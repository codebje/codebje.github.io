<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>λbje - Advent of Code, Day 2</title>
    <link rel="stylesheet" type="text/css" href="../css/main.css">
    <link rel="stylesheet" type="text/css" href="../css/animation.css">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700|Open+Sans:300|Source+Code+Pro:300,500&subset=latin,latin-ext" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <link rel="canonical" href="{{ page.url | replace:'index.html','' | prepend: site.baseurl | prepend: site.url }}">
    <link rel="alternate" type="application/atom+xml" title="Typed Out" href="../atom.xml" />
    
    <link rel="stylesheet" type="text/css" href="../css/literate.css">
    
  </head>
  <body>
    <header class="site-header">
      <div class="wrapper">
        <a class="site-title" href="../">Typed out</a>

        <nav class="site-nav">
          <a href="#" class="menu-icon">
            <svg viewBox="0 0 18 15">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
            </svg>
          </a>

          <div class="trigger">
            <a class="page-link" href="../about.html">About</a>
            <a class="page-link" href="../archive.html">Archive</a>
          </div>
        </nav>

      </div>
    </header>

    <div class="page-content">
      <div class="wrapper">
        <header class="post-header">
  
    <img class="post-logo" src="../images/calendar.svg">
  
  <h1 class="post-title">Advent of Code, Day 2</h1>
  <p class="post-meta">December  3, 2019 • bje</p>
</header>

<article class="post-content">
  


  <p>The <a href="aoc">Advent of Code</a>, day 2, involves an interpreted integer computer, with three opcodes. The first task is to interpret the (self-modifying) program and find the output value - this is straightforward. The second task is to find two initial memory values that produce a fixed output value. This task is the subject of today’s post.</p>
<p><!--more--></p>
<p>This post is presented as literate Haskell, but since I don’t provide you with the source of the site you’ll have to cut and paste it bit by bit to run it. Maybe some day I’ll improve on that, but not today.</p>
<p>No imports, no language extensions, let’s keep this one simple.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span></code></pre></div>
<p>Each participant gets a unique puzzle input. Mine has been cut and pasted into the program code below, because reading a text file isn’t the interesting part of the problem.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">puzzle ::</span> [<span class="dt">Int</span>]</span>
<span id="cb2-2"><a href="#cb2-2"></a>puzzle <span class="ot">=</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    [  <span class="dv">1</span>, <span class="dv">12</span>,  <span class="dv">2</span>,  <span class="dv">3</span>,  <span class="dv">1</span>,  <span class="dv">1</span>,  <span class="dv">2</span>,  <span class="dv">3</span>,  <span class="dv">1</span>,  <span class="dv">3</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    ,  <span class="dv">4</span>,  <span class="dv">3</span>,  <span class="dv">1</span>,  <span class="dv">5</span>,  <span class="dv">0</span>,  <span class="dv">3</span>,  <span class="dv">2</span>,  <span class="dv">6</span>,  <span class="dv">1</span>, <span class="dv">19</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    ,  <span class="dv">1</span>, <span class="dv">19</span>,  <span class="dv">5</span>, <span class="dv">23</span>,  <span class="dv">2</span>, <span class="dv">10</span>, <span class="dv">23</span>, <span class="dv">27</span>,  <span class="dv">2</span>, <span class="dv">27</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    , <span class="dv">13</span>, <span class="dv">31</span>,  <span class="dv">1</span>, <span class="dv">10</span>, <span class="dv">31</span>, <span class="dv">35</span>,  <span class="dv">1</span>, <span class="dv">35</span>,  <span class="dv">9</span>, <span class="dv">39</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    ,  <span class="dv">2</span>, <span class="dv">39</span>, <span class="dv">13</span>, <span class="dv">43</span>,  <span class="dv">1</span>, <span class="dv">43</span>,  <span class="dv">5</span>, <span class="dv">47</span>,  <span class="dv">1</span>, <span class="dv">47</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>    ,  <span class="dv">6</span>, <span class="dv">51</span>,  <span class="dv">2</span>,  <span class="dv">6</span>, <span class="dv">51</span>, <span class="dv">55</span>,  <span class="dv">1</span>,  <span class="dv">5</span>, <span class="dv">55</span>, <span class="dv">59</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>    ,  <span class="dv">2</span>,  <span class="dv">9</span>, <span class="dv">59</span>, <span class="dv">63</span>,  <span class="dv">2</span>,  <span class="dv">6</span>, <span class="dv">63</span>, <span class="dv">67</span>,  <span class="dv">1</span>, <span class="dv">13</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>    , <span class="dv">67</span>, <span class="dv">71</span>,  <span class="dv">1</span>,  <span class="dv">9</span>, <span class="dv">71</span>, <span class="dv">75</span>,  <span class="dv">2</span>, <span class="dv">13</span>, <span class="dv">75</span>, <span class="dv">79</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>    ,  <span class="dv">1</span>, <span class="dv">79</span>, <span class="dv">10</span>, <span class="dv">83</span>,  <span class="dv">2</span>, <span class="dv">83</span>,  <span class="dv">9</span>, <span class="dv">87</span>,  <span class="dv">1</span>,  <span class="dv">5</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>    , <span class="dv">87</span>, <span class="dv">91</span>,  <span class="dv">2</span>, <span class="dv">91</span>,  <span class="dv">6</span>, <span class="dv">95</span>,  <span class="dv">2</span>, <span class="dv">13</span>, <span class="dv">95</span>, <span class="dv">99</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>    ,  <span class="dv">1</span>, <span class="dv">99</span>,  <span class="dv">5</span>,<span class="dv">103</span>,  <span class="dv">1</span>,<span class="dv">103</span>,  <span class="dv">2</span>,<span class="dv">107</span>,  <span class="dv">1</span>,<span class="dv">107</span></span>
<span id="cb2-14"><a href="#cb2-14"></a>    , <span class="dv">10</span>,  <span class="dv">0</span>, <span class="dv">99</span>,  <span class="dv">2</span>,  <span class="dv">0</span>, <span class="dv">14</span>,  <span class="dv">0</span></span>
<span id="cb2-15"><a href="#cb2-15"></a>    ]</span></code></pre></div>
<p>Each number is a memory cell value. The interpreter has an instruction pointer initialised to zero, and recognises three opcodes: <code>1</code> is addition, <code>2</code> is multiplication, and <code>99</code> halts the program. The two numeric instructions have three arguments, each an indirect address. The first is the address of the left operand, the second the right operand, and the third the result address. In the puzzle input above, <code class="sourceCode haskell"><span class="dv">1</span>, <span class="dv">12</span>, <span class="dv">2</span>, <span class="dv">3</span></code> represents the addition opcode, which will add the contents of memory cells 12 and 2 and store the result in memory cell 3.</p>
<p>The second and third cells are the variables. The numbers above are the required values for the first part of the task - what value do you get in memory cell zero after executing this program. The second part of the task is to find values that mean the end result is the value 19690720 (the date of the first moon landing). The obvious approach is to try combinations until the right answer is output: my initial solution was to manually try a few numbers to see how the output varied with respect to the input, and derive a formula.</p>
<p>Hoever, this problem should be solvable directly, without using trial and error.</p>
<p>Each step of the program computes a new value for some memory cell using other memory cells. The trick with the second task is that two of the memory cells have no defined value: the final value in cell zero will be some expression of two variables. The solution, then, is to construct that expression directly, and solve it for the two variables.</p>
<p>The value to be computed will be an expression tree, where the leaves are either literal integers taken from program memory, or variables identified by their memory location. The branches are one of the two operations.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">Lit</span> <span class="dt">Int</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>          <span class="op">|</span> <span class="dt">Var</span> <span class="dt">Int</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>          <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>          <span class="op">|</span> <span class="dt">Mul</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>          <span class="kw">deriving</span> <span class="dt">Show</span></span></code></pre></div>
<p>An expression can be evaluted to a result as long as it has no variables in it. This is where my code goes off the rails already: I use <code class="sourceCode haskell"><span class="fu">error</span></code> instead of putting the partiality into the type. I’ll forgive myself, and as the only reader of my blog, therefore all my readers also forgive me.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">evaluate ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>evaluate (<span class="dt">Lit</span> x)   <span class="ot">=</span> x</span>
<span id="cb4-3"><a href="#cb4-3"></a>evaluate (<span class="dt">Var</span> x)   <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;evaluating variable&quot;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>evaluate (<span class="dt">Add</span> a b) <span class="ot">=</span> evaluate a <span class="op">+</span> evaluate b</span>
<span id="cb4-5"><a href="#cb4-5"></a>evaluate (<span class="dt">Mul</span> a b) <span class="ot">=</span> evaluate a <span class="op">*</span> evaluate b</span></code></pre></div>
<p>If there are variables, the expression can have those variables substituted for values.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">subst ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>subst var val (<span class="dt">Lit</span> x)   <span class="ot">=</span> <span class="dt">Lit</span> x</span>
<span id="cb5-3"><a href="#cb5-3"></a>subst var val (<span class="dt">Var</span> x)   <span class="ot">=</span> <span class="kw">if</span> var <span class="op">==</span> x <span class="kw">then</span> <span class="dt">Lit</span> val <span class="kw">else</span> <span class="dt">Var</span> x</span>
<span id="cb5-4"><a href="#cb5-4"></a>subst var val (<span class="dt">Add</span> a b) <span class="ot">=</span> <span class="dt">Add</span> (subst var val a) (subst var val b)</span>
<span id="cb5-5"><a href="#cb5-5"></a>subst var val (<span class="dt">Mul</span> a b) <span class="ot">=</span> <span class="dt">Mul</span> (subst var val a) (subst var val b)</span></code></pre></div>
<p>My code’s off-the-railness continues, with boolean blindness in the arguments, and recursion everywhere instead of catamorphisms. If you promise to stop being judgemental, I promise to stop being self-deprecating.</p>
<p>The first stage in solving the problem is to convert the initial memory footprint into an expression for the final value. The <code class="sourceCode haskell">mkExpr</code> function takes a list of variable positions and a program memory and produces a list of expression memory. The literal memory is first converted into expressions that are either a <code class="sourceCode haskell"><span class="dt">Lit</span></code> or a <code class="sourceCode haskell"><span class="dt">Var</span></code>, depending on the <code class="sourceCode haskell">vars</code> argument.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">mkExpr ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Expr</span>]</span>
<span id="cb6-2"><a href="#cb6-2"></a>mkExpr vars program <span class="ot">=</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="kw">let</span> cells <span class="ot">=</span> <span class="fu">zipWith</span> eval program [<span class="dv">0</span><span class="op">..</span>]        <span class="co">-- initial value</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>        eval c i <span class="ot">=</span> <span class="kw">if</span> i <span class="ot">`elem`</span> vars <span class="kw">then</span> <span class="dt">Var</span> i <span class="kw">else</span> <span class="dt">Lit</span> c</span>
<span id="cb6-5"><a href="#cb6-5"></a>     <span class="kw">in</span> interpret cells <span class="dv">0</span></span></code></pre></div>
<p>The expression program is now interpreted, starting with an instruction pointer of zero.</p>
<p>The opcode to be executed must be evaluated first. Self-modifying code is fine, but code where the opcodes depend on variables is not - they’ll cause an <code class="sourceCode haskell"><span class="fu">error</span></code> in <code class="sourceCode haskell">evaluate</code>. Since opcodes that depend on variables would mean the majority of programs are invalid, I do not expect this result. Spoiler: the assumption was valid. Also valid was the assumption that the instruction pointer would never stray out of bounds.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">interpret ::</span> [<span class="dt">Expr</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Expr</span>]</span>
<span id="cb7-2"><a href="#cb7-2"></a>interpret cells ip <span class="ot">=</span> <span class="kw">case</span> evaluate (cells <span class="op">!!</span> ip) <span class="kw">of</span></span></code></pre></div>
<p>The two functional opcodes perform their respective operation, increase the instruction pointer, and tail-recursively continue interpretation. The halting opcode returns the current view of memory.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a>    <span class="dv">1</span>  <span class="ot">-&gt;</span> interpret (add cells ip) (ip <span class="op">+</span> <span class="dv">4</span>)</span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="dv">2</span>  <span class="ot">-&gt;</span> interpret (mul cells ip) (ip <span class="op">+</span> <span class="dv">4</span>)</span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="dv">99</span> <span class="ot">-&gt;</span> cells</span></code></pre></div>
<p>Any other opcode results in the dreaded <code class="sourceCode haskell"><span class="fu">error</span></code> again. This time with a little debug info, although the error never arose.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a>    _  <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;invalid opcode &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> (cells <span class="op">!!</span> ip) <span class="op">&lt;&gt;</span> <span class="st">&quot; at &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> ip</span></code></pre></div>
<p>Performing an operation requires that the cell addresses can be evaluated. This is less of a firm assumption, as there would be many possible variable assignments that lead to functional but incorrect programs; for operands in particular programs would remain valid for all in-bounds addresses. Fortunately, this assumption also panned out.</p>
<p>The operand cells have their expressions retrieved. The destination cell is updated with a new expression using the two operands.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a>  <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>    op f cells ip <span class="ot">=</span> <span class="kw">let</span> a <span class="ot">=</span> cells <span class="op">!!</span> (evaluate <span class="op">$</span> cells <span class="op">!!</span> (ip <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb10-3"><a href="#cb10-3"></a>                        b <span class="ot">=</span> cells <span class="op">!!</span> (evaluate <span class="op">$</span> cells <span class="op">!!</span> (ip <span class="op">+</span> <span class="dv">2</span>))</span>
<span id="cb10-4"><a href="#cb10-4"></a>                        t <span class="ot">=</span> evaluate (cells <span class="op">!!</span> (ip <span class="op">+</span> <span class="dv">3</span>))</span>
<span id="cb10-5"><a href="#cb10-5"></a>                    <span class="kw">in</span> <span class="fu">take</span> t cells <span class="op">&lt;&gt;</span> (f a b <span class="op">:</span> <span class="fu">drop</span> (t <span class="op">+</span> <span class="dv">1</span>) cells)</span>
<span id="cb10-6"><a href="#cb10-6"></a>    add <span class="ot">=</span> op <span class="dt">Add</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>    mul <span class="ot">=</span> op <span class="dt">Mul</span></span></code></pre></div>
<p>The example program from the task is <code class="sourceCode haskell">[<span class="dv">1</span>, <span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">11</span>, <span class="dv">0</span>, <span class="dv">99</span>, <span class="dv">30</span>, <span class="dv">40</span>, <span class="dv">50</span>]</code>. With no variables defined, this program produces an expression tree:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a>mkExpr [] [<span class="dv">1</span>, <span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">11</span>, <span class="dv">0</span>, <span class="dv">99</span>, <span class="dv">30</span>, <span class="dv">40</span>, <span class="dv">50</span>] <span class="ot">=</span> <span class="dt">Mul</span> (<span class="dt">Add</span> (<span class="dt">Lit</span> <span class="dv">30</span>)</span>
<span id="cb11-2"><a href="#cb11-2"></a>                                                                (<span class="dt">Lit</span> <span class="dv">40</span>))</span>
<span id="cb11-3"><a href="#cb11-3"></a>                                                           (<span class="dt">Lit</span> <span class="dv">50</span>)</span></code></pre></div>
<p>And sure enough, (30 + 40) * 50 = 3500, the expected result.</p>
<p>Reading an expression tree isn’t all that fun though, so I added a pretty-printer that would parenthesis according to operator precedence:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="ot">pretty ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>pretty <span class="ot">=</span> pretty' <span class="dv">0</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>  <span class="kw">where</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>    pretty' p (<span class="dt">Lit</span> n) <span class="ot">=</span> <span class="fu">show</span> n</span>
<span id="cb12-5"><a href="#cb12-5"></a>    pretty' p (<span class="dt">Var</span> n) <span class="ot">=</span> <span class="st">&quot;v&quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> n</span>
<span id="cb12-6"><a href="#cb12-6"></a>    pretty' p (<span class="dt">Add</span> a b) <span class="ot">=</span> lparen p <span class="dv">1</span> <span class="op">&lt;&gt;</span> pretty' <span class="dv">1</span> a <span class="op">&lt;&gt;</span> <span class="st">&quot; + &quot;</span> <span class="op">&lt;&gt;</span> pretty' <span class="dv">1</span> b <span class="op">&lt;&gt;</span> rparen p <span class="dv">1</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>    pretty' p (<span class="dt">Mul</span> a b) <span class="ot">=</span> lparen p <span class="dv">2</span> <span class="op">&lt;&gt;</span> pretty' <span class="dv">2</span> a <span class="op">&lt;&gt;</span> <span class="st">&quot; * &quot;</span> <span class="op">&lt;&gt;</span> pretty' <span class="dv">2</span> b <span class="op">&lt;&gt;</span> rparen p <span class="dv">2</span></span>
<span id="cb12-8"><a href="#cb12-8"></a>    lparen p q <span class="ot">=</span> <span class="kw">if</span> p <span class="op">&gt;</span> q <span class="kw">then</span> <span class="st">&quot;(&quot;</span> <span class="kw">else</span> <span class="st">&quot;&quot;</span></span>
<span id="cb12-9"><a href="#cb12-9"></a>    rparen p q <span class="ot">=</span> <span class="kw">if</span> p <span class="op">&gt;</span> q <span class="kw">then</span> <span class="st">&quot;)&quot;</span> <span class="kw">else</span> <span class="st">&quot;&quot;</span></span></code></pre></div>
<p>The result is easier to follow, and can be cut and paste into a command line calculator.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a>pretty (<span class="dt">Mul</span> (<span class="dt">Add</span> (<span class="dt">Lit</span> <span class="dv">30</span>) (<span class="dt">Lit</span> <span class="dv">40</span>)) (<span class="dt">Lit</span> <span class="dv">50</span>)) <span class="ot">=</span> (<span class="dv">30</span> <span class="op">+</span> <span class="dv">40</span>) <span class="op">*</span> <span class="dv">50</span></span></code></pre></div>
<p>And if the pretty printer is run on the expression result for the puzzle input with two variables:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a>pretty <span class="op">$</span>  mkExpr [<span class="dv">1</span>,<span class="dv">2</span>] puzzle <span class="op">!!</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dv">5</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">+</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> <span class="dv">3</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>        ((<span class="dv">4</span> <span class="op">+</span> <span class="dv">4</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> v1 <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">3</span>) <span class="op">*</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span>))) <span class="op">+</span> <span class="dv">4</span>) <span class="op">*</span> <span class="dv">3</span>) <span class="op">*</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span> <span class="op">+</span> v2 <span class="op">+</span> <span class="dv">4</span></span></code></pre></div>
<p>The first observation to note about this is that <code>v2</code> is a simple offset, while <code>v1</code> has a multiplier. The equation will be of the form <span class="math inline">\(ax + y + b\)</span>, but first it must be simplified to reduce all those literals down to just <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="ot">simplify ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span></code></pre></div>
<p>This is an unremarkable expression simplifier, of the kind you’ll encounter over and over in any introduction to theorem proving, and many introductions to functional programming. The general gist of the addition simplifier is to look for opportunities to convert expressions of the form <code class="sourceCode haskell"><span class="dt">Add</span> (expr (<span class="dt">Lit</span> x)) (<span class="dt">Lit</span> y)</code> (i.e. “(expr + val) + val”) into expressions of the form <code class="sourceCode haskell"><span class="dt">Add</span> expr (<span class="dt">Lit</span> <span class="op">$</span> x <span class="op">+</span> y)</code>, removing one layer of nested addition. To accomplish this, the addition of two literals is immediately collapsed to one literal, any remaining literals on the left are moved to the right, the target sub-addition form is simplified, and any remaining nested literal additions have the literal moved to the outer expression.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a>simplify (<span class="dt">Add</span> a b) <span class="ot">=</span> <span class="kw">let</span> a' <span class="ot">=</span> simplify a</span>
<span id="cb16-2"><a href="#cb16-2"></a>                         b' <span class="ot">=</span> simplify b</span>
<span id="cb16-3"><a href="#cb16-3"></a>                      <span class="kw">in</span> <span class="kw">case</span> (a', b') <span class="kw">of</span></span>
<span id="cb16-4"><a href="#cb16-4"></a>                            (<span class="dt">Lit</span> x, <span class="dt">Lit</span> y)         <span class="ot">-&gt;</span> <span class="dt">Lit</span> (x <span class="op">+</span> y)</span>
<span id="cb16-5"><a href="#cb16-5"></a>                            (<span class="dt">Lit</span> _, _)             <span class="ot">-&gt;</span> simplify (<span class="dt">Add</span> b' a')</span>
<span id="cb16-6"><a href="#cb16-6"></a>                            (<span class="dt">Add</span> x (<span class="dt">Lit</span> y), <span class="dt">Lit</span> z) <span class="ot">-&gt;</span> <span class="dt">Add</span> x (<span class="dt">Lit</span> <span class="op">$</span> y <span class="op">+</span> z)</span>
<span id="cb16-7"><a href="#cb16-7"></a>                            (<span class="dt">Add</span> x (<span class="dt">Lit</span> y), z)     <span class="ot">-&gt;</span> <span class="dt">Add</span> (<span class="dt">Add</span> x z) (<span class="dt">Lit</span> y)</span>
<span id="cb16-8"><a href="#cb16-8"></a>                            _                      <span class="ot">-&gt;</span> <span class="dt">Add</span> a' b'</span></code></pre></div>
<p>Multiplication looks for the same nested pattern. In addition, multiplication looks for the opportunity to distribute a literal multiplier into an addition where it can be recursively simplified.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a>simplify (<span class="dt">Mul</span> a b) <span class="ot">=</span> <span class="kw">let</span> a' <span class="ot">=</span> simplify a</span>
<span id="cb17-2"><a href="#cb17-2"></a>                         b' <span class="ot">=</span> simplify b</span>
<span id="cb17-3"><a href="#cb17-3"></a>                      <span class="kw">in</span> <span class="kw">case</span> (a', b') <span class="kw">of</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>                            (<span class="dt">Lit</span> x, <span class="dt">Lit</span> y)         <span class="ot">-&gt;</span> <span class="dt">Lit</span> (x <span class="op">*</span> y)</span>
<span id="cb17-5"><a href="#cb17-5"></a>                            (<span class="dt">Lit</span> _, _)             <span class="ot">-&gt;</span> simplify (<span class="dt">Mul</span> b' a')</span>
<span id="cb17-6"><a href="#cb17-6"></a>                            (<span class="dt">Mul</span> x (<span class="dt">Lit</span> y), <span class="dt">Lit</span> z) <span class="ot">-&gt;</span> <span class="dt">Mul</span> x (<span class="dt">Lit</span> <span class="op">$</span> y <span class="op">*</span> z)</span>
<span id="cb17-7"><a href="#cb17-7"></a>                            (<span class="dt">Mul</span> x (<span class="dt">Lit</span> y), z)     <span class="ot">-&gt;</span> <span class="dt">Mul</span> (<span class="dt">Mul</span> x z) (<span class="dt">Lit</span> y)</span>
<span id="cb17-8"><a href="#cb17-8"></a>                            (<span class="dt">Add</span> x y, <span class="dt">Lit</span> _)       <span class="ot">-&gt;</span> <span class="dt">Add</span> (simplify (<span class="dt">Mul</span> x b'))</span>
<span id="cb17-9"><a href="#cb17-9"></a>                                                          (simplify (<span class="dt">Mul</span> y b'))</span>
<span id="cb17-10"><a href="#cb17-10"></a>                            _                        <span class="ot">-&gt;</span> <span class="dt">Mul</span> a' b'</span></code></pre></div>
<p>Anything else is a literal or a variable, and cannot be simplified further.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a>simplify cell <span class="ot">=</span> cell</span></code></pre></div>
<p>At this point, it’s a good idea to verify that <code class="sourceCode haskell">simplify</code> works as expected. I threw in the weakest kind of testing possible: check that evaluating my puzzle input when both simplified and unsimplified, using the task one values, produces the same output. This doesn’t check that I’ve simplified all possible expression forms, correctly or otherwise, only those encountered in my input. Ideally, it would use property-based checking to cover a wide range of variable values and programs, but I’m comfortable enough with this minor check on correctness.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a><span class="ot">test ::</span> <span class="dt">IO</span> ()</span>
<span id="cb19-2"><a href="#cb19-2"></a>test <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>    <span class="kw">let</span> expr <span class="ot">=</span> mkExpr [<span class="dv">1</span>, <span class="dv">2</span>] puzzle <span class="op">!!</span> <span class="dv">0</span></span>
<span id="cb19-4"><a href="#cb19-4"></a>    <span class="kw">let</span> r1 <span class="ot">=</span> evaluate <span class="op">$</span> subst <span class="dv">2</span> <span class="dv">2</span> <span class="op">$</span> subst <span class="dv">1</span> <span class="dv">12</span> expr</span>
<span id="cb19-5"><a href="#cb19-5"></a>    <span class="kw">let</span> r2 <span class="ot">=</span> evaluate <span class="op">$</span> subst <span class="dv">2</span> <span class="dv">2</span> <span class="op">$</span> subst <span class="dv">1</span> <span class="dv">12</span> <span class="op">$</span> simplify expr</span>
<span id="cb19-6"><a href="#cb19-6"></a>    <span class="fu">print</span> r1</span>
<span id="cb19-7"><a href="#cb19-7"></a>    <span class="fu">print</span> r2</span></code></pre></div>
<p>Let’s take a look at my puzzle’s simplified expression.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a>pretty <span class="op">$</span> simplify <span class="op">$</span> mkExpr [<span class="dv">1</span>,<span class="dv">2</span>] puzzle <span class="op">!!</span> <span class="dv">0</span> <span class="ot">=</span> v1 <span class="op">*</span> <span class="dv">360000</span> <span class="op">+</span> v2 <span class="op">+</span> <span class="dv">250635</span></span></code></pre></div>
<p>This is now of the expected form. Solving this by hand is, of course, trivial, but we’re not here to do things by hand. Except write code, which we’re dong by hand. The last important step is instead to compute the final answer. The expression above must equal <code class="sourceCode haskell"><span class="dv">19690720</span></code> to satisfy the task, giving an equation to solve. Fortunately, it’s a given that there is a unique integer solution, so a solver is trivial. Added literals are subtracted from both sides. Multiplied literals will produce a quotient and a remainder when dividing both sides, so an expression such as <span class="math inline">\(ax + y = b\)</span> means <span class="math inline">\(x\)</span> is the quotient and <span class="math inline">\(y\)</span> is the remainder.</p>
<p>If the simplifier has failed to reduce the expression into one of these forms, the solver will also fail. Which it does not, for my puzzle input.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a><span class="ot">solve ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)]</span>
<span id="cb21-2"><a href="#cb21-2"></a>solve (<span class="dt">Var</span> x) t                 <span class="ot">=</span> [(x, t)]</span>
<span id="cb21-3"><a href="#cb21-3"></a>solve (<span class="dt">Add</span> (<span class="dt">Mul</span> x (<span class="dt">Lit</span> y)) z) t <span class="ot">=</span> <span class="kw">let</span> (x', z') <span class="ot">=</span> t <span class="ot">`divMod`</span> y</span>
<span id="cb21-4"><a href="#cb21-4"></a>                                   <span class="kw">in</span> solve x x' <span class="op">&lt;&gt;</span> solve z z'</span>
<span id="cb21-5"><a href="#cb21-5"></a>solve (<span class="dt">Add</span> x (<span class="dt">Lit</span> y)) t         <span class="ot">=</span> solve x (t <span class="op">-</span> y)</span>
<span id="cb21-6"><a href="#cb21-6"></a>solve e t                       <span class="ot">=</span> <span class="fu">error</span> <span class="op">$</span> <span class="fu">show</span> e <span class="op">&lt;&gt;</span> <span class="st">&quot; = &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> t</span></code></pre></div>
<p>All that’s left to do is run the whole thing.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb22-2"><a href="#cb22-2"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb22-3"><a href="#cb22-3"></a>    <span class="kw">let</span> expr <span class="ot">=</span> simplify <span class="op">$</span> mkExpr [<span class="dv">1</span>, <span class="dv">2</span>] puzzle <span class="op">!!</span> <span class="dv">0</span></span>
<span id="cb22-4"><a href="#cb22-4"></a>    <span class="fu">putStrLn</span> <span class="op">$</span> pretty expr <span class="op">&lt;&gt;</span> <span class="st">&quot; = 19690720&quot;</span></span>
<span id="cb22-5"><a href="#cb22-5"></a>    <span class="kw">let</span> vars <span class="ot">=</span> solve expr <span class="dv">19690720</span></span>
<span id="cb22-6"><a href="#cb22-6"></a>    <span class="fu">maybe</span> (<span class="fu">error</span> <span class="st">&quot;no solution&quot;</span>) <span class="fu">print</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb22-7"><a href="#cb22-7"></a>        noun <span class="ot">&lt;-</span> <span class="fu">lookup</span> <span class="dv">1</span> vars</span>
<span id="cb22-8"><a href="#cb22-8"></a>        verb <span class="ot">&lt;-</span> <span class="fu">lookup</span> <span class="dv">2</span> vars</span>
<span id="cb22-9"><a href="#cb22-9"></a>        <span class="fu">pure</span> (noun <span class="op">*</span> <span class="dv">100</span> <span class="op">+</span> verb)</span></code></pre></div>
<p>Which produces the output:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a>v1 <span class="op">*</span> <span class="dv">360000</span> <span class="op">+</span> v2 <span class="op">+</span> <span class="dv">250635</span> <span class="ot">=</span> <span class="dv">19690720</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="dv">5485</span></span></code></pre></div>
<p>The icon for this post is copyright <a href="https://thenounproject.com/term/advent-calendar/28226/">Claire Jones</a>, used without modification under a Creative Commons license.</p>
</article>


      </div>
    </div>

    <footer class="site-footer">
      <div class="wrapper">

        <div class="footer-wrapper">
          <div class="social-media-list">
            <a href="http://twitter.com/codebje" title="codebje on Twitter" target="_blank"><i class="fa fa-twitter fa-2x"></i></a>
            <a href="http://linkedin.com/in/codebje" title="codebje on LinkedIn" target="_blank"><i class="fa fa-linkedin fa-2x"></i></a>
            <a href="http://github.com/codebje" title="codebje on Github" target="_blank"><i class="fa fa-github fa-2x"></i></a>
          </div>
          <div class="license">
            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
          </div>

        </div>

      </div>

    </footer>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-68687928-1', 'auto');
      ga('send', 'pageview');
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </body>
</html>
