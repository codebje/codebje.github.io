<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Typed Out</title>
    <link href="https://bje.id.au/blog/atom.xml" rel="self" />
    <link href="https://bje.id.au/blog" />
    <id>https://bje.id.au/blog/atom.xml</id>
    <author>
        <name>Byron Ellacott</name>
        <email></email>
    </author>
    <updated>2020-08-01T00:00:00Z</updated>
    <entry>
    <title>The TRS-20 - Will it work?</title>
    <link href="https://bje.id.au/blog/posts/trs20/015-testing-continues.html" />
    <id>https://bje.id.au/blog/posts/trs20/015-testing-continues.html</id>
    <published>2020-08-01T00:00:00Z</published>
    <updated>2020-08-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>With the board fully assembled, and USB enumeration working well enough to see the device, it’s time to see if the design is valid. Do I have a working Z180-based computer, or an expensive paperweight?</p>
<!--more-->
<h1 id="first-blink-the-lights">First, blink the lights</h1>
<p>My <a href="https://github.com/codebje/trs20-bootrom">initial bootrom</a> changes the CPU clock divider from EXTAL/2 to EXTAL/1 a few bytes into execution. With the FPGA reprogrammed to flash LED1 on a 24-bit divider, a 9.216MHz PHI will blink LED1 at 0.55Hz and an 18.432MHz PHI will blink it at 1.1Hz. With LED2 still on a 26-bit divider of the 100MHz oscillator, this provides an easy to observe visual guide to whether my boot ROM is executing at all.</p>
<p>Which lead me to discover that my boot ROM was not executing at all. The CPU was putting out a clock signal just fine, but at 9.216MHz, not 18.432MHz.</p>
<p>To verify the CPU was still okay after all my earlier fumbling about I put it back into the old debug board I built early on in the process, with an 18.432MHz can oscillator. My logic analyser showed it doing the expected signal dance - but I also recorded what happened as the CPU came out of /RESET, and saw that A19 stays high after /RESET has gone high. It stubbornly doesn’t fall until the address lines are being settled for the first machine cycle, which is up to 30ns after PHI rises for clock cycle T1. On top of that /M1 falls at most 35ns after PHI rises for T1. To the limits of accuracy of my very cheap 24MHz analyser, in practice /M1 falls at the same time as A19.</p>
<p>This is a significant oversight in my board design - the datasheet shows, if you look properly, that /M1 could fall before the address lines have settled. An earlier revision of my design used /MREQ instead of /M1, which can be seen in <a href="011-motherboard.html#memory">the design post</a> diagram. Despite my excessively detailed blog posts I neglected to document why I changed to /M1, but I believe it’s because I only wanted execution accesses to ROM to trigger the flip-flop. If I’d stuck with /MREQ then A19 would be settled low before /MREQ goes low, and this would have gone a bit smoother.</p>
<p>The consequence of all this is that the ROM overlay DFF is reset before the first memory read even happens, and ROM never gets read.</p>
<p>The good news is that there’s a simple fix to get the ROM overlay active at boot: I’ve put a 10kΩ 0603 resistor between the A19 and GND pins of the CPU socket, underneath the board. This pulls A19 low during reset, and it’s still low when /M1 falls for the first opcode fetch. Thereafter, the CPU continues to hold A19 low for each access.</p>
<p>With this fix in place, the LED starts to blink at twice the speed. I now have a computer that can run code!</p>
<h1 id="communication">Communication?</h1>
<p>After adjusting the clock speed the boot code’s next task is to set up ASCI0. As the ROM progresses from here it prints out the character sequence ‘1234567’, with each character indicating successful completion of another step of the boot-up.</p>
<p>Perhaps predictably by now, my serial terminal remained stubbornly blank. No output at all - but due to another questionable design choice, I wasn’t sure this meant the boot code was failing to transmit a character or not. This time it was the fact that the /RESET line also resets the FT230X USB IC. This causes the serial port to disconnect and reconnect; the FT230X datasheet doesn’t specify a time range for this but it will read the internal memory to configure the USB descriptors, enumerate as a USB device, and negotiate a connection. That’s enough work to be a non-trivial amount of time.</p>
<p>So - with no way to talk to the CPU to find out what’s going on, I resorted to the logic analyser. My analyser has eight lines, so it cannot monitor the entire bus at once, but it can watch some pins and check they’re behaving. I checked the ROM’s /CE and /OE pins, which were firing properly. I checked, rechecked, triple checked, and dispiritedly checked the ASCI0 lines to the FT230X. Without a reset button, I resorted to five second samples at a slow rate, before finally cluing in that I could pull /WAIT low through the bus header, and freeze the CPU to inspect what it was doing.</p>
<p>Freezing the CPU after it had run for a little while showed it had gone out to lunch in the middle of memory where no predictable value could be expected. It also showed that the transceiver pin for A12 was poorly soldered, but while that needed fixing it wasn’t in a position to be causing any faults.</p>
<p>Freezing the CPU before it finished the first opcode fetch showed the right values on address and data lines.</p>
<p>So - somewhere in between the first byte read, and thousands of cycles later, the CPU goes a bit nuts.</p>
<h1 id="debugging-a-cpu-board">Debugging a CPU board</h1>
<p>It’s impractical to try and whip a jumper lead in and out of the /WAIT header and expect to see anything meaningful going on. However, my board has a powerful tool available on in the form of the FPGA. Most of the board’s signals are connected to an FPGA pin so it has broad insight into the workings of the CPU. It also has a view of the /WAIT signal.</p>
<p>What it does need is a way to tell me what’s going on. Since the FPGA is expected to eventually run an I2C bus, I thought it’d be convenient to give it an I2C slave interface for a µC to drive. The FPGA can drive /WAIT low when /MREQ or /IORQ falls, capture address and data lines, and send all that information to the µC in a four byte burst.</p>
<p>Rather than trying to greenfields my own I2C module, I read over a handful of existing implementations. In the end I used one by Daniel Beer that has <a href="https://dlbeer.co.nz/articles/i2c.html">a truly excellent explanation</a>. Since it’s unlicensed, my FPGA code for this single step debugger is unpublished, but it’s not rocket surgery. I did get to learn about crossing clock domains though, to have an effective signal between an I2C event indicating the CPU should proceed to the next instruction and the CPU’s <em>much faster</em> clock cycle.</p>
<p>This work uncovered a bad solder job on A5 of the FPGA, which I also fixed. And amazingly, I had completely failed to solder one side of one of the I2C pull-up resistors. I hope that’s it for bad solder jobs, because the volume of them makes a mockery of the amount of connectivity testing I did.</p>
<p>The FPGA sends /MREQ, /IORQ, /RD, /RW, and the high four bits of the address bus in the first byte. The next two bytes are the rest of the address bus, and the data bus follows. After all four bytes have been read, the CPU is permitted to proceed.</p>
<p>On the µC side of things I just used an ESP8266 as a convenient 3v3 device, and programmed it using Arduino IDE. After a few iterations I wound up with something that could single step, run a number of steps, run to an address access, and set breakpoints. Its output looks something like this:</p>
<pre><code>MiRw 0016D  ED (11101101)
MiRw 0016E  39 (00111001)
MiRw 0016F  38 (00111000)</code></pre>
<p>… which is the CPU fetching and executing <code class="sourceCode z80asm">out0 (CBR), <span class="at">a</span></code>.</p>
<p>The debug tool showed that without a USB connection, the boot ROM pauses waiting for the transmit data register empty (TDRE) flag to be set for ASCI0. When that flag is set, the CPU writes ‘1’ - and the serial terminal receives it. This confirms my hunch that the USB IC is still resetting when the CPU starts writing to it. And confirms that the serial link works!</p>
<p>I had mixed up my boot code somehow and tried to do the MMU work right in the middle of setting up the DMA registers. Once I fixed this, I could watch the DMA executing its copy loop, reading from ROM and writing to RAM byte by byte.</p>
<p>I also discovered that the MMU base registers are added to the logical address: if Common Area 1 starts at <code class="sourceCode z80asm"><span class="bn">$F000</span></code> with a base register of <code class="sourceCode z80asm"><span class="bn">$80</span></code> the physical address is <code class="sourceCode z80asm"><span class="bn">$8F000</span></code>. This makes sense from an implementation perspective - it’s a single 8-bit adder involved - and was an easy fix to set CBAR to <code class="sourceCode z80asm"><span class="bn">$71</span></code> instead.</p>
<p>The remaining consequences of my choice to use /M1 then became apparent. A memory access to ROM space would set A19 high, with /M1 also high, no problem so far. But the next machine cycle would lower /M1 at around the same time as A19, with enough overlap between them for my flip-flop to be reset. The safest action is to jump to ROM as soon as possible, without allowing any other access to ROM space to happen first.</p>
<p>I re-ordered the boot code to set up the MMU first, jumped to ROM space, ran the DMA copy from there, then jumped back to, in theory, SRAM.</p>
<p>A transmit test that modified code showed that yes, I had code running out of SRAM.</p>
<h1 id="rough-consensus-and-running-code"><del>Rough consensus and</del> running code</h1>
<p>Let’s take a moment to absorb this.</p>
<p>I have a <em>working computer</em>. It has boot ROM, working memory, and enough peripherals for me to interact with it.</p>
<p>There’s plenty more to do from here, the Y-modem upload doesn’t work, I have nothing useful to upload, the FPGA isn’t capable of self-programming yet, and there are other boards I expect to add on over time. There’s even a laundry list of things I’d do differently on a second revision of the CPU board.</p>
<p>But none of that matters just as this exact moment: demonstrating running code on the board means this project is now a success.</p>
<p><img src="/images/trs20/logo.svg" /></p>]]></summary>
</entry>
<entry>
    <title>The TRS-20 - Finishing assembly</title>
    <link href="https://bje.id.au/blog/posts/trs20/014-finish-assembly.html" />
    <id>https://bje.id.au/blog/posts/trs20/014-finish-assembly.html</id>
    <published>2020-07-21T00:00:00Z</published>
    <updated>2020-07-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I claimed in the last post that, with blinking lights achieved, the job was done.</p>
<p>Of course, the job is not really done. Most of the board’s parts aren’t soldered on, and while it’s great that the FPGA works I’ve still yet to get the CPU on. Not to mention all the supporting chips. Time to break out the heat gun and get on with the task.</p>
<!--more-->
<p>I put on the FT230X USB IC first, plus its supporting connector and passives. This is for two reasons: I can program the GPIOs on it to ensure the correct VBus sense function and LED output, and because this is the last checkpoint beore I solder on every other part. This worked out fine - the device enumerates correctly, programs fine, and the RX LED flickers in time to keystrokes via USB serial.</p>
<figure>
<img src="/images/trs20/enumerated.png" alt="" /><figcaption>My shell history is chockers full of <code>lsusb</code> commands now.</figcaption>
</figure>
<p>Soldering everything else took a few evenings. My process was to squeeze a blob of solder paste onto the DDPAK tab copper area on a board with a bad FPGA solder job, align the target IC with its pads, then use a toothpick to place a sparing amount of paste on the pins. The heat gun then melts the paste onto the pins, and any faults are touched up with the iron.</p>
<figure>
<img src="/images/trs20/memory-pins.jpg" alt="" /><figcaption>I really should get some kind of macro lens for this stuff.</figcaption>
</figure>
<p>The best result was the SRAM. It’s possible there’s not quite enough solder on these pins, but I tested every one - I actually found two cold solder joints on the FPGA during this process - and I’m confident they’re all wetted properly.</p>
<p>The worst result was the 18.432MHz oscillator. I underestimated the difficulty of this job, and wound up with far too much solder on it. Solder from the NC pad reached the ground-connected case, and removing it was difficult. I do not feel confident that this part is healthy now.</p>
<h2 id="install-a-rom">Install a ROM</h2>
<p>The trouble with having finished the soldering is that I don’t much want to blindly power up. The ROM should contain <code>FF</code> endlessly, which will result in the CPU executing <code class="sourceCode z80asm">RST <span class="bn">$38</span></code> forever, but it’d be nice to be able to verify in some way that everything’s working as it should. This takes me back to writing a ROM again, but this time for the CPU.</p>
<p>So I wrote a <a href="https://github.com/codebje/trs20-bootrom/blob/master/src/bootrom.asm">ROM image</a> that sets up ASCI0 to 38400 baud, 8n1, and starts transmitting single character “printf debugging” style progress markers. The only things I do first are to disable DRAM refresh, disable external interrupts, and set the clock rate to the full oscillator speed.</p>
<p>After that, the boot ROM attempts to copy ROM into RAM, reset the ROM overlay D flip-flop, configure the MMU, set up a 100Hz timer, set up a stack, then run a very simple boot monitor that permits a binary to be uploaded using ymodem and executed.</p>
<p>Because I really don’t want to yank the PLCC-32 ROM chip in and out frequently, I don’t want too many rounds of corrections. My <a href="https://github.com/codebje/vtrs20">emulator</a> is therefore developing more or less in lockstep with the needs of the boot ROM so that I at least have to implement the same bug twice in more or less the same way to miss it. This is a feat I have accomplished in the past, and it’s surprisingly easy to do.</p>
<p>I burned the ROM, plugged it into the board, and with bated breath powered the board up. Good news: the FLT light doesn’t immediately go on, so there’s no major short circuit anywhere. The FPGA still blinks its LED, and the rest sits there, reminding me that I didn’t design in an obvious indicator of CPU health.</p>
<p>I plugged the USART USB cable in, and …</p>
<p><img src="/images/trs20/whereswally.png" /></p>
<p>… used some adult language.</p>
<h2 id="debugging-a-usb-ic">Debugging a USB IC</h2>
<p>Nothing felt warm. The FLT light was still off. The FPGA was still blinking its LED, now looking more like a taunt than a sign of success.</p>
<p>I busted out the multimeter and did a bit of a probe around, carefully - there’s 3V3 and GND pins right next to each other on the FT230X - only to see all the expected levels. The reset supervisor is not touching /RESET, so it is pulled high by a resistor. The USB cable is delivering ~5V to the voltage divider network. With power removed, I rechecked everything for good solder joints or shorts - everything seems fine.</p>
<p>At a loss, I thought I may as well also test whether the CPU is at least clocking along, so I ran a logic analyser on PHI (and /RESET, to verify the supervisor at the logic level) - and saw only a flat line. The clock was not ticking. It turns out the oscillator just isn’t at all happy, and is not generating any signals. It may still have a short, it may just be toast, either way it’s gotta come off.</p>
<p>I’ve never had much luck desoldering through-hole parts. Solder wick takes a <em>lot</em> of heat to work, and isn’t great even then. My solder sucker was bundled with a cheap soldering iron, and was broken on arrival. I never replaced it. So with a bit of concern that it’d go wrong, I put some heatproof tape on the CPU’s socket and got to work with the heat gun.</p>
<p>To my surprise, I removed the oscillator quite easily. I figured I may as well also remove the FT230X - and this also went far better than I anticipated. Well enough, in fact, that I soldered the removed IC onto a TSSOP-16 breakout board. I replicated the CPU board’s USB circuitry fairly closely on a breadboard, then plugged it in.</p>
<figure>
<img src="/images/trs20/enumerated.png" alt="" /><figcaption>wat.</figcaption>
</figure>
<p>The chip is (I think) fine. I can dump its ROM, and I can make an LED flicker by sending to it using the virtual COM port driver.</p>
<p>So I rechecked the CPU board. I checked all the connections into the CPU, which are the only parts I didn’t replicate on the breadboard. I checked all the passives, in case I had a dud resistor or capacitor. Everything looked fine - so, not having much to lose here, I desoldered the poor IC from the breakout board and resoldered it to the CPU board.</p>
<figure>
<img src="/images/trs20/whereswally.png" alt="" /><figcaption>I admit I felt a little glum.</figcaption>
</figure>
<p>Well, that’s it. I can’t communicate with the CPU, I can’t see if it’s working, I’ve no idea what I could possibly do. I am unwilling to risk the price of another board assembly when there’s no apparent reason for failure.</p>
<p>I packed everything away, and nearly didn’t even write this post.</p>
<h2 id="the-next-day">The next day</h2>
<p>The only substantive difference between the breadboard setup and the CPU board setup is my admittedly less than perfect USB socket. So after <del>sulking</del>sleeping on it I tried measuring voltage levels on the breadboard vs. on the CPU board. I ran the USB socket without the main USB power applied to the board: this <em>in theory</em> is perfectly fine, as the FT230X tolerances are absolute, not expressed in terms of its supply voltage. But what I noticed was that VBUS was running at 2V, and D- at -0.5V, relative to ground supplied via the data USB. I checked an unconnected USB socket and got 5V and 0V respectively, with D+ at 3.3V. Hmm.</p>
<p>I reconnected the supply power for the CPU board, and re-measured. Now I saw 5V, 3.3V, and 0V for VBus, D+, and D-, which seemed right. At a loss, I tried one last thing:</p>
<figure>
<img src="/images/trs20/enumerated.png" alt="" /><figcaption>Why do you taunt me so?</figcaption>
</figure>
<p>It was enumerating again.</p>
<p>This should feel like a victory, but in truth it does not. I don’t know why it didn’t work, I don’t know why it started working, I don’t know whether it will stop working again in the future. But I ordered a replacement oscillator, and may as well press on.</p>
<figure>
<img src="/images/trs20/assembled%20board.jpg" alt="" /><figcaption>The fully assembled board.</figcaption>
</figure>]]></summary>
</entry>
<entry>
    <title>The TRS-20 - ROM programming</title>
    <link href="https://bje.id.au/blog/posts/trs20/013-program-roms.html" />
    <id>https://bje.id.au/blog/posts/trs20/013-program-roms.html</id>
    <published>2020-07-10T00:00:00Z</published>
    <updated>2020-07-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>The <a href="/posts/trs20/012-build-it.html">last post</a> left off after soldering on the FPGA and its companion parts: the SPI Flash ROM, the 100MHz oscillator, all the power parts, and the programmable LEDs. The only way to know if it’s been designed properly and attached to the board without error is to have it do something observable, like control the LEDs. And the only way to do that is to program the SPI ROM.</p>
<p>The easy way is to order a ROM programmer that can handle SPI Flash ROMs (and, preferably, also handle the parallel ROM). But what would I learn from that?</p>
<!--more-->
<p>Instead, let’s use my STM32 “black pill” board as a programmer, using the USB serial interface to control it. The STM32 is a 3.3v board with an on-die SPI controller - with only one hitch. My black pill no longer powers up. I’ve no idea why, it seems to be failing to get power through the USB C socket, but there’s nothing wrong by a visual inspection.</p>
<p>Oh well.</p>
<p>The idea works well enough for me that I don’t want to just leave it there. Instead, I’m replacing my black pill board with a Nucleo-64, specifically the NUCLEO-F411RE. This is a slightly improved IC compared to the black pill’s STM32F401CC, and the Nucleo board is likely to be a higher quality product than a $6 part from an anonymous manufacturer. The Nucleo-64 board format has enough pins for me to directly program the parallel ROM without using shift registers.</p>
<h1 id="spi-flash-wiring">SPI Flash wiring</h1>
<p>Pin selection for the SPI ROM is a little fiddly, as STM32CubeMX presents me with an image of the IC’s pins, but I care about the board’s layout. The ’F411 has five SPI peripherals, and each peripheral has a few options for pins; after not too much time I’d selected SPI3 using pins PC10, 11, and 12 for SCK, MISO, and MOSI respectively. These pins are all grouped together on a pair of pin headers on one side of the board, close enough to the power pins that a <a href="https://docs.wemos.cc/en/latest/d1_mini_shiled/protoboard.html">D1 protoshield board</a> with a 2x8 female header can cover GND, 3V3, the three SPI pins, and an arbitrary pin (PD2) for slave select.</p>
<p>The circuit on the protoshield is trivial - a pull-up for /CS and a socket for the ROM - and you can see my handiwork in the image at the top of the post.</p>
<p>I won’t go into detail on the code work involved. I wrote a simple <a href="https://github.com/codebje/romble/blob/master/Src/flashrom.c">interface</a> for the Flash ROM, and implemented a <a href="https://github.com/codebje/romble/blob/master/Src/ymodem.c">YModem</a> receiver so I could upload over the ST-LINK’s USB serial port.</p>
<p>I burned on a simple image that just sets one LED to be always off, and binds the other to the 100MHz oscillator’s input via a 26-bit counter. This is around a 1.5Hz blink - if it works.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">module</span> poc(CLK1, LED1, LED2);</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="dt">input</span> CLK1;</span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span class="dt">output</span>              LED1, LED2;</span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a>    <span class="kw">assign</span> LED1 = <span class="dv">0</span>;</span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a>    <span class="dt">reg</span> [<span class="dv">25</span>:<span class="dv">0</span>]          counter;</span>
<span id="cb1-9"><a href="#cb1-9"></a>    <span class="dt">reg</span>                 toggle;</span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a>    <span class="kw">always</span> @(<span class="kw">posedge</span> CLK1)</span>
<span id="cb1-12"><a href="#cb1-12"></a>        counter &lt;= counter + <span class="bn">1&#39;b1</span>;</span>
<span id="cb1-13"><a href="#cb1-13"></a></span>
<span id="cb1-14"><a href="#cb1-14"></a>    <span class="kw">assign</span> LED2 = counter[<span class="dv">25</span>];</span>
<span id="cb1-15"><a href="#cb1-15"></a></span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="kw">endmodule</span></span></code></pre></div>
<p>While I was at it, I figured I may as well make two images like this, one with <code>assign LED1 = 0;</code> and the other with <code>assign LED1 = 1;</code>. <a href="http://www.clifford.at/icestorm/">Project IceStorm</a> supports multi-image bitstreams, so I can exercise my boot selector jumpers as well.</p>
<p>After straightening the ROM’s pins back out (use a removal tool: flat tweezers are excellent, fingers are not) and plugging it into the main board, well:</p>
<video controls="true" autoplay="true" loop="true" style="width: 100%">
<source type="video/mp4" src="/images/trs20/blinky-led.mp4">
</video>
<p>I stared at a blinking light for a somewhat absurd amount of time. The FPGA works. The oscillator works. The ROM works. The power works. Job more or less done!</p>
<h1 id="the-parallel-rom">The parallel ROM</h1>
<p>I thought about how I might want to do this. A neat job would be female headers on a board for the Nucleo to plug into, programming the ROM IC in a PLCC socket beside it. I could add a DIP8 socket and have a programmer for both ROMs in short order. But this is a lot of jumper wires to mess about with, and frankly I’m not really keen on it. So - pretty much every jumper lead I have is now in Frankenprogrammer.</p>
<figure>
<img src="/images/trs20/plcc-programmer.jpg" alt="" /><figcaption>So much better than a TL866II, right?</figcaption>
</figure>
<p>I hope to minimise my programming cycles - I need to work out how I can verify the whole CPU board is good, then work on producing enough of a ROM that I can boot up to something that’ll program other parts of the ROM over USB. PLCC sockets are only good for a few tens of insertions, so I want to be bootstrapped on-board ASAP.</p>
<p>Next up: completing the CPU board assembly.</p>]]></summary>
</entry>
<entry>
    <title>The TRS-20 - Assembling the board</title>
    <link href="https://bje.id.au/blog/posts/trs20/012-build-it.html" />
    <id>https://bje.id.au/blog/posts/trs20/012-build-it.html</id>
    <published>2020-06-26T00:00:00Z</published>
    <updated>2020-06-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I have all my parts, I have my boards, it’s time to assemble this thing. I’ll be starting with the highest risk components first, on the grounds that if I muck up I will have less to replace to try again.</p>
<!--more-->
<h2 id="soldering-round-one">Soldering, round one</h2>
<p>I’ve attempted the iCE40 IC first, as the most likely to fail. And indeed, it hasn’t gone at all well. There were terrible solder bridges on two sides, and while I’ve eventually figured out the technique for dealing with these I’ve applied substantial heat to get there. The board looks in good nick, perhaps due to the two large inner copper planes wicking heat away, but there’s a persistent short from 3.3V to GND that, obviously, is a deal-breaker. I’ve tested the other four boards and they’re all short-free so it’s very likely this is a soldering issue. I found and removed another short on two address lines, and think everything else is clear (no test points - a board design issue), but I don’t even know which of the supply/ground pin pairs has the short. I fear it may have somehow happened beneath the IC where I can’t see it, or with excess heat down a ground via delaminating the board enough for solder to worm its way to a connection with the power layer. It may just be solder sitting sneakily behind some pins, but there’s only two supply pins that are adjacent and I’ve inspected the everloving out of them both.</p>
<figure>
<img src="/images/trs20/dodgy-solder.png" alt="" /><figcaption>That big one on the left I’ve nicknamed ‘The Bridge of Sighs’.</figcaption>
</figure>
<p>I’ve ordered three more FPGAs, and I’ll try again, armed perhaps with a greater fear of excessive solder paste, a new multimeter that doesn’t have one lead replaced by an alligator clip holding a screw, and my improved techniques for fixing small bridges. They won’t arrive until the end of the week, so I’ve put board assembly aside for now.</p>
<h2 id="programming-roms">Programming ROMs</h2>
<p>I have two ROMs to program: the bitstream to configure the FPGA (assuming I ever get it soldered on safely) and the boot/BIOS ROM. The bitstream ROM is programmed over SPI, and is a DIP-8 in a socket. I’m fairly confident I can solder up something to program bitstreams using my STM32F401 black pill board. The boot/BIOS ROM is a bit more difficult, as it’s a parallel device with 18 address pins, 8 data pins, and a little assortment of control pins. I’ll need shift registers to handle this. Luckily I have a little pile of 74HC595s lying around unused. Two of those gives me 16 of my 18 address pins at the cost of two µC pins, and two more for A<sub>16</sub> and A<sub>17</sub>. I can wire up the µC directly to the data pins, and to /OE and /WR, and I’ve only used 14 pins.</p>
<p>I will load up a perfboard with sockets, and then have to figure out how to have the STM32 read a programming bytestream over USB serial. But this can wait while I perform main board assembly - I don’t need more parts, just more time.</p>
<p>I’m also slowly working on a TRS-20 emulator, so I can crack on with writing a boot ROM that’s got a halfway decent chance of actually running on the real deal.</p>
<h2 id="soldering-round-two">Soldering, round two</h2>
<p>My replacement FPGAs arrived earlier than expected. I got in plenty of practice on the first board for dealing with 0.5mm pitch pins using an iron and absurd amounts of flux, so I thought I’d try drag soldering one. Now I have two badly soldered FPGAs on two boards. I don’t really think it’s worth trying to fix the second IC it’s that bad, and the first has been subject to so much heating and cooling and <em>still</em> has a sneakily hidden bridge somewhere between 3V3 and GND.</p>
<p>I tried a third FPGA on a fresh board. I have one spare FPGA and two spare boards. This time, I carefully lined up the IC then used a toothpick to put as little solder paste on as I could, then cracked in with the heat gun. There were a few bridges left, but this time I was able to get in and clean them up without using crazy heating cycles. I’ve checked all 100 pins to confirm they’re connected to what they should be, and not to what they shouldn’t be, and it’s all looking good.</p>
<p>So I got stuck into getting a few more components on the board. I have <em>absolutely no idea</em> if my 100MHz oscillator is on right. It’s a tiny QFN - the only no-lead part on the board - and I can see that at least two pads are soldered, the others <em>probably</em> are, and maybe it doesn’t have bridges, or heat damage from the hot air gun. I can’t really test it, and I didn’t have any particular use for it.</p>
<figure>
<img src="/images/trs20/power-components.png" alt="" /><figcaption>100 0.5mm pitch pins soldered neatly - and a handful of capacitors on crazy angles.</figcaption>
</figure>
<p>The 1.2V regulator is a DDPAK, an absolutely enormous beast of a part. It features a large tab for heat transfer, and again I can’t see underneath it to know if solder paste melted or not. The DDPAK is designed to dissipate heat, so it fights every step of the way when soldering. Even the three pins wick heat magically away into the large copper pours and are difficult to solder. It’s on - but the tab might not be soldered down as well as it should be.</p>
<p>I am filled with regrets about choosing to use 0603 bypass capacitors, they’re fiddly. I’ve put on a half dozen or so, plus a few larger capacitors around the power management. My goal is to get enough soldered on to verify the power circuitry, and then to verify the FPGA is on safely, so I’ve done the DDPAK, the eFuse, and capacitors. I’ve yet to do the resistors, diode, and the R-78 3.3V regulator, more caps, and perhaps the MIC803.</p>
<p>That’s all for another day.</p>
<h2 id="soldering-round-three">Soldering, round three</h2>
<p>It is another day. I’ve pressed on, popping on a stack of resistors for the LEDs, eventual I2C bus pull-ups, CDONE pull-up, and power management resistors. I’ve finished off all the capacitors for the regulators, the FPGA, and its ROM. I’ve added the ROM’s socket, and an unprogrammed ROM is sitting in it, tempting fate. I’ve also added the power USB port, which in hindsight I should have done before the whopping great big capacitor that made access to the USB pins much harder than I’d have liked. All of it went pretty well, I only lost one 0603 resistor (and found it again when cleaning up, amazingly), most of my parts aren’t on <em>too</em> crooked, and there’s no shorts or, as far as I can determine, bad joints.</p>
<p>And finally, I added one LED, the power indicator LED. This is my first SMD LED, and finding the polarity of these parts proved a little harder than I’d expected. The data sheet said the underside would indicate the cathode with a single horizontal line, but the actual underside had a turnstile symbol instead. I wound up relying on the advice in the sheet that the anode is closest to the holes on the tape.</p>
<p>It is time to apply power. If I’ve done anything wrong in design or assembly, magic smoke will now escape.</p>
<h2 id="powering-up-round-one">Powering up, round one</h2>
<p>I pushed the USB cable into the socket, fearing the worst, hoping for the best. Today, I got the best: the power LED lit up. The board has juice! This LED is wired straight to the USB power supply, so it tells me that I don’t have a critical short somewhere, and that I do have a successfully soldered USB port, resistor, and correctly oriented LED. That’s quite a moment, but not the end of the story, not just yet.</p>
<figure>
<img src="/images/trs20/power-on.jpg" alt="" /><figcaption>Just an LED - and an important milestone.</figcaption>
</figure>
<p>I have two regulators and a voltage divider network in my power circuitry. The RECOM should be converting the 5V supply from USB via the eFuse into 3.3V, while the DDPAK linear regulator supplies 1.2V from the same source. I gave them both a probe with the multimeter, and to my delight, both are showing the expected levels. The voltage divider for the MIC2774 reset controller is also performing properly, delivering 315mV to the 300mV comparator input. Nothing is unduly warm, so I feel confident in declaring my power circuitry design and assembly a success.</p>
<p>I have no idea just yet whether the FPGA, ROM, and 100MHz oscillator are in a good place. Tomorrow’s soldering task will be to add the remaining LEDs (including the two USR LEDs wired to the FPGA), the MIC803 supervisor, and the pull-up for the ROM’s Slave Select that I missed - U20 and R13 in the above image. After that I’ll choose between testing the FPGA out before committing RAM, ROM, and CPU, or pressing on with the actual computer part of this circuit.</p>
<p>The ROM programmers are becoming more important with every additional blob of solder hitting the board.</p>
<h2 id="soldering-round-four">Soldering, round four</h2>
<p>This time I’m methodically placing capacitors and resistors, aiming to complete all of each particular size. I’ve knocked out the 0.1µFs, although one is dangerously close to forming a bridge and needs fixing. I’ve put on all the 10kΩ and 2.2kΩ resistors - including deciding that I would use 10kΩ for the /INTx pull-ups instead of 2.2kΩ. I’ve finished all the LEDs off, five are the yellow-green diffuse diodes and three are green low-current clear. The clear LEDs have a dome on top which makes them a little fiddly to hold in place for hand soldering, but didn’t give too much trouble. I also put in the MIC803, which I realised I’d made harder for myself by soldering the SPI Flash socket in place first. There wasn’t much room to get in and heat it up, and it took a few goes to ensure the pin near the socket was adequately wetted.</p>
<p>I put on the 10kΩ resistor R12, which forms part of the voltage divider for VBUS sense on the FT230X USB chip. Since the FT230X isn’t currently programmed for VBUS sense, this means I’ve wired up an output chip with a resistor into GND, and this will draw 0.33mA current when that output is HIGH. I need to be careful not to solder on R11 until I’ve programmed the IC.</p>
<p>Foolishly, I also soldered on the PLCC-32 socket. Progress is barely visible after doing a few tens of 0603 parts, so I wanted some big visible progress in place. However, this is now going to get in the way for soldering the ICs close to the socket: U1 and U30 are SOIC8 ICs with one side of pins each about 7mm away from the socket. They’re handsolder pads, at least, so it should be okay, but I need to take the lesson to heart and not rush in to the big parts until I’ve dealt with the parts needing easier access.</p>
<p>Sadly, on power-up my LEDs didn’t light up as expected. 5V is still lighted, which is good news, but 3V didn’t light up while both USR LEDs wired to the FPGA did, albeit not as bright as the others. Since my understanding of the FPGA is that every IO pin goes Hi-Z during configuration, this seems like terrible news - if power is coming through that IC might be on the fritz. I re-read the iCE40 Programming and Configuration Guide, which does definitely say those pins are Hi-Z with pull-ups. The iCE40 family data sheet says both that I/O pins default to weak pull-down and weak pull-up, depending on which part of the sheet you’re at, but clearly these two pins at least are not wired to GND. There are 2.2kΩ resistors on those LEDs already, so for them to be visibly lit up the weak pull-up resistors can’t be that weak - or the FPGA might still be on the fritz.</p>
<p>The 3V LED was nothing more serious than a bad solder joint on one side, easily fixed.</p>
<p>At this point I’m confident that everything on the board so far has been soldered on correctly (if not necessarily neatly) but I have some doubts about whether the FPGA is still good, or if it’s been fried by clumsy handling or soldering. My next work is therefore going to focus on programming the SPI Flash ROM with a bitstream that can demonstrate the FPGA is good.</p>
<h2 id="errata">Errata</h2>
<ul>
<li>U7 has four floating pins that will become inputs if /BUSACK is active, and four pins that will be outputs wired directly into ground. I can perhaps fix it by also wiring the floating pins to ground - without doing that, using /BUSRQ might result in a short through the ’245 buffer.</li>
<li>There’s no solder mask between the pins of most of my SMD ICs. It’s not a critical failure by itself, but it significantly increases the risk of solder bridges. This may have contributed to my difficulty with the iCE40, and may cause problems for the 0.65mm pitch ICs I have yet to do.</li>
<li>The reset button. I didn’t check pins on this part, and they’re wrong. When the button is soldered on the reset input on the supervisor is always pulled low. I may try to jury rig something down the line, but for now I will just go without.</li>
</ul>
<h2 id="potential-improvements">Potential improvements</h2>
<ul>
<li>Yanking a USB cable in and out for power is not great. I considered a power toggle switch, but chose to omit it - I think putting one in would be a substantial improvement.</li>
<li>The FPGA’s default pin state includes pull-ups; the USR LEDs are on at boot, until configuration is complete. Inverting these LEDs to be wired to +3.3V with an open drain pin configuration would prevent this.</li>
<li>The CBSEL jumpers could have been spaced 2.54mm apart and used a double row pin header, or perhaps DIP switches, though I wanted something with low chance of mechanical failure.</li>
<li>There’s a row of resistors for pull-ups that could have been replaced by two resistor arrays to take a bit less board real-estate up. Fixing U7’s floating and shorted pins will require resistor arrays to fit without major board layout changes.</li>
<li>The 100MHz oscillator in a QFN package is difficult, as I expected it would be. It’s also more important than I counted on, as it’s the only available clock for the FPGA without the processor’s PHI output. Using a bigger package for this oscillator would be a good change.</li>
</ul>
<h2 id="budget-summary">Budget summary</h2>
<p>The budget is blown. I bought three more iCE40HX1Ks to cope with my first failure at soldering, I forgot I needed PLCC-32 sockets, and for the ROM programmer I’ve also had to buy replacements for failed parts. I’ll track my total spend and when I’ve either succeeded or admitted defeat on the CPU board I’ll tally the cost in parts for just the board, but I will no longer pretend I’m going to build a retrocomputer for $400.</p>
<table style="width:65%;">
<caption>Project status update</caption>
<colgroup>
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 10%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">CPU</th>
<th style="text-align: center;">Power</th>
<th style="text-align: center;">Keyboard</th>
<th style="text-align: center;">Video</th>
<th style="text-align: center;">Memory</th>
<th style="text-align: center;">Debug</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">███─</td>
<td style="text-align: center;">done</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">███─</td>
<td style="text-align: center;">done</td>
</tr>
</tbody>
</table>]]></summary>
</entry>
<entry>
    <title>The TRS-20 - CPU board design</title>
    <link href="https://bje.id.au/blog/posts/trs20/011-motherboard.html" />
    <id>https://bje.id.au/blog/posts/trs20/011-motherboard.html</id>
    <published>2020-06-06T00:00:00Z</published>
    <updated>2020-06-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In this post I’ll document my progress on the design of the CPU board. I’m still happy with the PC104 form factor, so into a 10cm² area I’ll see if I can pack on the socketed processor, a clock, the PC104 headers, a power supply, SRAM, and ROM. Snuck in around this needs to be the address decoding logic, glue logic, and a few status LEDs.</p>
<!--more-->
<p>I’ve also switched from Eagle CAD to KiCad for this stage of the project. The main motivation is frugality: I want to design a schematic of moderate complexity, which means multiple schematic files are desirable, but that feature is not part of the free edition of Eagle. As a bonus: the 3D rendering feature of KiCad is pretty fun, and adding parts is easy enough that I’m spending more time hunting for 3D models of parts than worrying about finding footprints or schematics.</p>
<h2 id="the-boards-main-features">The board’s main features</h2>
<p>The motherboard will be responsible for the core of the computer, with everything required for program execution natively on-board. It’s practically a single-board computer, though as seems to be the pattern for Z80-based SBCs there will be at most serial I/O on board, and that only if space permits.</p>
<p>The chief elements to fit on the board, in decreasing order of priority, are:</p>
<ol type="1">
<li><p><a href="#cpu">The CPU</a></p>
<p>Without this, there’s no computer. Because the days of 5V are waning, I’ve decided to settle on a Z8L180-20 part at 3.3V. Whether I use a socketed part or risk a QFP-80 is still to be determined.</p></li>
<li><p><a href="#clock">The clock system</a></p>
<p>This needs to be close to the CPU. An 18.432MHz MEMS oscillator will have excellent rise and fall times, take up little room, and provide a USART compatible clock.</p></li>
<li><p><a href="#power">The power and reset supervision circuitry</a></p>
<p>The CPU needs to be held in reset long enough to initialise, and the single-IC solutions for this problem will also debounce my reset switch for me. This can’t reasonably be off-board, the CPU needs it to start.</p></li>
<li><p><a href="#memory">SRAM</a></p>
<p>Like the clock, this also needs to be close to the CPU for zero wait state access. There’s little choice other than a TSOP-II 48 pin part here.</p></li>
<li><p><a href="#power">Power regulation</a></p>
<p>While I could offload power regulation in a pinch I’d prefer to keep it on-board. I’ll feed in a Raspberry Pi 2.5A 5.1v Micro-USB supply and regulate that down to 3.3v and 1.2v on-board.</p></li>
<li><p><a href="#memory">Flash ROM</a></p>
<p>This could move off-board if necessary, but since it’s essential for booting I’d prefer not to. The tricky part for the ROM is how to program it. A boot loader in the ROM allowing it to be programmed via the Z180 has appeal but risks bricking my system, so this part needs to be socketed.</p></li>
<li><p><a href="#pic">Interrupt controller</a></p>
<p>Responding to interrupts requires programmable I/O registers. I’ve looked at a few ways to do this, and in the end I’ve settled on an ICE40HX1K FPGA, which should offer me plenty of flexibility to do other things as I think of them too, <em>if</em> I can get it in-system programmable. Running it as an I2C controller, for example, would be an interesting use of a few pins on the main header.</p></li>
<li><p><a href="#uart">Serial I/O</a></p>
<p>Without some kind of I/O I really won’t have a clue if my system is working. Ensuring I keep room for USART headers lets me communicate with the CPU after some amount of ROM wrangling, and get into a faster iteration on system development than I would otherwise have.</p></li>
</ol>
<p>This is a lot to try and pack onto a 10cm<sup>2</sup> board. I had originally planned to stick to two layers, but that makes routing substantially harder and I’ve caved and spent extra on four layers. I can offload some parts to a second board, with the caveat that signals will need to go across the PC104 headers. There’s no value I can see in aiming for PC104 pin compatibility, but even so my header pin count isn’t infinite.</p>
<h2 id="cpu">The CPU</h2>
<p>I’ve been aiming at the Z80180 family basically since I discovered the chip - the Z80 core plus a handful of useful peripherals. My debug IC is a rather vanilla Z80180-10 from Aliexpress clocked at 1MHz, with my eye set on (of course) the maximum speed of a Z8S180 clocked at 33MHz.</p>
<p>Running through the timing exercise of the last blog post, plus part selections while designing this board, have brought me to two accommodations. The first is that a 3.3V part has better compatibility with other parts I want to use, as mentioned above. The second is that while it’s possible for me to meet the 30ns timing constrants of a 33MHz part, doing so will require much more care and time. I’m nearly half way through the year and don’t even have a CPU board yet, so ensuring my ambitions don’t exceed my capabilities is important.</p>
<p>Also since the last blog post, all suppliers of the Z8L180 have dried up, unless I want to buy 100 of them. Which I do not. However, if I am reading the datasheet correctly, the Z8S180 will happily run at 3.3V as long as it’s not clocked over 20MHz. Back to the S180 it is.</p>
<p>Parts required:</p>
<ul>
<li>Z8S180-33 CPU</li>
<li>PLCC socket</li>
</ul>
<h2 id="clock">Clocking in</h2>
<p>The Z80180 needs to be clocked at a <a href="003-basic-board.html">magic frequency</a> for UART usage, though the S180 adds a baud rate generator that can divide the clock by a 16-bit value. I toyed with the idea of having a software configurable clock, mostly so I could clock up to maximum for general use and clock down to something approaching the TRS-80 Model I’s 1.777MHz for an emulation mode (10.664MHz crystal divided by 6). But the Z180 is not a Z80. It won’t ever execute a Z80 program at the same speed as an original Z80. I’d rather save a lot of board space and hassle and use a fixed clock that gets my Z180 up and running, at the cost of definitely not being able to run original TRS-80 software at the original speed.</p>
<p>Parts required:</p>
<ul>
<li>A MEMS oscillator at 18.432MHz</li>
</ul>
<h2 id="power">Power supply</h2>
<p>Much like clocks, I’ve cycled around a few ideas here. I need a rough estimate of the total power my system will draw, which I’ve guessed at under an amp. I need input power from an AC adapter, and regulated 3.3V and 1.2V supplies on board. And I don’t want it all to take up too much space, else I’ll have to put it on a separate board.</p>
<p>My solution currently (sic!) is to use a Raspberry Pi USB-Micro power supply. These supplies are rated for 2.5A and deliver power into a USB Micro port. There’s no power negotiation involved - on the Pi the data pins are unconnected - so there’s no IC needed. The supply should deliver a fairly well regulated 5.1V that I can down-regulate to 3.3V and 1.2V.</p>
<p>A RECOM R-783.3-1.0 DC/DC converter is pretty much ideal for me. It’s a three-pin potted package containing all the components needed to regulate 4.75V to 18V down to 3.3V, at 1A. All I need to add is a bypass capacitor or two, and to provide ~250mA at 1.2v for the FPGA’s core with a simple LDO like the <a href="http://ww1.microchip.com/downloads/en/DeviceDoc/22070a.pdf">MCP1824S</a>.</p>
<p>Power management comes in the form of a small collection of ICs. The <a href="http://www.ti.com/lit/ds/symlink/tps25921l.pdf?ts=1588770951061">TPS25921</a> eFuse protects the computer from over-current faults. A 150kΩ resistor sets the current limit of the eFuse to 1.6A. An eFuse provides similar protections to a traditional fuse, but with a much faster response rate. The <a href="http://ww1.microchip.com/downloads/en/DeviceDoc/mic2774.pdf">MIC2774</a> reset controller monitors two voltages and maintains a reset signal for 140ms to 280ms after voltages have reached their target levels, while also supporting a manual reset input.</p>
<p>To let me know what’s going on, I’ll want an LED on the 5.1V supply, an LED tied to the /FLT line of the TPS25921, and an LED on the output of the RECOM. The MIC2774 has a very low current tolerance on its /MR line, so I’ll need to find some other way to indicate that the CPU is being released from reset. I’ve chosen a mix of orange and yellow-green LEDs, which all have a 1.9-2.4V forward voltage and a 30mA forward current. These will need resistors for both 5V and 3.3V, at around 20mA.</p>
<p>Parts required:</p>
<ul>
<li>USB micro port, 2A capable</li>
<li>RECOM R-783.3-1.0 DC/DC converter</li>
<li>1x 22uF MLCC capacitor, 1210</li>
<li>1x 10uF MLCC capacitor, 1206</li>
<li>2x 1uF MLCC capacitor, 0805</li>
<li>TPS25921L, 8SOIC</li>
<li>150kΩ resistor, 0603</li>
<li>MIC2774, SOT23-5</li>
<li>270kΩ, 732kΩ resistors, 0603</li>
<li>Orange and yellow-green LEDs</li>
<li>68Ω and 150Ω resistors, 0603</li>
</ul>
<p>And in general for power management:</p>
<ul>
<li>Lots of 0.1uF MLCC capacitors, 0603</li>
<li>Lots of 10kΩ resistors, 0603</li>
</ul>
<figure>
<img src="/images/trs20/power%20supply.svg" alt="" /><figcaption>A higher part count than I would have liked in the end, but still relatively simple.</figcaption>
</figure>
<h2 id="memory">RAM and ROM</h2>
<p>The <a href="010-timing-check.html">last post</a> went into detail on the specific timings required for zero wait state memory access. In particular, zero wait state ROM requires clever tricks with enabling the IC before I am even sure that a memory request is coming. In the end I’ve chosen not to be too clever, and instead require at least one wait state for memory accesses when the ROM (or off-board memory-mapped I/O) is in use.</p>
<h3 id="utilising-the-z180-mmu">Utilising the Z180 MMU</h3>
<p>One of the selling points for the Z180 is the onboard peripherals, pegged as space and cost savers. The peripheral of the most interest to me right now is the memory management unit. This maps the 20-bit physical address space of the Z180 to a 16-bit logical space, neatly sidestepping a number of problems I’d otherwise face.</p>
<p>The Z180’s MMU divides logical memory into three regions. At the bottom and top of memory are what the processor designers call the Common Areas, and between them is the Bank Area. Common Area 0 at logical address <code class="sourceCode z80asm"><span class="bn">$0000</span></code> is always mapped to physical address <code class="sourceCode z80asm"><span class="bn">$00000</span></code>, and at boot is 64K in size. The Bank Area starts at the end of Common Area 0, and Common Area 1 starts at the end of the Bank Area. All addresses are aligned to 4K, such that logical addresses are 4-bits long and physical addresses are 8-bits long.</p>
<p><img src="/images/z180-mmu.svg" /></p>
<p>At reset, the Z180 will set the program counter to <code class="sourceCode z80asm"><span class="bn">$0000</span></code> and will fetch an opcode from phyiscal address <code class="sourceCode z80asm"><span class="bn">$00000</span></code>. Putting the ROM at this physical address makes booting simple, but after boot it makes Common Area 0 less valuable, as it must always be the boot ROM. CP/M in particular expects useful memory at least as low as <code class="sourceCode z80asm"><span class="bn">$0200</span></code>.</p>
<p>More annoying is that dividing a 1Mb physical memory space into one 512Kb and two 256Kb regions is really easy with an <a href="http://www.ti.com/lit/gpn/sn74lvc1g29">SN74LVC1G29</a> - but its truth table only aligns with selecting SRAM when A<sub>19</sub> is low, and using A<sub>18</sub> to choose between the off-board bus or the ROM when A<sub>19</sub> is high. With a 5.1ns propagation delay this IC is plenty fast enough for the job.</p>
<table>
<caption>How RAM, ROM, and the BUS relate to the CPU’s signals</caption>
<thead>
<tr class="header">
<th>A<sub>19</sub></th>
<th>A<sub>18</sub></th>
<th>RAM</th>
<th>BUS</th>
<th>ROM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>L</td>
<td>-</td>
<td>L</td>
<td>H</td>
<td>H</td>
</tr>
<tr class="even">
<td>H</td>
<td>L</td>
<td>H</td>
<td>L</td>
<td>H</td>
</tr>
<tr class="odd">
<td>H</td>
<td>H</td>
<td>H</td>
<td>H</td>
<td>L</td>
</tr>
</tbody>
</table>
<p>But for this to work, I need to have SRAM at phyiscal address <code class="sourceCode z80asm"><span class="bn">$00000</span></code>. Except right at boot.</p>
<h3 id="booting-from-rom">Booting from ROM</h3>
<p>The /RESET signal on the CPU will be pulled low by the MIC2774 voltage supervisor for 140ms or so after power is first applied or the reset button is mashed. When this signal goes high the processor will enter its reset cycle and very shortly thereafter it will start the first opcode read cycle for address <code class="sourceCode z80asm"><span class="bn">$00000</span></code>.</p>
<p>To instead read that first opcode from ROM at <code class="sourceCode z80asm"><span class="bn">$80000</span></code> I need A<sub>19</sub> to be high after reset. I can OR together the output of a D flip-flip and A<sub>19</sub>, and latch the flip-flop high on the rising edge of /RESET. I also need to clear the flip-flop during the boot sequence. Feeding the inverted A<sub>19</sub> line into the /CLR line of the flip-flop will clear it when A<sub>19</sub> rises, which I can arrange to happen by programming the MMU and jumping.</p>
<object class="paper" data="/images/shadow-rom.svg" type="image/svg+xml">
</object>
<p>In this circuit, U4 is an SN74LVC1G29 2-of-3 decoder. Its A1 input selects its Y0 output when A1 is low. When A1 is high, it selects either Y1 or Y2 depending on whether A0 is low or high, respectively. Feeding into U4 is A<sub>19a</sub>, which is the output of U3, an OR gate. The idea is that a high BOOTUP signal means A<sub>19a</sub> is set no matter what the real A<sub>19</sub> does, and BOOTUP is active at boot.</p>
<p>To achieve this goal, BOOTUP is the Q output of a D flip flop (U1, SN74LVC1G74) whose D line is tied to V<sub>CC</sub>. With its clock signal coming from /RESET, the flip-flop latches Q high when /RESET has a rising edge, or when the CPU is coming out of reset. This in turn makes A<sub>19a</sub> high after reset, causing the CPU to address ROM instead of RAM.</p>
<p>To disable BOOTUP, any CPU access that has A<sub>19</sub> set will do. This feeds into the inverter U2 (SN74LVC1G04), which drives /CLR low on U1, resetting BOOTUP. In this way, all the ROM code needs to do is use the MMU to map ROM into the logical space, then jump to it, and RAM access will be enabled.</p>
<p>While /RESET is active, the address lines from the processor are high-Z. However, the Z8S180 has auto-latches on all its I/O pins, so A<sub>19</sub> will be pulled either low or high - due to its design, it will most likely be pulled high. A pull-down resistor will keep it low when it’s not being driven, and prevent my flip-flop from being reset incorrectly.Zilog’s AN0009 discusses choice of resistor strength, but the text has several errors that muddy the choice a little.</p>
<p>Alternatively, I can combine the signal from A<sub>19</sub> with the signal from /M1. /M1 is held high during reset, and will only go low for a small number of CPU modes, only one of which will occur during boot-up: fetching opcodes. Instead of using an inverter at U2 I can use another IC that will output low iff /M1 is low and A<sub>19</sub> is high. The logic function is a two-input OR (or NAND) gate with one inverted input, <code>/M1 | ~A19</code>. The SN74LVC1G57 and ’97 both support this configuration in a SOT-23-6 package.</p>
<p>I will also swap out the 1G74 for a 1G175 which has no /Q and no /PRE, also in a SOT23-6 package. Dropping the unnecessary pins saves some board space.</p>
<h3 id="programming-the-rom">Programming the ROM</h3>
<p>Until reaching this section, the /WE input of my ROM was hard-wired to Vcc, and I planned to laboriously remove the thing from its socket, put it in a programming socket, burn a new image on, and move it back. Well, no more! I sat down and had a proper read of the datasheet, and I’ve convinced myself that programming it via the CPU is no harder than ensuring I have a wait state or two configured and just writing bytes to the right memory addresses. To write one byte, you need to write <code class="sourceCode z80asm"><span class="bn">$AA</span></code> to <code class="sourceCode z80asm"><span class="bn">$5555</span></code>, then <code class="sourceCode z80asm"><span class="bn">$55</span></code> to <code class="sourceCode z80asm"><span class="bn">$2AAA</span></code>, then <code class="sourceCode z80asm"><span class="bn">$A0</span></code> to <code class="sourceCode z80asm"><span class="bn">$5555</span></code>, and finally, write the byte to program to the address it should be at. Of course, this is Flash memory so you can only write zeros, and must also first erase a sector or the whole chip to one, but this too is accomplished with a sequence of bytes written to magic addresses.</p>
<p>I’ve wired /WE up to the memory write logic, and /WE will now go active when /MREQ and /WR go active. /CE will go active when A<sub>19</sub> (modified by the flip-flop) and /MREQ are active but A<sub>18</sub> is not. If I got it wrong, I only have one trace to cut to disable Flash writes altogether.</p>
<p>Other than needing a series of bytes written on the bus to write one byte to the Flash memory, there’s also of course a much larger time required to write that final byte. This time begins after /WE goes inactive, so the usual CPU write cycle will latch the byte in for writing. Completion of the write can be detected by simple timing, or by reading a byte and examining bit 7, which will be the complement of the true data until the write is finished, or bit 6, which will toggle high and low on successive reads until the write is finished.</p>
<h2 id="pic">Interrupt controller</h2>
<p>There are four interrupt lines on the Z180. The /NMI always restarts the processor at <code class="sourceCode z80asm"><span class="bn">$0066</span></code>. /INT0 has three modes of operation. Mode 0 fetches a single byte instruction from the bus. Mode 1 restarts at fixed address <code class="sourceCode z80asm"><span class="bn">$0033</span></code>. Mode 2 fetches an index into an interrupt vector from the bus, and is the mode I expect to use. /INT1 and /INT2 construct an address similarly to /INT0 Mode 2, but the index is retrieved from a register instead of the data bus. Internal interrupts operate in the same way as /INT1 and /INT2, and all such interrupts have a fixed 5-bit code specific to that interrupt source.</p>
<p>It’s common for Z80 machines to daisy-chain peripherals that raise interrupts. Each peripheral in the chain has an Interrupt Enable Input (IEI) pin. If this pin is asserted low, the peripheral must not signal an interrupt to the CPU. The highest priority peripheral has this pin tied to Vcc. Each peripheral also has an Interrupt Enable Output (IEO) pin that will be connected to the IEI of the next lowest priority peripheral. When the peripheral wishes to raise an interrupt it will assert IEO. If its IEI is not asserted, it will also assert the OR-wired /INT0 line. This will interrupt the processor, which will begin an interrupt acknowledge cycle. Only a peripheral with IEI unasserted will respond by writing its interrupt vector to the bus, then deasserting /INT. It will not deassert IEO until it sees the processor fetch a RETI instruction from the bus while the peripheral’s IEI line is deasserted.</p>
<p>A higher priority peripheral can interrupt another peripheral’s interrupt service routine. A lower priority peripheral must wait until all higher priority interrupts have been serviced before raising its own. And each peripheral must watch the bus for opcode fetch cycles, to detect RETI.</p>
<p>The scheme is quite neat, allowing a priority interrupt scheme without a dedicated controller. However, it’s not at all suited to a PC/104-style stack of boards, where every pin passes directly through each layer to the next. It’s not possible to have a daisy chained signal with stacked headers.</p>
<p>Since I’m not using any of the Z80 peripheral ICs, this isn’t a big problem. I can instead use an Intel 8259 style interrupt controller: one CPU interrupt line is split into a number of peripheral interrupt lines, each claimed by a single peripheral. This requires hard wiring peripherals to the appropriate interrupt on each child board, but doesn’t need any specific wiring for interrupt acknowledgement. Typically a peripheral will keep its interrupt flag active until acknowledged directly via I/O operations, or will keep it active for a short period.</p>
<p>The FPGA is also able to run an I2C core, and maybe down the track other tricks, so I’ve used five pins for interrupts and two for SDA/SCL lines. The I2C lines need pull-ups, and I’ve chosen 2.2kΩ. This is 1.5mA of current drain to pull low, but most of the time those lines will be idle.</p>
<p>The 8259A interface watches for rising edges or high signal levels on its interrupt lines, but I would prefer to configure the inputs in the FPGA as hi-Z unless explicitly configured as enabled rather than adding pull-downs or jumpers.</p>
<p>The FPGA itself requires an SPI slave device to feed it configuration data. I’ve chosen a DIP-8 package ROM in a socket so I can remove and reprogram it reasonably easily. The IC is a Winbond 32Mbit ROM, which has room for around 129 bitstream images for an iCE40HX1K device at 32,303 bytes per bitstream. The iCE40 has the option of selecting one of four image locations on boot based on the state of two pins at reset, or under software control using two internal signals. This allows me to store a bitstream in a different region of the Flash memory and load that image into the FPGA to test it before committing it to be the main boot-up bitstream. Adding a few jumpers to control the cold boot pins lets me have an emergency recovery bitstream I never touch.</p>
<figure>
<img src="/images/trs20/pcb_fpga.png" alt="" /><figcaption>The PCB’s layout is dominated by capacitors that are large enough for me to solder.</figcaption>
</figure>
<p>The FPGA is a 0.5mm pitch VQFP-100 IC. This might be the most difficult part to solder on this board. I have done a practice solder of a TQFP-100, which sadly had several bridged pins. I corrected those bridges after buying the flux I should have used in the first place, but I’ve no idea if I cooked the IC with my hamfisted soldering and repair attempts. I’m a little nervous about this. Also in this section of the board is the only no-lead package I’ve used. X1 is a 100MHz MEMS oscillator that has no specific reason to exist, other than someday maybe I’d like a 100MHz clock input on the FPGA. Because it doesn’t need to be there, mucking X1 up won’t be such a big deal.</p>
<p>The FPGA is connected to all address and data lines, after buffering. It receives the CPU control signals: /MREQ, /IORQ, /RD, /WR, and /M1. It is the only part of the system wired up to the DMA control signals and the bus master control signals, and controls the three maskable external interrupt lines. It’s also wired to USART1’s RX and TX pins, and since taking the above image I also wired up CTS1. Again, I have no specific plans here, but it costs nothing except the time to try for a neat trace to leave the option of using USART1 with the FPGA open.</p>
<p>The control input lines for the CPU are all pulled high with 10kΩ resistors. Each pin on the iCE40HX1K has a drive current of 8mA maximum (“sysIO Single-Ended DC Electrical Characteristics”, iCE40 LP/HX Family Data Sheet) for an R<sub>min</sub> of 412.5Ω. R<sub>max</sub> is determined by timing constraints. For interrupts it’s not too critical. Sooner is better, but using 2.2kΩ at the ~15pF capacitance on the CPU and traces is around 30ns, and I will live with that. The /DREQn signals indicate to the CPU that an I/O device is ready for a DMA read or write to proceed, and it shouldn’t matter terribly if it’s delayed 30ns either.</p>
<p>/WAIT is a bit trickier. The Z8018x User Manual recommends synchronising changes to the signal with the rising edge of the system clock to meet timing requirements. This suggests a D flip-flop clocked from PHI sitting between open-drain drivers of /WAIT and the input pin on the CPU, with a pull-up to keep it high in the absence of a /WAIT claim. The ’175 D flip-flop I’m using elsewhere will do fine for this job: it has an input capacitance of around 3pF, so at 2.2kΩ this is close to a 10ns delay. With around 62ns to react and insert an additional wait state (assuming the CPU supplies at least one) this is a reasonable delay.</p>
<p>The two jumpers to configure <code>CBSEL0</code> and <code>CBSEL1</code> are below the ROM socket. U20 is a MIC803 supervisor, wired to <code>CRESET_B</code> on the FPGA. This pin pulls low to hard reset the FPGA, and the MIC803 holds it low for 20-44ms after the 3.3V rail has powered up. This is because the SPI ROM requirements include it being ready to accept commands 10µs after meeting power-on conditions, but the Winbond ROM takes a minimum of 20µs. The FPGA will be configured and ready to communicate long before the CPU has been released from reset with its minimum 140ms reset hold time - at the slowest configuration frequency, the typical configuration time is 53ms. This falls to 13ms with the fastest configuration frequency.</p>
<p>During this review, I found two errors in the PCB layout above. The first was the lack of a pull-up resistor on <code>CRESET_B</code>. Without this, the FPGA would have reset itself randomly as the MIC803 is an open-drain supervisor. The second is that I had a pull-up resistor on the SPI clock line, which the iCE40 does not want or recommend, and which the Winbond also doesn’t specify. I’ve added one and removed the other. I also noticed I haven’t connected <code>CDONE</code> to a status LED, which would at this point require rerouting large parts of the board to accommodate. It’s properly pulled up to Vcc as per the iCE40 programming manual, at least.</p>
<h2 id="uart">Serial I/O</h2>
<p>The Z180 has two USARTs, one with a full suite of control signals and one with just /CTS. I have wired USART1 up to the FPGA, which leaves USART0 as the obvious choice for my first interface into my computer. The easiest way to handle it is to expose a pin header with the various signals and use a USB to serial dongle to hook it up to a terminal program. Neater, though, is to put the USB port directly on the board and use one of many USB to UART ICs directly. I’ve chosen the FTDI FT230X, which can be powered at 3.3V without needing an external clock, can drive RX/TX LEDs, and has CTS/RTS signalling.</p>
<p><img src="/images/trs20/schm-usb-serial.svg" /></p>
<p>I’ve chosen to run the FT230X in a self powered configuration, using my on-board power to supply the IC. In this configuration there’s a few items to check off:</p>
<ol type="1">
<li>It’s not nice to push current down the D wires to an inactive hub or host. To resolve this the FT230X expects to have a VBUS sense input on one of its four configurable I/O pins, which is just a voltage divider on VBUS from the USB port. When this input reads zero the FT230X isolates the D wires. When it’s high the FT230X pulls D+ up to 3.3V, which identifies the FT230X as a full speed device.</li>
<li>There is an internal LDO regulator that provdes 3.3V to various internal components. It also provides power output on the 3V3OUT pin which can be wired to VCCIO to supply power for the I/O pins. When VCC is less than 4.3V this voltage will fall out of regulation, and the FT230X datasheet says that when VCC is at 3.3V, 3V3OUT becomes an input pin and should be connected to VCC. Without this those internal components won’t get the 3.3V they need.</li>
<li>Some revisions of this IC had a fault in which they would mistakenly believe the host or hub had powered down, and USB communications would stop. This was fixed in revision D of the chip, which I believe was released in 2012 or so. The work-around for revisions A, B, and C is to pull a Keep Awake input low on another configurable I/O pin.</li>
</ol>
<p>These things aren’t as straightforward to resolve as I would like. For each item to check off, there’s a corresponding wrinkle to deal with.</p>
<ol type="1">
<li>All four CBUSx pins are programmed as outputs in the factory. They can be reprogrammed easily over USB, but trying to connect over USB when CBUS0 is configured as an output and wired up to get ~3.4V from VBUS is a recipe for smoke. To sort this out, I need to avoid soldering R11 and R12 until I have reprogrammed the IC.</li>
<li>KiCad has a feature that treats having more than one power output on a net as an error. This is generally a good idea as it’ll pick up if you’ve accidentally wired two voltage sources together. However 3V3OUT is marked as a power output in the FT230X package, but it must be wired up to the 3.3V output of my regulator. KiCad complains about this. I could copy the FT230X package and modify the pin to be an input, but instead I am just going to live with KiCad telling me I have an error.</li>
<li>I expect I will get a revision D chip when ordering from a reputable supplier like DigiKey, but I can’t easily fix the problem once I’ve soldered the chip in place. I’ve added a resistor on the back of the board to pull CBUS3 to ground, which I can jumper or put a low value resistor on in the unlikely circumstance that my IC has this fault - after programming CBUS3 to the right function, that is.</li>
</ol>
<h2 id="reviewing-everything">Reviewing everything</h2>
<p>The <a href="/images/trs20/cpu%20board.pdf">full schematic</a> shows how long this has taken me - I started work on this in February. It’s not quite complete yet, either - I want to review the datasheets of each IC and ensure the pin assignments are right, because it’s dang hard to fix that sort of problem once you’ve fabbed a board.</p>
<p>So here we go, one IC at a time, checking everything. Let’s see how many errors I pick up, and sweat over how many I don’t pick up.</p>
<ol type="1">
<li>I have 1210, 1206, and 0805 capacitors in my DigiKey BOM for the 22uF, 10uF, and 1uF parts, respectively. On the board I’d assigned 0805 footprints to them all. I fixed that up, and popped a second 22uF on near the USB power input. The eFuse IC also suggests a Schottky diode on the output to protect against negative transients, which I am still considering.</li>
<li>I wired D+ to USBDM and D- to USBDP on the FT230X. You can see the mistake in the schematic above. I think it’s because they just lined up neatly that way. I needed to rotate the FT230X on the board to resolve it.</li>
<li>My 74LVC2G32 gates had the wrong pin assignments in the schematic. Rather than use the two-unit IC schematic supplied with KiCad I drew up my own one-unit schematic, and got it wrong. There’s three on the board, but they just needed re-routing.</li>
<li>My MCP1824S linear regulator was wired directly to the USB power, not to the eFuse output. On top of that, I’m not really happy with a 300mA limit for the FPGA’s core. I have no idea how much power it will actually draw, I can’t find that information, but other board designs I’ve looked at give it more juice. So - it’s now an MCP1826S rated for 1A, in a 3DDPAK footprint that can dissipate twice as much heat. If I can solder it down. DDPAKs are huge, so I had to move a few things around to fit it in. And I threw in that diode. I should be able to feed up to 700mA to the FPGA without any stress on the parts now.</li>
<li>A big one. I force A<sub>19</sub> high at boot to select ROM - but A<sub>18</sub> will be low, which would have selected unassigned bus memory addresses. I correctly identified the ROM would be at <code class="sourceCode z80asm"><span class="bn">$80000</span></code>, and clearly got that right in the circuit that forces A<sub>19</sub> high, but got it wrong in my logic table and wiring.</li>
<li>Another big one, courtesy BFLmouse from the 8 Bit World Discourse server: U16 is a ’245 buffer for the data bus, with DIRection controlled by /WR. If the CPU releases the bus via /BUSREQ, then this buffer must stay off the data bus. It needs the inverse of /BUSACK wired into /OE to disable the outputs. This could also be applied to the /OE pins of the address ’245s, but their DIR pin is wired to /BUSACK already - when /BUSACK is low, the Z180’s address lines are high-Z, and those ’245s will replicate whatever’s on the address bus outside to be ignored by the CPU on the inside.</li>
<li>KiCad’s SOT-23 footprints are smaller than the parts I’ve checked expect. I’ve switched to the hand soldering footprints in most cases, which gives me more room to get in with an iron and ensures I have enough overhang to successfully solder these parts down even if I’m not perfectly lined up. The same appears to be true of the diode footprints.</li>
<li>The lack of connection of the <code>CDONE</code> signal bothered me enough that I did the work to add an LED in. This meant moving a few components around to make room for an extra LED in the status LED section of the board. It also meant figuring out why the iCEstick appears to have an LED wired up to a 4.7kΩ resistor from 3.3V - at 1.8V<sub>F</sub> that’s only 0.32mA of forward current, though it’s also only 0.7mA of current into the <code>CDONE</code> pin when it’s being pulled low. I think the board must be using very low current LEDs, so I added a few of those to my BOM and I’ll drive them with 2.2kΩ resistors.</li>
<li>This isn’t really a board error, but I also added two user LEDs to the FPGA. This will let me do the usual “blinky” FPGA test code and confirm it’s working reasonably correctly early on, and let me use those LEDs as “printf debug” signals when programming the FPGA to interact with the CPU. And when it’s all working satisfactorily, I’ll have two system-controlled status lights.</li>
<li>The footprint for the MCP1826S didn’t match the datasheet in pretty much any dimension. I suspect it would have been okay, but I replaced it with a footprint that does match the datasheet. I also boosted the input capacitor to 4.7µF, which the datasheet seems to like sprinkling around a lot. The power input comes off a fairly long cable, so that extra buffering is likely to be used.</li>
<li>All CPU output signals were buffered before reaching the 40-pin header except for PHI. That now runs through a clock fanout buffer IC (the Microchip Technology PL133-37) with three outputs - one is used for the /WAIT flip-flop, one feeds both the FPGA and the header, and one is unused.</li>
</ol>
<p>I’ve checked all components wired to the address and data buses. I’ve checked every datasheet for pins, footprints, capacitor and resistor selection guidelines. I’ve reviewed whether component labels are obscured by other components or vias. And I’ve, most importantly, added decor to the board with the excellent <a href="https://www.1001fonts.com/park-tech-cg-font.html">Park Tech CG Font Family</a> and an adaptation of a logo Zilog was using in the ’80s and ’90s. The second revision schematic is <a href="/images/trs20/cpu%20board%20rev%202.pdf">here</a>.</p>
<p>This is a risky project for me. I’ve never designed such a complex circuit before, nor have I soldered so many tiny SMD parts. Most of the elements of this design are new to me: FPGAs, USB ICs, and management of the timing constraints the 18.432Mhz clock demands. This blog post serves as my major design review, and picked up a handful of issues that would have been painful to hit after fabrication.</p>
<p>I’ve pulled the trigger on ordering parts (they left Honolulu early this morning) and the board (four layers with ENIG finish, in fabrication) for close to $190 all up, so my budget is now blown. I’ve got to somehow successfully solder all the parts to the board, write code for the FPGA, write a ROM, and hopefully not discover any mistakes that I can’t monkey patch, and if all that goes to plan I’ll have a working computer I can interact with over a USB serial link. Adding keyboard and video I/O will have to wait.</p>
<p><img src="/images/trs20/logo.svg" /></p>
<table style="width:86%;">
<caption>Project status update</caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 10%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Budget</th>
<th style="text-align: center;">CPU</th>
<th style="text-align: center;">Power</th>
<th style="text-align: center;">Keyboard</th>
<th style="text-align: center;">Video</th>
<th style="text-align: center;">Memory</th>
<th style="text-align: center;">Debug</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">$425.76 of $400</td>
<td style="text-align: center;">███─</td>
<td style="text-align: center;">███─</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">███─</td>
<td style="text-align: center;">done</td>
</tr>
</tbody>
</table>]]></summary>
</entry>
<entry>
    <title>The TRS-20 - Timing check</title>
    <link href="https://bje.id.au/blog/posts/trs20/010-timing-check.html" />
    <id>https://bje.id.au/blog/posts/trs20/010-timing-check.html</id>
    <published>2020-05-03T00:00:00Z</published>
    <updated>2020-05-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I am working on the CPU board design, which covers too many topics and decisions to fit into just one post. This particular post explores timing in depth, checking that I understand how fast my logic circuits must be to keep the bus contention free and the CPU state valid.</p>
<!--more-->
<h2 id="but-first-a-digression">But first, a digression…</h2>
<p>When, say, an adder circuit in a CPU is presented with some values on its input wires, some brief amount of time will elapse before the correct value presents on its output wires. In the meantime, it’s even possible that the output value will pass through intermediate states before settling on the right answer. The clock in a processor is the solution to this: it doesn’t matter what the circuit does while computing its answer, so long as it’s got the right answer by the time the next clock transition happens. The clock signal synchronises all the circuits of the processor, shuffling data from circuit to circuit with metronomic regularity.</p>
<p>When you pop out of the CPU and look at its immediate peripherals, the clock signal comes along for the ride. External components must march to the same drum as the processor, consuming data it outputs before the processor has moved on to the next task, and providing data as input before the processor acts on it.</p>
<p>This manifests in data sheets and other documentation as <em>timing diagrams</em>. These diagrams have time as the horizontal axis, and signal levels as the vertical axis, with multiple signals on the same diagram to show how the signals must synchronise with each other. If there’s a clock synchronising the signals, it’ll usually be the first signal in the diagram. Since the diagram’s purpose is to show relative timing constraints, the time axis isn’t accurate - if two signals change at the same point horizontally, they’re only specified to change at the same time if the diagram indicates a zero time delay between them.</p>
<figure>
<img src="/images/timing-diagram-example.svg" alt="" /><figcaption>Three signals (one a bus), and two indicated timing data.</figcaption>
</figure>
<p>A timing diagram’s value is in explaining how one signal’s change in state is related to another signal. In the above diagram, a table would give an upper or lower bound for the intervals marked <code>1</code> and <code>2</code>. An upper bound for interval <code>1</code> would specify the maximum time that the address lines will settle after the rising edge of T1. A lower bound for interval <code>2</code> would specify the minimum time that the address lines will be settled before /MREQ falls.</p>
<h2 id="processor-timing-details-for-the-z180">Processor timing details for the Z180</h2>
<p>For the Z180 processor, there’s a feast of timing diagrams to dine on. They get their own section of the User Manual, and are one of the few pieces of information that appear in both the User Manual and the specification document. They’re accompanied by large data tables specifying bounds for various durations in the diagram. Time value t<sub>CYC</sub> is the clock cycle time - the time between each rising edge. For the Z8L180-20 t<sub>CYC</sub> lies between 50ns and DC, reflecting that the maximum speed of the processor is 20MHz (<span class="math inline">\(\frac{1}{20e^6} = 50e^{-9}\)</span>), and there is no minimum speed: you can stop its clock entirely.</p>
<p>Some of these timing values tell me useful information for my board design - my clock should be able to satisfy not only the clock cycle time bounds, but also the high and low pulse width bounds, which are only specified as minimum values. The Z80180 expects that the low and high pulses are each at least 40ns long. The upper bound is determined by the actual clock cycle time and the other pulse time minimum - for a 100ns cycle, the maximum high or low pulse is 60ns. There’s also clock rise and fall times: signal levels don’t change instantaneously, and if they transition too slowly a CMOS input can oscillate between reading a high and a low, or if you’re lucky, just chew up relatively huge amounts of power.</p>
<p>Others of these timing values tell me useful information for my component selection, when read in conjunction with a timing diagram. How fast does my SRAM have to be if I want to access it with no wait states? Well - in an opcode fetch cycle, the address pins will stabilise no more than t<sub>AD</sub> (30ns) after the first rising edge of the first clock cycle of the opcode fetch machine cycle, and no less than t<sub>AS</sub> (5ns) before /MREQ or /IORQ falls. In turn, /MREQ promises it will fall no later than t<sub>MED1</sub> (25ns) after the falling edge of that first clock cycle. Similarly, t<sub>RDD1</sub> (25ns) promises that /RD will fall at most that long after the falling edge as well. There’s nothing tying /RD and /MREQ together though, so there’s no commitment made as to which will fall first, or how much time will elapse between the two falling.</p>
<p>It’s all a bit complicated. Perhaps a diagram would help…</p>
<figure>
<img src="/images/z180-timing-main.png" alt="" /><figcaption>z8018x User Manual (UM005004-0918), p.197, Figure 81.</figcaption>
</figure>
<p>There’s a lot going on in this one diagram, but I can use it to produce the information I really need - if I have 12ns SRAM, how fast does my glue logic have to be before I need a wait state? And for my Flash ROM and any on-board I/O devices, similar questions play out.</p>
<h2 id="working-out-maximum-delays">Working out maximum delays</h2>
<p>The figure I included above shows an opcode fetch cycle and I/O read/write cycles, but not a memory read or write cycle. As it turns out memory read cycles look almost the same as opcode fetch cycles with one key difference - the data lines are sampled on the falling edge of T3, not the rising edge. Taking a leaf from Application Note AN009602-0808 (“The Z180 Interfaced with the SCC at 10 MHz”) a simplified diagram showing a read and a write memory cycle will clear up the clutter nicely and show just what’s needed for memory timing constraints.</p>
<table>
<caption>Values for the timing parameters of the Z80L180-20. All times in ns.</caption>
<thead>
<tr class="header">
<th style="text-align: left;">No.</th>
<th style="text-align: left;">Label</th>
<th style="text-align: left;">Time</th>
<th style="text-align: left;">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">6</td>
<td style="text-align: left;">t<sub>AD</sub></td>
<td style="text-align: left;">≤ 30</td>
<td style="text-align: left;">PHI rise to Address Valid Delay</td>
</tr>
<tr class="even">
<td style="text-align: left;">7</td>
<td style="text-align: left;">t<sub>AS</sub></td>
<td style="text-align: left;">≥ 5</td>
<td style="text-align: left;">Address Valid to /MREQ or /IORQ fall</td>
</tr>
<tr class="odd">
<td style="text-align: left;">8</td>
<td style="text-align: left;">t<sub>MED1</sub></td>
<td style="text-align: left;">≤ 25</td>
<td style="text-align: left;">PHI fall to /MREQ fall delay</td>
</tr>
<tr class="even">
<td style="text-align: left;">9</td>
<td style="text-align: left;">t<sub>RDD1</sub></td>
<td style="text-align: left;">≤ 25</td>
<td style="text-align: left;">PHI fall to /RD fall delay</td>
</tr>
<tr class="odd">
<td style="text-align: left;">11</td>
<td style="text-align: left;">t<sub>AH</sub></td>
<td style="text-align: left;">≥ 5</td>
<td style="text-align: left;">Address Hold time from /MREQ, /IORQ, /RD, /WR high</td>
</tr>
<tr class="even">
<td style="text-align: left;">12</td>
<td style="text-align: left;">t<sub>MED2</sub></td>
<td style="text-align: left;">≤ 25</td>
<td style="text-align: left;">PHI fall to /MREQ rise delay</td>
</tr>
<tr class="odd">
<td style="text-align: left;">13</td>
<td style="text-align: left;">t<sub>RDD2</sub></td>
<td style="text-align: left;">≤ 25</td>
<td style="text-align: left;">PHI fall to /RD rise delay</td>
</tr>
<tr class="even">
<td style="text-align: left;">15</td>
<td style="text-align: left;">t<sub>DRS</sub></td>
<td style="text-align: left;">≥ 10</td>
<td style="text-align: left;">Data Read Set-up time</td>
</tr>
<tr class="odd">
<td style="text-align: left;">16</td>
<td style="text-align: left;">t<sub>DRH</sub></td>
<td style="text-align: left;">≥ 0</td>
<td style="text-align: left;">Data Read Hold time</td>
</tr>
<tr class="even">
<td style="text-align: left;">22</td>
<td style="text-align: left;">t<sub>WRD1</sub></td>
<td style="text-align: left;">≤ 25</td>
<td style="text-align: left;">PHI rise to /WR fall delay</td>
</tr>
<tr class="odd">
<td style="text-align: left;">23</td>
<td style="text-align: left;">t<sub>WDD</sub></td>
<td style="text-align: left;">≤ 25</td>
<td style="text-align: left;">PHI fall to Write Data Delay time</td>
</tr>
<tr class="even">
<td style="text-align: left;">24</td>
<td style="text-align: left;">t<sub>WDS</sub></td>
<td style="text-align: left;">≥ 10</td>
<td style="text-align: left;">Write Data Set-up time to /WR fall</td>
</tr>
<tr class="odd">
<td style="text-align: left;">25</td>
<td style="text-align: left;">t<sub>WRD2</sub></td>
<td style="text-align: left;">≤ 25</td>
<td style="text-align: left;">PHI fall to /WR rise delay</td>
</tr>
<tr class="even">
<td style="text-align: left;">27</td>
<td style="text-align: left;">t<sub>WDH</sub></td>
<td style="text-align: left;">≥ 10</td>
<td style="text-align: left;">Write Data Hold time from /WR rise</td>
</tr>
</tbody>
</table>
<figure>
<img src="/images/z180-timing-memory.svg" alt="" /><figcaption>Memory access timing diagram, opcode fetch and write cycles.</figcaption>
</figure>
<p>The only timing not specified in the table above is 1 (t<sub>CYC</sub>, the clock cycle time). I will use an 18.432MHz MEMS oscillator, the DSC1001DE5. This part is accurate to 10ppm, which means t<sub>CYC</sub> will fall between 54.253ns and 54.254ns, which I will call 54ns. It outputs 0.9xV<sub>DD</sub>, or 2.97V, with a rise and fall time no longer than 2ns. The duty cycle could be anywhere between 45% and 55%, or 24.3ns to 29.7ns.</p>
<p>A regular memory read cycle shortes the data window by only requiring that data has been set up t<sub>DRS</sub> before the falling edge of T3, rather than the rising edge. I/O read cycles are the same as regular memory read cycles, except that /IORQ replaces /MREQ and there is always at least one wait state. In Z80-compatible mode though, /IORQ and /RD fall after the rising edge of T2, so that’s a little trap to be wary of.</p>
<p>To read a byte from a typical memory chip, one will decode the address lines plus /MREQ to activate the chip enable input of the memory, then activate either output enable or write enable depending on whether /RD or /WR is active. /MREQ activates 5ns after the address lines have settled, or 25ns after T1 falls. T1 could fall as late as 29.7ns after T1 rises, so /MREQ will not become active until 54.7ns have elapsed. /RD will become active at the same time. This is 1.7ns after T2 has begun, leaving 53.3ns until T3 begins, and 43.3ns until the data must be available.</p>
<figure>
<img src="/images/z180-memory-read-timing.svg" alt="" /><figcaption>Laid out as a timeline, it’s starting to make sense.</figcaption>
</figure>
<p>This 43.3ns is eaten up by address decoding to drive the SRAM’s /CE input, by any logic required to translate the CPU’s /RD and /WR outputs into the SRAM’s /OE and /WE inputs, by any buffering or logic level conversions required, and of course by the SRAM’s own timing constraints. Fortunately, these are easier to understand - in a nutshell, data will be ready at most 10ns after /CE is active and 6ns after /OE is active. The data outputs will be Hi-Z again 5ns after /OE goes high. These figures are specific to the SRAM chip I’m using: check your datasheet.</p>
<p>There’s also parasitics that add delay to the signal. On my sized board, this will be well below 3.3ns - the <a href="https://blog.zuken.com/how-to-calculate-trace-length-from-time-delay-value-for-high-speed-signals/">speed of signals</a> on stripline traces is close to 150mm/ns, so it’ll take less than one nanosecond for a signal to traverse my 10cm^2 board corner to corner. This leaves me a tidy 40ns to work with.</p>
<p>For SRAM, this is an enormous surplus of time, with a whopping 30ns available for logic. For Flash ROM, it’s not so much time. My chosen ROM is the SST39SF020A, a 2Mbit 55ns IC. 55ns is, of course, greater than 40ns. But all is not lost, because as with the SRAM the 55ns applies from the time /CE is active. Data will be available 35ns after /OE is active, so if I can decode the address lines and toggle /CE early enough I will have 5ns to activate /OE on the ROM and still have data available inside the zero wait state window. Data must be ready at t+98ns and the address lines are settled at t+30ns, leaving 10ns for address decoding and 3ns for parasitics.</p>
<p>The Z180 has a 16-bit I/O space so A16-A19 should all be low for any I/O request. Address decoding on ADDR alone can be fairly sure that if the ROM bits are set (A18, A19) that it’s really going to be a ROM request. In a similar vein, if A18 is set and A19 is clear it’s going to be an off-board memory request, and a wait state could be immediately generated, but I’m quite comfortable requiring software to manage this via the CPU’s wait state generator if off-board memory is needed.</p>
<figure>
<img src="/images/z180-memory-write-timing.svg" alt="" /><figcaption>My eyes are starting to glaze.</figcaption>
</figure>
<p>When writing, the SRAM IC has from the fall of /WR to the fall of T3 to store data. /WR should fall no later than t+79ns, and T3 should fall no earlier than t+131.4ns. /WR will rise up to 25ns later. Timing constraint 26 (t<sub>WRP</sub>, write pulse width) guarantees that /WR will be low for at least 80ns. You could almost write the byte down on paper with that much time.</p>
<h2 id="wait-state-generation">Wait state generation</h2>
<p>Wait states are inserted between T2 and T3, either because the Z180’s internal wait state generator has been configure to insert them, or because the /WAIT signal is low when sampled at the fall of T2. The internal wait state generator can add zero to three wait states to every memory or I/O access, with three being added at reset.</p>
<p>The /WAIT signal must be asserted low at least t<sub>WS</sub> (15ns) before T2 falls, and held low at least t<sub>WH</sub> (10ns) after T2 falls. To allow the processor to continue, it must be de-asserted at least t<sub>WS</sub> before a TW clock cycle falls, and held high at least t<sub>WH</sub> after it falls.</p>
<p>T2 could fall as early as t+78.3ns, and /WAIT must be asserted low 15ns before that at t+63.3ns. If /WAIT is asserted in response to /MREQ falling at t+54.7ns then only 8.6ns is available. /WAIT transitions are ideally done on the rising edge of a system clock, but /MREQ might fall after T2 rises - if wait states are required for a memory read, they are likely to need to be generated either based on address alone or done using the internal wait state generator. For IO, there’s already one wait state inserted at a minimum, giving at least 62.6ns.</p>
<h2 id="interrupt-acknowledgement">Interrupt acknowledgement</h2>
<p>The Mode 0 and Mode 2 INT0 acknowledgement cycles both read a data byte from the bus, where only M1 and IORQ go low. In both cases there are two wait states, /M1 falls up to 35ns after T1 rises, /IORQ falls at least 125ns (2.5 clock cycles) after /M1 falls and at most 25ns after TW<sub>1</sub> falls. Data must be ready 10ns before T3 begins to rise. Assuming TW<sub>1</sub> falls late at 29.7ns and /IORQ falls 25ns after that, and a few ns for parasitics, there’ll be 40ns left in which to respond to the acknowledgement cycle with data on the bus.</p>
<p>Memory writes</p>
<ul>
<li>10 t<sub>M1D1</sub> PHI rise to M1 fall ≤ 35ns</li>
<li>28 t<sub>IOD1</sub> PHI rise/fall to IORQ fall ≤ 25ns</li>
<li>29 t<sub>IOD2</sub> PHI fall to IORQ rise ≤ 25ns</li>
<li>30 t<sub>IOD3</sub> M1 fall to IORQ fall ≥ 125ns</li>
</ul>
<h2 id="io-timing">IO timing</h2>
<p>IO read and write cycles differ from memory only by the addition of one mandatory wait cycle. This adds 54ns to all timing constraints. In the case of t<sub>WRP</sub>, the minimum write pulse time is 150ns.</p>
<h2 id="timing-constraint-summary">Timing constraint summary</h2>
<table>
<thead>
<tr class="header">
<th>Constraint</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Mem read</td>
<td style="text-align: left;">ADDR to data available</td>
<td style="text-align: left;">65ns</td>
</tr>
<tr class="even">
<td>Mem read</td>
<td style="text-align: left;">/MREQ, /RD fall to data available</td>
<td style="text-align: left;">40ns</td>
</tr>
<tr class="odd">
<td>Mem write</td>
<td style="text-align: left;">/WR fall duration</td>
<td style="text-align: left;">80ns</td>
</tr>
<tr class="even">
<td>Mem wait</td>
<td style="text-align: left;">/MREQ fall to clock rise</td>
<td style="text-align: left;">-0.7ns</td>
</tr>
<tr class="odd">
<td>IO read</td>
<td style="text-align: left;">/IORQ, /RD fall to data available</td>
<td style="text-align: left;">94ns</td>
</tr>
<tr class="even">
<td>IO write</td>
<td style="text-align: left;">/WR fall duration</td>
<td style="text-align: left;">150ns</td>
</tr>
<tr class="odd">
<td>IO wait</td>
<td style="text-align: left;">/IORQ fall to clock rise</td>
<td style="text-align: left;">50ns</td>
</tr>
<tr class="even">
<td>INT0 read</td>
<td style="text-align: left;">/M1 and /IORQ fall to data available</td>
<td style="text-align: left;">40ns</td>
</tr>
</tbody>
</table>]]></summary>
</entry>
<entry>
    <title>The TRS-20 - boot up</title>
    <link href="https://bje.id.au/blog/posts/trs20/009-boot-it.html" />
    <id>https://bje.id.au/blog/posts/trs20/009-boot-it.html</id>
    <published>2020-02-19T00:00:00Z</published>
    <updated>2020-02-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>My 128 bytes each of ROM and RAM are working: the Z180 is executing my code.</p>
<!--more-->
<p>With my test rig re-wired using 22AWG wire (from a kit, I don’t have a nice stock of the stuff to trim to length myself yet) and looking neat, despite still only having eight address lines, I fired the thing up. Not pictured is a small extension that ties RESET high with a 10k resistor and adds a tactile switch to pull it low, as the Z180 doesn’t really behave properly without being reset.</p>
<p>The <a href="https://github.com/codebje/trs20-debug/blob/fe11a903a1df9553ae3c87e779e340607668d3f4/trs20.asm">code</a> that should be executed disables DRAM refresh, so my logic analyser images don’t have so much noise in them. After that, it just loops forever not doing anything.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode z80asm"><code class="sourceCode z80asm"><span id="cb1-1"><a href="#cb1-1"></a><span class="fu">reset:</span>	<span class="dt">.org</span>	<span class="bn">$0000</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>	ld	<span class="at">a</span>, <span class="bn">0</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>	out0	(RCR), <span class="at">a</span>	<span class="co">; disable the DRAM refresh</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>	jp	_start</span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="co">; … other RST vectors omitted …</span></span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="fu">_start:</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>	nop</span>
<span id="cb1-10"><a href="#cb1-10"></a>	jp	_start</span></code></pre></div>
<p>After a reset, the data lines look like this. I’ve added handy little labels for the signals.</p>
<figure>
<img src="/images/boot-from-rom.png" alt="" /><figcaption>On reflection, it probably would have been easier to read as D7:0.</figcaption>
</figure>
<p>Decoding and cross-referencing these binary values with the listing file for the ROM image shows it executing exactly what it should, and it’s apparent that immediately after the <code class="sourceCode z80asm">out0</code> the DRAM refresh ceases, and the CPU repeatedly requests the <code class="sourceCode z80asm">nop</code> and <code class="sourceCode z80asm">jp</code> instructions</p>
<table>
<thead>
<tr class="header">
<th>bits</th>
<th>hex</th>
<th>assembly</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>00111110</code></td>
<td><code>3E</code></td>
<td><code class="sourceCode z80asm">ld <span class="at">a</span>, <span class="bn">0</span></code></td>
</tr>
<tr class="even">
<td><code>00000000</code></td>
<td><code>00</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>11101101</code></td>
<td><code>ED</code></td>
<td><code class="sourceCode z80asm">out0 (RCR), <span class="at">a</span></code></td>
</tr>
<tr class="even">
<td><code>00111001</code></td>
<td><code>39</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>00110110</code></td>
<td><code>36</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>11000011</code></td>
<td><code>C3</code></td>
<td><code class="sourceCode z80asm">jp <span class="bn">$0038</span></code></td>
</tr>
<tr class="odd">
<td><code>00111000</code></td>
<td><code>38</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>00000000</code></td>
<td><code>00</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>00000000</code></td>
<td><code>00</code></td>
<td><code class="sourceCode z80asm">nop</code></td>
</tr>
</tbody>
</table>
<p>I don’t think I’ve convinced friends or family that this is, in fact, quite an exciting milestone. Nevertheless, it is: I have written code that runs on my CPU. The rest of the computer is just details…</p>
<p>The STM32’s usefulness for this stage of the project is, I think, now at an end. It may return as a USB keyboard controller down the line, but this project is ready for PCB design.</p>
<p>Meanwhile, the PC104 headers I ordered arrived, after 84 days. My guess is they fell behind something in Customs and were only recently found. They were very well packed, and are undamaged, so I contacted the seller and placed another order that the seller didn’t ship. Since my refund didn’t include the tax I paid, and my new order did, I’ve now paid twice the tax on the headers, taking their total cost up to $12.70 for five 40-pin headers and two 64-pin headers. My stand-offs also arrived, so there’s now nothing in transit.</p>
<p>I also ordered and received an Altera MAX II CPLD minimal development board, for $11.56. This board saves me a lot of fiddly soldering making my own on perfboard, and will let me trial the use of a relatively cheap CPLD IC for address decoding or video output. I booted up Intel’s Quartus II to a sufficient level to verify the board works - to cut a long story short on it, it’s just a lot easier on a Mac to run Quartus in a desktop Linux VM than it is to try to make it work in Docker.</p>
<p>I’m going to mark the Debug section of the project as complete. It’s possible I’ll need further debugging aids later in the project, but each quarter I’ll want to review my targets and check they still make sense given what I’ve learned so far.</p>
<table style="width:86%;">
<caption>Project status update</caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 10%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Budget</th>
<th style="text-align: center;">CPU</th>
<th style="text-align: center;">Power</th>
<th style="text-align: center;">Keyboard</th>
<th style="text-align: center;">Video</th>
<th style="text-align: center;">Memory</th>
<th style="text-align: center;">Debug</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">$233.61 of $400</td>
<td style="text-align: center;">██──</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">done</td>
</tr>
</tbody>
</table>]]></summary>
</entry>
<entry>
    <title>Testing STM32 code</title>
    <link href="https://bje.id.au/blog/posts/trs20/008-test-it.html" />
    <id>https://bje.id.au/blog/posts/trs20/008-test-it.html</id>
    <published>2020-02-09T00:00:00Z</published>
    <updated>2020-02-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>There’s now code worth testing in my project: address line decoding. Let’s take another sidebar journey into automated testing of embedded code, and see where it leads.</p>
<!--more-->
<p>I’ve been claiming loudly for a while now that there’s no good reason to begin any new projects in C when there’s Rust available instead, and that there’s precious little reason for new projects in C++, barring libraries you just cannot expose to Rust and cannot live without. As a result, this project is done in Rust.</p>
<p>The basic problem facing me is that I’m extremely inexperienced with ARM assembly and the Thumb-2 instruction set. I’d like to be able to test my ideas and expectations before flashing code to my device, which means I want to execute my code on my development host.</p>
<p>I originally considered firing up <a href="https://www.qemu.org/">QEMU</a>. The current master branch has support for one STM32F4 processor, so it’s not an outrageous stretch to build a black pill emulator, but the support is threadbare and QEMU isn’t set up for being a unit test executor.</p>
<p>My <a href="https://github.com/codebje/rustmtest/">solution</a> uses the <a href="http://www.unicorn-engine.org/">Unicorn engine</a>, which is backed by QEMU, to set up the memory map of an STM32F401. I then load my ELF intermediate output, which has a symbol table, and copy the loadable segments into the emulator’s memory.</p>
<p>Tests are defined as a DSL that specifies the input and output register states, and selects a symbol to call.</p>
<p>The GitHub workflow for this project builds a binary, automatically tags a new release if the version number in <code>Cargo.toml</code> has changed, and publishes the binary to the release.</p>
<p>I can now take this local function for breaking my 8 bits of address space out of port B and into an address in either RAM or ROM:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode armasm"><code class="sourceCode armasm"><span id="cb1-1"><a href="#cb1-1"></a>        .type           memaddr, %function</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="fu">memaddr:</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>        // the memory address is in PB0:<span class="bn">1</span>, <span class="bn">5</span>:<span class="bn">10</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>        movw            <span class="at">r2</span>, <span class="bn">0</span>b11111100</span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a>        // top <span class="bn">6</span> bits into <span class="at">r1</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>        and             <span class="at">r1</span>, <span class="at">r2</span>, <span class="at">r0</span>, lsr <span class="bn">3</span></span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a>        // assemble full address into <span class="at">r0</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>        and             <span class="at">r0</span>, <span class="at">r0</span>, <span class="bn">0</span>b11</span>
<span id="cb1-11"><a href="#cb1-11"></a>        orr             <span class="at">r0</span>, <span class="at">r1</span>, <span class="at">r0</span></span>
<span id="cb1-12"><a href="#cb1-12"></a></span>
<span id="cb1-13"><a href="#cb1-13"></a>        // check if RAM or ROM</span>
<span id="cb1-14"><a href="#cb1-14"></a>        movw            <span class="at">r1</span>, <span class="bn">1</span></span>
<span id="cb1-15"><a href="#cb1-15"></a>        eors            <span class="at">r1</span>, <span class="at">r1</span>, <span class="at">r0</span>, lsr <span class="bn">7</span></span>
<span id="cb1-16"><a href="#cb1-16"></a></span>
<span id="cb1-17"><a href="#cb1-17"></a>        ite             eq</span>
<span id="cb1-18"><a href="#cb1-18"></a>        ldreq           <span class="at">r2</span>, =RAM_BASE</span>
<span id="cb1-19"><a href="#cb1-19"></a>        ldrne           <span class="at">r2</span>, =ROM_BASE</span>
<span id="cb1-20"><a href="#cb1-20"></a></span>
<span id="cb1-21"><a href="#cb1-21"></a>        <span class="kw">add</span>             <span class="at">r0</span>, <span class="at">r0</span>, <span class="at">r2</span></span>
<span id="cb1-22"><a href="#cb1-22"></a></span>
<span id="cb1-23"><a href="#cb1-23"></a>        <span class="kw">bx</span>              <span class="at">lr</span></span>
<span id="cb1-24"><a href="#cb1-24"></a></span>
<span id="cb1-25"><a href="#cb1-25"></a>        .size           memaddr, . - memaddr</span></code></pre></div>
<p>… and confirm that my use of unfamiliar instructions like <a href="http://infocenter.arm.com/help/topic/com.arm.doc.kui0100a/armasm_cjabicci.htm">ite</a> work the way I expect with a test script:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode armasm"><code class="sourceCode armasm"><span id="cb2-1"><a href="#cb2-1"></a><span class="fu">test:</span> Memory Address decode</span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="fu">setup:</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    <span class="at">r0</span> = <span class="bn">0</span>b10111011101</span>
<span id="cb2-5"><a href="#cb2-5"></a></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="fu">call:</span> memaddr</span>
<span id="cb2-7"><a href="#cb2-7"></a></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="fu">check:</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="at">r0</span> = <span class="bn">0</span>x200000b9</span>
<span id="cb2-10"><a href="#cb2-10"></a>    <span class="at">r1</span> = <span class="bn">0</span></span></code></pre></div>
<p>It’s easy to also wrap a download of the released binary from GitHub into an action in the <a href="https://github.com/codebje/stm32-debug/">RAM/ROM project</a> and have automatic unit testing take place.</p>
<p>Constantly practicing repeatable and automated processes for building, testing, and deploying makes it easier and more habitual to do for everything. I may have lost two or three days of STM32F4 assembly coding time in writing my test executor and its workflow actions, but I’ve gained a lot more confidence that the code will work as expected once it hits the μC, and I expect I’ll easily make back that time in fewer mistakes on device, where it’s harder to inspect.</p>]]></summary>
</entry>
<entry>
    <title>The TRS-20 - STM32F4 driver</title>
    <link href="https://bje.id.au/blog/posts/trs20/007-build-it.html" />
    <id>https://bje.id.au/blog/posts/trs20/007-build-it.html</id>
    <published>2020-02-02T00:00:00Z</published>
    <updated>2020-02-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>With my <a href="/post/trs20/006-fake-it.html">plan</a> sorted out, it’s time to get down to code. I’ll set up my build environment, take a look at testing options, configure timers, make a bunch of mistakes, and eventually test my hypothesis that an STM32F4 is fast enough to pretend to be the RAM and ROM for a 1MHz Z180.</p>
<!--more-->
<h2 id="build-first">Build first</h2>
<p>I find it to be good practice for any project to start with the build and deployment processes. I want to be able to evolve my processes as my project evolves, and I don’t want to encounter infrastructure surprises late in the project when everything is more complicated and change is costlier.</p>
<p>My initial build process was a straightforward Makefile to build a single assembly source file with a single <code class="sourceCode armasm"><span class="dt">.text</span></code> section and link it as per the <a href="http://www.martinhubacek.cz/arm/arm-cortex-bare-metal-assembly/stm32f0-cortex-m0-bare-metal-assembly">Cortex M0 example</a> I mentioned in the last post. This got me far enough to inspect binary outputs, which leads to understanding why my assembly sources should begin with the following three directives.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode armasm"><code class="sourceCode armasm"><span id="cb1-1"><a href="#cb1-1"></a>        .thumb</span>
<span id="cb1-2"><a href="#cb1-2"></a>        .cpu            cortex-m4</span>
<span id="cb1-3"><a href="#cb1-3"></a>        .unified</span></code></pre></div>
<p>The STM32F series is based on a Cortex M4 design. The M4 permits two instruction sets, the ARMv7 and Thumb sets - the Thumb set has 32-bit extensions (sometimes called Thumb v2), and the STM32F4 only supports Thumb mode. The directives then tell the assembler to emit Thumb opcodes, to use the set of opcodes supported by the M4, and to use a unified syntax common to both sets as the original Thumb mnemonics kind of sucked.</p>
<p>Switching between ARMv7 and Thumb modes is accomplished with a couple of branch-and-exchange-mode instructions. If the target address has its least significant bit set, then Thumb mode is enabled. Otherwise, ARMv7 mode is enabled. I’ll never use the <code class="sourceCode armasm"><span class="kw">bx</span></code> instructions, but this LSB signal also crops up for the processor’s vector table.</p>
<p>You could simply set the LSB on each address in the vector table with something like <code class="sourceCode armasm"><span class="dt">.word</span> _start + <span class="bn">1</span></code>, but the GNU ARM assembler knows its business and will set the bit for you if you tell it that a symbol is for a function entry point, with <code class="sourceCode armasm">.type _start, %function</code>.</p>
<h2 id="but-what-of-the-tests">But what of the tests?</h2>
<p>Testing embedded code brings some interesting challenges, ones I’m not familiar with. Checking that the code builds and opening up an ELF file in GDB don’t get you a whole lot of assurance. My first thought was to use QEMU to emulate the STM32F4, as this lets me test code without worrying about plugging a device in. Sadly, QEMU does not support any STM32s out of the box, and my Googling found only a project for an STM32F103. Firing up QEMU with some other Cortex M4 based system doesn’t help much, since the M4 is only the processor. The STM32F4 and other M4 based designs are differentiated by their peripherals, including their memory maps. Since my code is linked at 0x08000000, most CPUs won’t even see my vector table or code in the right places.</p>
<p>As it turns out, in the current (as of writing) master branch of qemu, some gentle soul has added an STM32F405 SoC, and a machine built on top of it. It’s quick work to add an STM32F401 SoC and a Black Pill machine to my local checkout, so I now have the capacity to run my ARM code on an emulator for the target device.</p>
<p>Testing chip configuration via an emulator is of limited value though - the emulator’s peripherals all do nothing - so I will leave off any further investigation of automated testing until I have something worth testing.</p>
<h2 id="on-to-the-code">On to the code!</h2>
<p>I’ve refactored my code base to have a separate startup module in <code>start.s</code>, which configures the clocks and then calls <code>main</code>. This code broadly follows the outline of my last post, with the configuration of the APB1 prescaler moved to happen first. This prescaler <em>must</em> be set before the system clock ramps up from 16MHz to 84MHz for the APB1 bus to never exceed 42MHz, but it can take up to 16 AHB cycles for a change to the prescalers to take effect. With a populated pipeline, most STM32F4 instructions take only one cycle.</p>
<p>I’d like to test my clock configuration, so I’ll fire up one of the timers to emit what should be a 1MHz signal. TIM2 is on the supposedly 42MHz APB1 bus, and TIM9 is on the supposedly 84MHz APB2 bus. I’ll test TIM2’s output first. By using channel 3 of TIM2, and channel 1 of TIM9 all my output will be on the same pin, PA2, so I won’t have to change my wiring.</p>
<p>An STM32 timer’s output frequency is governed by its clock frequency, its prescaler, and its period. With a clock of 42MHz and a desired output frequency of 1MHz, this means the prescaler times the period must equal 42. Integer factors of 42 include 6 and 7, which are fine for what I want. This means I’ll set the <code>TIM2_PSC</code> prescale register to 6, and the <code>TIM2_ARR</code> auto-reload register to 5. The minus one happens because the STM32 timers count from zero and do not reset until overflow. A prescale value of 6 means the timer will count <code>[0, 1, 2, 3, 4, 5, 6]</code> and then reset, taking seven time intervals to complete.</p>
<p><span class="math display">\[F = \frac{\mathrm{CK\_INT}}{(\mathrm{TIM2\_PSC} + 1)\times(\mathrm{TIM2\_ARR} + 1)}\]</span></p>
<p>With the timer ticking away at what I expect to be 1MHz, the next task is to produce a square wave on an output pin. There’s an output compare mode in which a pin can be set, reset, or toggled when the timer’s counter reaches a configured value. Using this mode would produce a square wave at 500KHz, so I would have to double the timer’s frequency. Using Pulse Width Modulation (PWM) modes, a duty cycle is established based on the <code>TIM2_CCRx</code> capture/compare register, where <code>x</code> is the channel being used. The <code>OCREF</code> output compare reference signal is high while the timer’s counter is lower than the CCR, otherwise it’s low. By setting <code>TIM2_CCR3</code> to 3, I should see a nice square wave 1MHz signal on the output pin.</p>
<table>
<caption>The subset of registers and bits that must be configured.</caption>
<colgroup>
<col style="width: 12%" />
<col style="width: 6%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Register</th>
<th style="text-align: center;">Bits</th>
<th style="text-align: center;">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">TIM2_CR1</td>
<td style="text-align: center;">CEN</td>
<td style="text-align: center;">Counter enable, set to start the timer.</td>
</tr>
<tr class="even">
<td style="text-align: center;">TIM2_EGR</td>
<td style="text-align: center;">UG</td>
<td style="text-align: center;">Update generation, set by software to reset the timer and update shadow registers.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">TIM2_CCMR2</td>
<td style="text-align: center;">OC3M CC3S</td>
<td style="text-align: center;">Output compare mode. Set to 0b100 for PWM mode 1. Capture/Compare selection. Set to 0b00 for output mode.</td>
</tr>
<tr class="even">
<td style="text-align: center;">TIM2_CCER</td>
<td style="text-align: center;">CC3E</td>
<td style="text-align: center;">Capture/Compare output enable.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">TIM2_PSC</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Prescaler, to be set to 6.</td>
</tr>
<tr class="even">
<td style="text-align: center;">TIM2_ARR</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Auto-reload, to be set to 5.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">TIM2_CCR3</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Capture/Compare register, to be set to 3.</td>
</tr>
</tbody>
</table>
<p>All of the timer registers are reset to zero except for the auto-reload register which is set to 0xffff ffff. This means any settings I’m not interested in that are safe to leave at zero can be ignored. The code to configure TIM2 is <a href="https://github.com/codebje/trs20-debug/blob/fe11a903a1df9553ae3c87e779e340607668d3f4/main.s#L46">here</a>. It’s time to flash this sucker to a device and see what’s on pin A2.</p>
<p>To flash the device, I’m programming over USB. I could use the SWDIO pins for this, which would give me debugging support too. However, those pins don’t supply power, and I’d need to run the USB cable anyway. The open-source [dfu-util][dfu] tool will program many ST devices, including the STM32F4 using the bootloader. The STM32F4 can be reset to boot from the bootloader by asserting BOOT0 during a reset (with BOOT1 low). The Black Pill board has a button for this purpose, and pulls BOOT1 (aka PB2) low at all times. Programming the board via USB is as simple as holding BOOT and pressing NRST, then using a magic invocation of <code>dfu-util</code> to flash my binary image at the right address, into the right device target.</p>
<h2 id="experiments">Experiments</h2>
<p>Because I have no facility to test register configuration, I’m taking a cautious approach. I’ve commented out all code to write to the clock configuration registers, leaving only the timer output. With the HSI running at 16MHz, I expect to see a signal of <span class="math inline">\(\frac{16\mathrm{MHz}}{42} = ~381\mathrm{KHz}\)</span>.</p>
<figure>
<img src="/images/timers%20-%20flatline.png" alt="" /><figcaption>I’m no electrical engineer, but I’m pretty sure that’s a 0Hz signal.</figcaption>
</figure>
<p>I made several mistakes, which isn’t entirely unexpected. I can’t debug on the device itself, because my st-link clone appears to be broken, possibly fried by my own actions, but I can inspect my code in a debugger.</p>
<p>The first problem is that my linker script wasn’t quite right. You are free to name your output sections anything you like, and I chose <code>.vectors</code> for my vector table. However, that freedom is limited by your output format. In an ELF binary, however, certain section names are magical.</p>
<pre><code>Idx Name          Size      VMA       LMA       File off  Algn
  0 .vectors      0000001c  08000000  08000000  0001803c  2**0
                  CONTENTS, READONLY
  1 .text         000000dc  08000000  08000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00007f60  080000dc  080000dc  000100dc  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.attributes 00000021  00000000  00000000  00018058  2**0
                  CONTENTS, READONLY</code></pre>
<p>As I planned it, my <code>.vectors</code> section is at VMA 0x08000000, hooray. But its flags don’t include ALLOC or LOAD, so the section is never loaded into memory, or flashed onto the device. Instead, the <code>.text</code> section is loaded at VMA 0x08000000, and the processor attempts to jump to 0x60b00000 to run code, as shown in gdb with <code>x/2xw 0x08000000</code>. This does not succeed. The problem is easily solved: I put the <code>.vectors</code> input section into the <code>.text</code> output section.</p>
<p>The next problem is in this little excerpt of code, that is supposed to set pin A2’s mode to its alternate function.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode armasm"><code class="sourceCode armasm"><span id="cb3-1"><a href="#cb3-1"></a>        <span class="kw">ldr</span>     <span class="at">r0</span>, [<span class="at">r6</span>, GPIOx_MODER]</span>
<span id="cb3-2"><a href="#cb3-2"></a>        orr     <span class="at">r0</span>, <span class="at">r0</span>, GPIOx_MODER_MODE_ALT</span>
<span id="cb3-3"><a href="#cb3-3"></a>        <span class="kw">str</span>     <span class="at">r0</span>, [<span class="at">r6</span>, GPIOx_MODER]   // set PA2 to mode AF</span></code></pre></div>
<p>Symbolic constants abound. I can check those by cross-referencing where they’re defined, but I can also fire up a debugger and look at what code is in the byte stream.</p>
<pre><code>0x080000a2 &lt;+46&gt;:	ldr	r0, [r6, #0]
0x080000a4 &lt;+48&gt;:	orr.w	r0, r0, #2
0x080000a8 &lt;+52&gt;:	str	r0, [r6, #0]</code></pre>
<p><code>#0</code> is the right offset for <code>GPIOx_MODER</code>, but what’s this? <code>#2</code> is definitely not the right constant for setting pin 2 to AF - it’s the right constant for setting pin 0 to AF. I neglected to shift my symbolic constant into the right spot for the pin I want to affect.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode armasm"><code class="sourceCode armasm"><span id="cb5-1"><a href="#cb5-1"></a>        orr     <span class="at">r0</span>, <span class="at">r0</span>, GPIOx_MODER_MODE_ALT &lt;&lt; <span class="bn">4</span></span></code></pre></div>
<p>And now, I see output.</p>
<figure>
<img src="/images/timers%20-%20heartbeat.png" alt="" /><figcaption>The earlier peaks here measure as 375KHz, so I cherry picked the best one.</figcaption>
</figure>
<p>I see the output I predicted, no less. The time there is 2.625μs, which is exactly 42 divided by 16. Every few intervals, the measured frequency is 375KHz, which I would expect is because either the internal oscillator or my cheap logic analyser’s clock are not perfectly accurate. A 2.625μs measurement is 63 samples at 24MHz, while a 2.667μs measurement is 64 samples.</p>
<h2 id="changing-clocks">Changing clocks</h2>
<p>Able to see output, it’s now time to start changing my clock speeds. I’ll start by verifying I can change the APB1 divider, because that’s the one I need to get right before mucking with the system clock. This means re-including stores to <code>RCC_CFGR</code>. While I’m there, I’ll also turn on the HSE and wait for it to be ready, and as the last thing I do in my <code>main</code>, I’ll turn on PC13 as a push-pull output, driven low, to turn on the board’s blue LED. This will give me a quick visual indicator that my code has made it through all of the configuration, instead of hitting a trap or an endless loop.</p>
<p>With the APB1 divider set to 2, I now expect to see 5.25μs between peaks, a 190KHz rate, taking 126 samples. I may see 189KHz as well, which is 127 samples. Let’s take a look.</p>
<figure>
<img src="/images/timers%20-%20heartbeat.png" alt="" /><figcaption>Yes, this is the same image as before.</figcaption>
</figure>
<p>Well, hmm. Am I failing to configure the APB1 clock divider? If so, how? A peek at my code shows I forgot to actually set <code class="sourceCode armasm"><span class="at">r6</span></code> to <code>RCC</code>, so I’m attempting to set the clock by writing a word into Flash. This does not succeed. I fix that up, and…</p>
<figure>
<img src="/images/timers%20-%20heartbeat.png" alt="" /><figcaption>Yes, this is still the same image as before.</figcaption>
</figure>
<p>Uh. Well, it’s midnight, I should sleep.</p>
<h2 id="finding-the-mistake">Finding the mistake</h2>
<p>There is a very good reason for the timer output being unchanged despite the APB1 clock divider being set to two. The reason for it is right there on the clock tree diagram from the <a href="006-fake-it.html">last post</a>: the timers on APB1 and APB2 have their clocks multiplied by a value that’s set by the microcontroller, based on the APBx prescaler. From the reference manual (RM0368 rev. 5, p94):</p>
<blockquote>
<p>If the APB prescaler is configured to a division factor of 1, the timer clock frequencies (TIMxCLK) are set to HCLK. Otherwise, the timer clock frequencies are twice the frequency of the APB domain to which the timers are connected: TIMxCLK = 2xPCLKx.</p>
</blockquote>
<p>So it turns out that I am seeing what I would expect to see if I set the APB1 divider to 2.</p>
<p>It’s also around this point that I reflect on the fact that my logic analyser has eight inputs, and I’m only using one. I can observe both TIM9 and TIM2 at once. I’ll use PA3 for TIM9 channel 2, and switch to PA1 for TIM2 channel 2, so I can re-use the timer setup code trivially.</p>
<p>With a big change to my port setup code, I’ll check my constants via gdb again:</p>
<pre><code>   0x08000088 &lt;+32&gt;:	ldr	r6, [pc, #108]	; (0x80000f8)
   0x0800008a &lt;+34&gt;:	mov.w	r0, #204	; 0xcc
   0x0800008e &lt;+38&gt;:	str	r0, [r6, #8]
   0x08000090 &lt;+40&gt;:	movw	r0, #12304	; 0x3010
   0x08000094 &lt;+44&gt;:	str	r0, [r6, #32]
   0x08000096 &lt;+46&gt;:	ldr	r0, [r6, #0]
   0x08000098 &lt;+48&gt;:	orr.w	r0, r0, #136	; 0x88
   0x0800009c &lt;+52&gt;:	str	r0, [r6, #0]</code></pre>
<p>Address <code>0x80000f8</code> has the right value for <code>GPIOA</code>. <code>0xcc</code> is <code>1100 1100</code>, which sets very high speed on pins 1 and 3. <code>0x3010</code> is <code>0011 0000 0001 0000</code>, written to <code>GPIOx_AFLR</code>, sets pin 3 to AF03, and pin 1 to AF01. And finally, <code>0x88</code> is <code>1000 1000</code>, written to <code>GPIOx_MODER</code>. This assumes the modes for pins 1 and 3 are in their reset state, and sets them to AF mode.</p>
<p>With APB1’s clock now divided by four, I’m ready to run this sucker.</p>
<figure>
<img src="/images/timers%20-%20paired.png" alt="" /><figcaption>If this were a gif sort of blog, there’d be a celebratory dance of some kind right here.</figcaption>
</figure>
<p>I configured both timers with prescale 7, counter 6. With APB2’s timers running twice as fast as APB1’s, I now expect to see TIM9 spitting out a 381KHz signal, and TIM2 spitting out a 190KHz signal.</p>
<h2 id="the-rest-of-the-owl">The rest of the owl</h2>
<p>With the most risky part out of the way, it’s time to fire up the whole configuration scheme and get the part running at 84MHz. I’ve set APB2’s divider back down to two, which means both TIM2 and TIM9 will be running at 84MHz. The settings I have for prescaler and counter should produce a 2MHz signal (84/6/7 = 2).</p>
<figure>
<img src="/images/timers%20-%202mhz.png" alt="" /><figcaption>Sort of anticlimatic, when everything works as predicted.</figcaption>
</figure>
<p>Now I need to refer back to my notes so I can start reacting to signals. The pins I’ve defined are:</p>
<table>
<thead>
<tr class="header">
<th>STM32</th>
<th>Z180</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PA0:7</td>
<td>D0:7</td>
<td>Data bus, in/out</td>
</tr>
<tr class="even">
<td>PA9</td>
<td>-</td>
<td>STM32’s “processing read” flag</td>
</tr>
<tr class="odd">
<td>PB0:1</td>
<td>A0:1</td>
<td>First two address lines</td>
</tr>
<tr class="even">
<td>PB5:10</td>
<td>A2:7</td>
<td>Next six address lines</td>
</tr>
<tr class="odd">
<td>PB12</td>
<td>IORQ</td>
<td></td>
</tr>
<tr class="even">
<td>PB13</td>
<td>MREQ</td>
<td></td>
</tr>
<tr class="odd">
<td>PB14</td>
<td>WR</td>
<td></td>
</tr>
<tr class="even">
<td>PB15</td>
<td>RD</td>
<td></td>
</tr>
</tbody>
</table>
<p><em>Note: the mistake I made in the previous post to somehow forget that the address bus is 16-bits continues here. I won’t fix it, I’ll live with it and move on to using real memory.</em></p>
<p>The code to watch for a memory request and react to it is straightforward. I read from the GPIOB input data register and check to see if MREQ and RD (bits 13 and 15) are set. If not, I loop and read again.</p>
<p>If so, then I set PA9 using the bit set/reset register for GPIOA, then I wait for either MREQ or RD to clear. I then reset PA9, and loop back to wait for MREQ and RD again.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode armasm"><code class="sourceCode armasm"><span id="cb7-1"><a href="#cb7-1"></a><span class="fu">loop:</span>   // wait for MREQ and RD to be set</span>
<span id="cb7-2"><a href="#cb7-2"></a>        <span class="kw">ldr</span>             <span class="at">r0</span>, [<span class="at">r6</span>, GPIOx_IDR]</span>
<span id="cb7-3"><a href="#cb7-3"></a>        ands            <span class="at">r1</span>, <span class="at">r0</span>, <span class="bn">0</span>b1010000000000000</span>
<span id="cb7-4"><a href="#cb7-4"></a>        <span class="kw">beq</span>             loop</span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a>        // set PA9 to indicate memory read is active</span>
<span id="cb7-7"><a href="#cb7-7"></a>        <span class="kw">ldr</span>             <span class="at">r0</span>, =<span class="bn">1</span> &lt;&lt; <span class="bn">9</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>        <span class="kw">str</span>             <span class="at">r0</span>, [<span class="at">r5</span>, GPIOx_BSRR]</span>
<span id="cb7-9"><a href="#cb7-9"></a></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="fu">reading:</span>// wait for MREQ and RD to go inactive</span>
<span id="cb7-11"><a href="#cb7-11"></a>        <span class="kw">ldr</span>             <span class="at">r0</span>, [<span class="at">r6</span>, GPIOx_IDR]</span>
<span id="cb7-12"><a href="#cb7-12"></a>        ands            <span class="at">r1</span>, <span class="at">r0</span>, <span class="bn">0</span>b1010000000000000</span>
<span id="cb7-13"><a href="#cb7-13"></a>        <span class="kw">bne</span>             reading</span>
<span id="cb7-14"><a href="#cb7-14"></a></span>
<span id="cb7-15"><a href="#cb7-15"></a>        // reset PA9</span>
<span id="cb7-16"><a href="#cb7-16"></a>        <span class="kw">ldr</span>             <span class="at">r0</span>, =<span class="bn">1</span> &lt;&lt; <span class="bn">25</span></span>
<span id="cb7-17"><a href="#cb7-17"></a>        <span class="kw">str</span>             <span class="at">r0</span>, [<span class="at">r5</span>, GPIOx_BSRR]</span>
<span id="cb7-18"><a href="#cb7-18"></a></span>
<span id="cb7-19"><a href="#cb7-19"></a>        b               loop</span></code></pre></div>
<p>There’s a logic error in here I introduced in the 11th hour, so it works <em>almost</em> as expected. The logic analyser’s capture shows the STM32 dropping PA9 low when MREQ and RD are low, and PA9 staying high during a DRAM refresh cycle when only MREQ goes low. Of course, I wrote it thinking I was asserting PA9 high when MREQ/RD were active, but I forgot to take into account that these two lines are active low. Despite this, the timing here shows the STM32F4 will comfortably respond to a read request in time, and have no trouble turning output off when it should relinquish the bus.</p>
<figure>
<img src="/images/timers%20-%20reacting.png" alt="" /><figcaption>The slowest reaction I could find in here was 166.667ns.</figcaption>
</figure>
<p>A few other things have gone a little bit wrong, of course. I was having trouble getting the STM32 to boot up correctly: it would only work immediately after being flashed on. Turns out I forgot to uncomment the Flash wait state register write, which as promised crashes the μC. I have to plug in the STM32’s USB cable before the logic analyser: I suspect a ground loop is at fault. And my ghetto breadboard header for the 50-pin IDC socket is really not a good piece of engineering, so A1 isn’t wired up right. This final point means I’ve got to bust out a soldering iron before I can make the STM32 act as RAM and ROM.</p>
<figure>
<img src="/images/timers%20-%20test%20rig.jpg" alt="" /><figcaption>There’s a cheeky 74HC245N photobombing my rig.</figcaption>
</figure>
<p>I also don’t really like my chances of fitting enough wires on this breadboard to wire up the data lines via a ’245. Another round of fiddly soldering of 40 or so wires, here I come.</p>
<p>This experiment has been a great success. I’ve programmed my STM32F4 from the ground up, detected the Z180’s memory requests, and confirmed that an 84MHz μC is easily fast enough to be RAM and ROM for a 1MHz processor. Nice.</p>
<table style="width:86%;">
<caption>Project status update</caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 10%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Budget</th>
<th style="text-align: center;">CPU</th>
<th style="text-align: center;">Power</th>
<th style="text-align: center;">Keyboard</th>
<th style="text-align: center;">Video</th>
<th style="text-align: center;">Memory</th>
<th style="text-align: center;">Debug</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">$209.35 of $400</td>
<td style="text-align: center;">██──</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">███─</td>
</tr>
</tbody>
</table>]]></summary>
</entry>
<entry>
    <title>The TRS-20 - fake it 'til you make it</title>
    <link href="https://bje.id.au/blog/posts/trs20/006-fake-it.html" />
    <id>https://bje.id.au/blog/posts/trs20/006-fake-it.html</id>
    <published>2020-01-27T00:00:00Z</published>
    <updated>2020-01-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>My processor appears to be happy in its perfboard home for now. While I can get pretty excited over seeing signal probes confirm data sheet timing diagrams, I’ll admit that it’s a limited success. There is still a long road to having a homebrew computer built. What I’d like to do next is give the processor some RAM and ROM, and have it execute programs more significant than endless <code>NOP</code>s. I’d like to exercise the other major machine cycles - memory write, and I/O reads and writes, so I can get excited about signal probes confirming a whole new swathe of timing diagrams.</p>
<p>To achieve this, I’ll use my STM32F401CC “black pill” board to act as the RAM and ROM, and use its connection to my LCD to display runtime status information. With 256KiB of Flash and 64KiB of SRAM, there’s space on the black pill to share with the Z180… but can the 84MHz STM32F401CC react fast enough to deliver data smoothly to the 1MHz Z180?</p>
<!--more-->
<p><em>Note: this post contains a significant mistake that flows on to the next post. I’ve annotated the mistake in a subsequent edit, but have otherwise left it as-is.</em></p>
<h2 id="will-they-blend">Will they blend?</h2>
<p>At a physical level, there’s no particular problem with wiring up the STM32 to the Z180. The STM32 is 5V tolerant, so as long as voltage levels, current limits, and impedance requirements line up, I can wire the two up directly.</p>
<p><span class="math display">\[\begin{array}{rrcll}
&amp; \text{STM32} &amp; &amp; \text{Z180} &amp; \\\hline
V_{IL} &amp;1V &amp;\leq&amp;  0.45V &amp;V_{OL} \\
V_{IH} &amp;2.3V &amp;\leq&amp; 2.4V &amp;V_{OH} \\
V_{OL} &amp;0.4V &amp;\geq &amp; 0.8V &amp;V_{IL} \\
V_{OH} &amp;2.4V &amp;\geq &amp; 2.0V &amp;V_{IH} \\
\end{array}
\]</span></p>
<p>There’s a possible concern with the V<sub>IH</sub> for the STM32 at 2.31V, and the V<sub>OH</sub> of the Z180 at 2.4V. 100mV is not a lot of margin. The datasheet indicates that the Z180 will put out a voltage of V<sub>CC</sub>-1.2 if the output current is 20μA or less. The dynamic current consumption of the STM32 is calculated below, based on a pin capacitance on the Z180 of up to 12pF plus some stray capacitance.</p>
<p><span class="math display">\[\begin{aligned}
I_{SW}  &amp;= C_L \times V_{DD} \times F_{SW} \\
        &amp;= 20\mathrm{pF} \times 3.3\mathrm{V} \times 1\mathrm{MHz} \\
        &amp;= 20\times10^{-12} \times 3.3 \times 1\times10^6 \\
        &amp;= 20\times10^{-6} \times 3.3 \\
        &amp;= 60\times10^{-6} \\
        &amp;= 60\textrm{μA}
\end{aligned}\]</span></p>
<p>60μA means the high output voltage will be somewhere between 2.4V and 3.8V. There’s no curve provided, alas, but having a lower current than 200μA means the high level will be over 2.4V, and the circuit should behave correctly.</p>
<figure>
<img src="/images/black-pill-schematic.png" alt="" /><figcaption><a href="https://user-images.githubusercontent.com/26240765/60139875-2fb05880-97e2-11e9-9a82-5670e73c8bd1.png">This</a> might not be the same thing that I have, but it will be close to it.</figcaption>
</figure>
<p>There’s also the matter of pin assignments. The black pill board has an STM32F401CCU6 processor on it, which is a 48-pin device. Ten pins are supply pins, two pins are boot/reset signals, and the remaining 36 pins are GPIO - or special purpose. PC14 and PC15 are attached to the external low-speed oscillator, as shown above. According to the full schematic, PC13 is wired to the board’s user LED. PA11 and PA12 are wired to the USB-C socket. PA4 (F_CS), PA5, PA6 (MISO), and PA7 (MOSI) are all wired up to U3, which by the schematic is a 32M SPI Flash chip - this Flash has not been installed on my board, so these pins are available for GPIO. PA13 and PA14 are wired to the serial debug header, and are SWDIO and SWCLK respectively. PB3, PB4, and PA15 are also JTAG pins, but there’s no JTAG header exposed, so I can configure these pins for GPIO. However, PB4 and PA15 are in pull-up state after reset, so care must be taken if they’re wired directly to the Z180.</p>
<p>I2C3 uses PA8 and PB4. PB2 is tied to ground, as it also serves as BOOT1 and must be low when BOOT0 is high to select the bootloader. This leaves PB0:1 and PB5:10 free for the address bus, and PB12:15 for signals. Pulling in MREQ, IORQ, RD, and WR gives me 95% of what I’ll need - I can’t detect an interrupt acknowledge, differentiate opcode fetch from other memory reads, or see a bus request acknowledgement. PA0:7 are open to be the data bus, so long as I can switch them from output to input fast enough to avoid a bus collision with the Z180. I’m left with PA8:10 for any further signals required.</p>
<p><em>Note: here is my mistake: the address bus on the Z180 is not 8-bit, it’s 20-bit. I never intended to use the full 20 bits, but I did intend to use 16 bits. I’ve only assigned 8 pins for the address bus, which gives me 128 bytes each of RAM and ROM. This isn’t a disaster, since I need to wean myself off the μC anyway, but it is a pretty big error in planning! I’m proceeding with an 8-bit address bus, and if I get desperate PA8:10 can give me 8x the address space.</em></p>
<h2 id="racing-electrons">Racing electrons</h2>
<p>The STM32F4 can be configured to operate at 84 times the system clock speed of the Z180. At this speed, there’s a good chance that the STM32 will have enough time to observe signal changes and connect SRAM or Flash to the data bus depending on the operation involved. And, of course, if there’s any bug in my code then I’ll either lock the data bus on output and possibly burn out pins, or lock it on input and the Z180 will see only noise. A transceiver with its enable and direction inputs controlled by glue logic may be worthwhile to protect my hardware from me.</p>
<p>The basic loop looks something like this:</p>
<p><img src="/images/stm32-ram-rom-flowchart.png" /></p>
<p>There’s 4,500ns available between the fall of T1 and the rise of T3 with a 1MHz clock and three wait states. MREQ and RD may fall as much as 50ns after the fall of T1, and data must be present at least 25ns before the rise of T3, so with the magic of rounding that’s 4,400ns to recognise a memory read request and respond to it. If a read is immediately followed by a write, then the Z180 might be asserting data on the bus as soon as the fall of T1, so it’s imperative that the STM32 stops asserting data as soon as RD rises - that’s one full clock cycle, less the maximum 50ns delay that RD may have, or around 950ns at 1MHz.</p>
<p>I don’t think I can reasonably pre-determine how many clock cycles the STM32 will take for its work, as this isn’t your simple 8-bit 1980s era processor any more. It has an instruction cache (in the Flash interface, not the Cortex-M4 itself), multiple bus masters, and a pipelined CPU with instruction prefetch and branch prediction. Even with interrupts disabled, I don’t think I’d be comfortable declaring that any measurement I make gives a definitive answer of clock cycles used. However, each clock cycle is around 12ns, so I have a hair over 75 cycles to detect RD rising and to change the I/O ports to inputs again.</p>
<p>I can wire up signals in and out of the STM32, but leave address and data disconnected, to see how quickly it can respond to the Z180’s changing signals.</p>
<h2 id="programming-the-stm32">Programming the STM32</h2>
<p>Since this project is about doing pointlessly difficult things for no reason other than learning something that others have already done before me, and better, I’ll program the STM32 in assembly. The bare bones of this is straightforward, as the GCC port for ARM does everything except writing to the device with a minimum of fuss.</p>
<p>There’s only a few details to worry about. The first is that the Flash memory on the STM32F4 series is at 0x08000000:0x08040000, so the linker must be told to place sections into that region. The second is that there is a vector table to place at 0x08000000, containing an initial stack pointer, the reset vector, and a handful of other vectors. Using the <code>-Ttext 0x08000000</code> argument to <code>ld</code> will put the text section at the right offset, and putting the reset vector at the start of the text section more or less does the trick. As my code gets bigger, though, I’ll want to use a linker script to ensure all sections are placed correctly, and that the vector table is placed first, even when I’m linking multiple object files. The trivial method is shown by example <a href="http://www.martinhubacek.cz/arm/arm-cortex-bare-metal-assembly/stm32f0-cortex-m0-bare-metal-assembly">here</a>, and the linker script can easily be cribbed from the output of CubeMX.</p>
<p>After those details are squared away, it’s down to code. The STM32 chips are interesting in that they boot up kind of brain-dead. Most of the peripherals are off, the clock runs off an internal oscillator at a low speed, and there’s no fuses to pre-configure everything like on an AVR. This allows much more software control over the chip’s power consumption, but requires that the chip is configured after every reset, from which peripherals will be used to how the clock runs.</p>
<h2 id="clocking-in">Clocking in</h2>
<p>The STM32F4 has a moderately complex clock tree, compared to the old 8 bit CPUs. There are two internal oscillators, at 32KHz and 16MHz. The low speed internal (LSI) oscillator feeds the RTC system and the internal watchdog, neither of which I will use for now. The high speed internal (HSI) oscillator feeds into the PLL source mux, along with the high speed external (HSE) oscillator. The PLL feeds the USB 48MHz clock, and all three of PLL, HSI, and HSE feed into the system clock mux. From here, the clock is prescaled, then drives the various peripheral buses and such.</p>
<figure>
<img src="/images/stm32-cube-clocks.png" alt="" /><figcaption>Image from STM32CubeMX, which makes all of this easier to work out.</figcaption>
</figure>
<p>Solving the clock tree puzzle means finding values for M, N, P, and Q in the PLL subsystem such that 84MHz can be fed into the system clock mux, and 48MHz can be fed into the USB clock. The high speed oscillator is divided by M, then multiplied by N. This value is divided by P to get the system clock, and by Q to get the USB clock. P is constrained to be 2, 4, 6, or 8, while Q is anything from 2 to 15.</p>
<p><span class="math display">\[\begin{aligned}
    ((25MHz / M) \times N) / P &amp;= 84MHz &amp; \text{system clock} \\
    ((25MHz / M) \times N) / Q &amp;= 48MHz &amp; \text{USB clock}
\end{aligned}\]</span></p>
<p>The trick, at least according to one <a href="https://stm32f4-discovery.net/2015/01/properly-set-clock-speed-stm32f4xx-devices/">tutorial</a>, is to start by ensuring <span class="math inline">\(M\)</span> matches your high speed oscillator so you feed a 1MHz signal into the PLL.</p>
<p><span class="math display">\[\begin{aligned}
    N / P &amp;= 84MHz &amp; \text{system clock} \\
    N / Q &amp;= 48MHz &amp; \text{USB clock}
\end{aligned}\]</span></p>
<p>Now the constraints on <span class="math inline">\(P\)</span> limit the possibilities to finding a value for <span class="math inline">\(N\)</span> that can be divided by 2, 4, 6, or 8 to get 84MHz, and that can be divided by 2 to 15 to get 48MHz. <span class="math inline">\(N\)</span> will be one of 168, 336, 504, or 672. Since <span class="math inline">\(N\)</span> is constrained to be between 50 and 432, the choices are 168 or 336. Of those two, only 336 has no remainder when divided by 48, so the PLL settings are <span class="math inline">\(M\)</span> at 25, <span class="math inline">\(N\)</span> at 336, <span class="math inline">\(P\)</span> at 4, and <span class="math inline">\(Q\)</span> at 7. After that it’s just a matter of setting the prescalers and multipliers for the peripheral clocks to keep everything at 84MHz except for PCLK1, which maxes out at 42MHz instead.</p>
<p>All of this is communicated to the chip by writing to the Reset and Clock Control (RCC) registers, described in gory detail in the STM32F401xx reference manual (RM0368, pp. 103-139).</p>
<ol type="1">
<li><p>The HSE must be turned on. In the case of the black pill board, this is an external crystal, so the RCC Control Register (RCC_CR) will have bit 16 turned on. The software should then wait until bit 17 (HSE RDY) of RCC_CR is set by hardware.</p></li>
<li><p>The PLL must be configured via the RCC PLL configuration register (RCC_PLLCFGR). The PLL is disabled on reset, so it is safe to write to the register in one go, setting M, N, P, Q, and the PLL source. The PLL is then enabled via the RCC_CR, and the program should wait until the PLL is flagged as ready.</p></li>
<li><p>The Flash interface must be configured to use a sufficient number of wait states for the chosen clock speed. At 84MHz, three CPU cycles are required to read from the Flash memory, and so two wait states must be inserted. Writing to the Flash Access Control Register (FLASH_ACR) achieves this - the low byte can be used to select between zero and fifteen wait states.</p></li>
<li><p>The system and peripheral bus clocks must be configured. The APB1 peripheral clock must not exceed 42MHz, so the APB1 prescaler needs to be set before the system clock source is changed to the PLL. When the APB1 prescaler, AHB prescaler, and SYSCLK source have all been configured via the RCC Configuration Register (RCC_CFGR), the clock tree is configured and ready to go.</p></li>
</ol>
<p>There’s one part in this that concerns me a little. The reference manual (RM0368) states that some bits of the RCC_PLLCFGR are reserved and “must be kept at reset value.” The reset value from the manual has one reserved bit set, but the HAL library code happily constructs a value for this register that obliterates that bit. Are they important? Who knows. The HAL certainly has its share of bugs, so my inclination is to stick to what the manual describes, and set the bit.</p>
<h2 id="general-purpose-io-sir">General Purpose IO, <em>sir</em>!</h2>
<p>The final boot-up task is to configure the GPIO pins. PB0:1, PB5:10, and PB12:15 are all to be inputs, while PA0:7 will be inputs unless a read is requested. The two ports are enabled using the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR), bits 0 and 1. However, the errata sheet ES0182 (rev 11, pp 16) notes that there must be a delay between enabling an RCC peripheral clock and any access to that peripheral. One of the three work-arounds suggested is to read back from the register immediately after writing to it.</p>
<p>The reference manual has a chapter explaining the GPIO system. Configuration is managed through four registers per port: the GPIOx_MODER mode register, the GPIOx_OTYPER output type register, the GPIOx_OSPEEDR output speed register, and the GPIOx_PUPDR pull-up/pull-down register. At reset, most GPIO pins are configured as inputs, with the exception of PA13 (analog input) and PB3/4 (alternate function: JTAG/SWD). PA13 and PB3 are configured for very high output speeds, with all other pins at low speed. PA15, PA13, and PB4 are all configured to pull up, with PA14 configured to pull down.</p>
<p>All of port B should stay as inputs; all pins on the port will either be tied to something on the Z180, or already configured to not be floating. Most of port A should stay as it is on reset as well. PA8:10 will be floating, and should have an internal pull-up enabled. PA0:7 are the data lines, and will be shared between the Z180 and the STM32. Setting A0:7 to push-pull in GPIOA_OTYPER should allow a single half-word store to GPIOA_MODER to flip modes. Between the time each IC is trying to drive the lines they will be left floating. Putting an external pull-up resistor on the data lines will help ensure that both ICs always see a valid logic level.</p>
<p>The minimum resistance for the pull-up is determined by how much current will flow through the resistor and into an N-MOS gate driving the line low. The Z180 does not want to sink more than around 2.2mA on an output line being pulled low, while the STM32 claims to be comfortable with 25mA per pin, but only 120mA total across all pins, so around 2mA is a reasonable target for both ICs. This sets the lower bound for the pull-up resistor at 5V/2.2mA or 2.3kΩ.</p>
<p>The maximum resistance depends on both the impedance of the input pin (as the pull-up resistor and the pin’s impedance form a resistor divider that limits the input voltage level seen by the pin), and on the acceptable rise time for a floating line to be pulled high. CMOS high-Z impedance is usually in the MΩ range: the STM32’s leakage current is 3μA, and the Z180’s is 1μA, putting their respective impedances at around 333kΩ and 1MΩ respectively. This caps the pull-up resistor at 33.3kΩ. Assuming around 25pF capacitance for the wires and input pins, the RC time constant will be 33kΩ × 25pF = 33e3 × 25e-12 = 825e-9 or 825ns, and the time to reach approx. 2.5V from 0V is 0.693 825ns = 572ns.</p>
<p>Selecting a resistor value that will give a faster rising edge will leave both ICs in their defined voltage ranges for more total time. A 10k resistor will reach 2.5V in 173ns and consume 500μA, and a 4.7k resistor will reach 2.5V in 81ns and consume 1mA. Lower resistance is a stronger pull-up, and causes more work to be done by a driver pulling the line low, but will reduce the work done to pull the line high.</p>
<p>The effect of resistance on rise time can be seen in this interactive chart. The chart shows a 500kHz signal with a pull-up resistor and 25pF capacitance. The fastest signal out of the Z180 is PHI at 1MHz, but most information bearing signals are 500kHz or slower.</p>
<canvas id="canvas" height="300" style="width:100%">
</canvas>
<p>There are two advantages to using a strong pull-up in my design. Assisting the Z180 to pull the data lines high will help the STM32 see a higher voltage level on its inputs, and configuring the STM32’s pins as open-drain outputs means they will never be driving a line high while the Z180 is driving it low. Unfortunately the reverse is not true, as the Z180 operates its data lines in push-pull mode, and will push high when it needs a high signal. If it pushes high when the STM32 is pulling low, both ICs will be at risk of damage. A ’245 transceiver is still the real answer to this problem.</p>
<p>The next step is to <a href="https://github.com/codebje/trs20-debug/">write the code</a> to implement chip configuration. My logic probe is a 24MHz device, so it can’t directly observe an 84MHz clock, but I can certainly drive a timer on the STM32 to produce what I think should be a 1MHz signal, and observe that. Then I can observe the μC reacting to the CPU’s control signals, and verify that an 84MHz μC can react fast enough to appear like RAM to a 1MHz CPU.</p>
<table style="width:86%;">
<caption>Project status update</caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 10%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Budget</th>
<th style="text-align: center;">CPU</th>
<th style="text-align: center;">Power</th>
<th style="text-align: center;">Keyboard</th>
<th style="text-align: center;">Video</th>
<th style="text-align: center;">Memory</th>
<th style="text-align: center;">Debug</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">$209.35 of $400</td>
<td style="text-align: center;">██──</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">██──</td>
</tr>
</tbody>
</table>]]></summary>
</entry>

</feed>
