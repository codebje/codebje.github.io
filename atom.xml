<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Typed Out</title>
    <link href="https://bje.id.au/blog/atom.xml" rel="self" />
    <link href="https://bje.id.au/blog" />
    <id>https://bje.id.au/blog/atom.xml</id>
    <author>
        <name>Byron Ellacott</name>
        <email></email>
    </author>
    <updated>2016-04-12T00:00:00Z</updated>
    <entry>
    <title>Z specification with Atom</title>
    <link href="https://bje.id.au/blog/posts/2016-04-12-atom-z-notation.html" />
    <id>https://bje.id.au/blog/posts/2016-04-12-atom-z-notation.html</id>
    <published>2016-04-12T00:00:00Z</published>
    <updated>2016-04-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Z notation is a formal specification language based on typed set theory and predicate logic. With this relatively simple mathematical grounding, Z is a useful pedagogic introduction to formal methods, and a useful formal method to apply when consumers of the output aren’t already trained for it.</p>
<p>However, the development of Z mostly involves tools which are rather dated. This article shows how to use Atom as a modern Z authoring studio, for small to medium specifications.</p>
<!--more-->
<div class="figure">
<img src="/images/linter-czt.png" />

</div>
<h2 id="essential-ingredients-latex">Essential ingredients: LaTeX</h2>
<p>Z notation is primarily authored in LaTeX, so the first step is writing effective LaTeX in Atom.</p>
<p>There are two approaches to this. One is to use Markdown for prose, and embed LaTeX directly, using [Pandoc] to produce PDF output. The downside of this is that Pandoc has no straightforward way to require a LaTeX package, and so including <code>oz.sty</code> or an equivalent means writing a custom preamble.</p>
<p>The second approach is the one I favour: write in LaTeX, use the <a href="https://atom.io/packages/latextools">latextools</a> package to build PDF output, and use the <a href="https://atom.io/packages/pdf-view">pdf-view</a> package to preview the PDF in a side-by-side panel.</p>
<h2 id="essential-ingredients-type-checking">Essential ingredients: type checking</h2>
<p>Z notation is machine checkable; the syntax and types can be verified automatically. However, <a href="https://en.wikipedia.org/wiki/Z_notation#Tools">the tools</a> to do this aren’t always kept up to date: the most current is <a href="https://sourceforge.net/projects/czt/">CZT</a>, the Community Z Tools, many others are either now broken links, or ten years out of date.</p>
<p>Using CZT isn’t a great experience, particularly for beginners. It offers an Eclipse-based IDE, with a project concept and file naming requirements in conflict with LaTeX naming requirements.</p>
<p>CZT also offers a command line typechecker, and so I created an Atom package, <a href="https://atom.io/packages/linter-czt">linter-czt</a>, to invoke that typechecker as a service provider for the <a href="https://atom.io/packages/linter">linter</a> package.</p>
<h2 id="usage-of-linter-czt">Usage of linter-czt</h2>
<p>Because it’s not a good idea to typecheck all LaTeX files, the CZT linter package introduces a new grammar for Z specifications, with scope <code>text.tex.latex.zed</code>. You can either select the <code>LaTeX Z</code> grammar from the grammar selection list (click on <code>LaTeX</code> in the status bar for a .tex file), follow the CZT approach and name your file with a <code>.zed</code> notation, or put <code>% !Z-notation</code> as the first line in your file.</p>
<p>Interpreting messages is not made any easier by the wrapper of a modern editor over a dated typechecker, so there’s no substitute for experience and understanding when it comes to writing meaningful Z.</p>
<p>The CZT distribution requires a Java 8 runtime, and a binary is included in the Atom package, with a patch to provide better location information applied.</p>
<p>Install all packages using either <code>apm</code> or the GUI settings install tab.</p>]]></summary>
</entry>
<entry>
    <title>Church encoding of a monoid</title>
    <link href="https://bje.id.au/blog/posts/2016-02-03-church-monoid.html" />
    <id>https://bje.id.au/blog/posts/2016-02-03-church-monoid.html</id>
    <published>2016-02-03T00:00:00Z</published>
    <updated>2016-02-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This article shows how a Church encoding can be derivied from an abstract data type, and intuitively but not rigorously demonstrates their equivalence.</p>
<!--more-->
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs, RankNTypes #-}</span></code></pre></div>
<p>We start out by defining a sum type for a monoid, with empty, embed, and append operations. To ease the transformation to Church encoding, we use <code>GADTs</code> to give explicit type signatures to the three constructors.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MonoidAST</span> a <span class="kw">where</span>
    <span class="dt">MEmbed</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">MonoidAST</span> a
    <span class="dt">MEmpty</span><span class="ot"> ::</span> <span class="dt">MonoidAST</span> a
    <span class="dt">MAppend</span><span class="ot"> ::</span> <span class="dt">MonoidAST</span> a <span class="ot">-&gt;</span> <span class="dt">MonoidAST</span> a <span class="ot">-&gt;</span> <span class="dt">MonoidAST</span> a</code></pre></div>
<p>A Church encoding represents the interpretation of a data structure; for each construction in the type, the Church encoding will require a function to interpret that construction. Thus, the Church encoding of the above structure can be obtained by replacing <code>MonoidAST a</code> with a type variable <span class="math inline"><em>r</em></span>, and describing a function which takes one function for each of the ADT constructors, finally returning an <span class="math inline"><em>r</em></span> :</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">CEMonoid</span> a <span class="fu">=</span> <span class="dt">CEMonoid</span> { mrun <span class="ot">::</span>
    forall r<span class="fu">.</span>        <span class="co">-- ≡ MonoidAST</span>
    (a <span class="ot">-&gt;</span> r)         <span class="co">-- ≡ MEmbed</span>
    <span class="ot">-&gt;</span> r             <span class="co">-- ≡ MEmpty</span>
    <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r) <span class="co">-- ≡ MAppend</span>
    <span class="ot">-&gt;</span> r }</code></pre></div>
<p>The <code>mrun</code> function will take a Church encoded monoid and the functions for each interpretation, and produce a monoidal value. If we consider <code>CEMonoid  Int</code>, we might wish to take the sum monoid (<code>mrun _ id 0 (+)</code>) or the product monoid (<code>mrun _ id 1 (*)</code>). Of special note here is that <span class="math inline"><em>a</em></span> and <span class="math inline"><em>r</em></span> are not necessarily the same type. We could execute a monoid which first transforms the integer value to something else, such as <code>mrun _ show &quot;&quot; (++)</code>.</p>
<p>Now we have a way to execute a monoid, but not to construct one. We provide functions for constructors, effectively taking the lower-case of the ADT’s constructors:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">membed&#39; a <span class="fu">=</span> <span class="dt">CEMonoid</span> <span class="fu">$</span> \ d _ _ <span class="ot">-&gt;</span> d a
mempty&#39; <span class="fu">=</span> <span class="dt">CEMonoid</span> <span class="fu">$</span> \ _ e _ <span class="ot">-&gt;</span> e
mappend&#39; a b <span class="fu">=</span> <span class="dt">CEMonoid</span> <span class="fu">$</span> \ d e f <span class="ot">-&gt;</span> f (mrun a d e f) (mrun b d e f)</code></pre></div>
<p>To demonstrate the equivalence of these constructors to the ADT’s value constructors, we can inspect the types of the functions and observe their similarity to the ADT:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">:</span>t mempty&#39;
<span class="fu">:</span>t membed&#39;
<span class="fu">:</span>t mappend&#39;</code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span class="get-type">mempty’ :: forall a. CEMonoid a</span></p>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span class="get-type">membed’ :: forall a. a -&gt; CEMonoid a</span></p>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span class="get-type">mappend’ :: forall a. CEMonoid a -&gt; CEMonoid a -&gt; CEMonoid a</span></p>
<p>Now we have all the elements in place to create and run a few monoids:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> mon <span class="fu">=</span> membed&#39; <span class="dv">5</span> <span class="ot">`mappend&#39;`</span> membed&#39; <span class="dv">3</span> <span class="kw">in</span>
    (mrun mon id <span class="dv">0</span> (<span class="fu">+</span>), mrun mon id <span class="dv">1</span> (<span class="fu">*</span>), mrun mon show <span class="st">&quot;&quot;</span> (<span class="fu">++</span>))</code></pre></div>
<pre><code>(8,15,&quot;53&quot;)</code></pre>
<p>When transforming to the Church encoding, at the type level we exchanged a definition of how to construct the type for a definition of how to interpret the type, and needed to provide functions to construct values in the type.</p>
<p>Conversely, the ADT describes at the type level how to construct values, and so needs a function to interpret those values:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runM <span class="dt">MEmpty</span> d e f <span class="fu">=</span> e
runM (<span class="dt">MEmbed</span> a) d e f <span class="fu">=</span> d a
runM (<span class="dt">MAppend</span> a b) d e f <span class="fu">=</span> f (runM a d e f) (runM b d e f)
<span class="fu">:</span>t runM
<span class="kw">let</span> mon <span class="fu">=</span> <span class="dt">MEmbed</span> <span class="dv">3</span> <span class="ot">`MAppend`</span> <span class="dt">MEmbed</span> <span class="dv">5</span> <span class="kw">in</span>
    (runM mon id <span class="dv">0</span> (<span class="fu">+</span>), runM mon id <span class="dv">1</span> (<span class="fu">*</span>), runM mon show <span class="st">&quot;&quot;</span> (<span class="fu">++</span>))</code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<p><span class="get-type">runM :: forall t t1. MonoidAST t -&gt; (t -&gt; t1) -&gt; t1 -&gt; (t1 -&gt; t1 -&gt; t1) -&gt; t1</span></p>
<pre><code>(8,15,&quot;35&quot;)</code></pre>]]></summary>
</entry>
<entry>
    <title>Developing Haskell using Atom</title>
    <link href="https://bje.id.au/blog/posts/2015-10-06-atom-haskell-dev.html" />
    <id>https://bje.id.au/blog/posts/2015-10-06-atom-haskell-dev.html</id>
    <published>2015-10-06T00:00:00Z</published>
    <updated>2015-10-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I’m picking up pace on Haskell development, with useless early versions of two packages now on github:</p>
<ul>
<li><a href="https://github.com/codebje/hakyll-site/">hakyll-site</a> - a bare-bones static site generator using Hakyll</li>
<li><a href="https://github.com/codebje/hask-mrt/">hask-mrt</a> - A parser for multi-router toolkit (MRT) export files</li>
</ul>
<p>This article outlines the tool chain I’m now using to do this development.</p>
<!--more-->
<h2 id="building-code-build-status">Building code <a href="https://travis-ci.org/codebje/hakyll-site"><img src="https://travis-ci.org/codebje/hakyll-site.svg?branch=master" alt="Build Status" /></a></h2>
<p>You can start to get a sense of how I do this by looking at those two repositories, where right off the bat you’ll see that I’m using <a href="https://www.stackage.org/">stack</a> for building, and where possible using <a href="https://travis-ci.org/codebje/">Travis CI</a> to test my builds.</p>
<p>Using stack frees me from the cabal sandbox concerns of whether the environment is applied appropriately, particularly for tools invoked other than directly from a shell prompt where I need to take care to ensure the path is right. It also gives me the stable set of packages, but this isn’t the full Hackage, and already I’ve noticed a few packages missing.</p>
<p>The blog itself is run using a trio of Docker containers: an nginx server to spit out the content, a builder image which pulls the latest git version, rebuilds the site executable as necessary, rebuilds the site itself, and copies it into place, on the third image, a data container. A git <code>post-receive</code> hook triggers the site rebuild container, so blog updates are always just one push away.</p>
<h2 id="writing-code">Writing code</h2>
<p>The major change for me, though, is that I’m using <a href="https://atom.io/">Atom</a> as my editor. I’ve been a <a href="http://www.vim.org/">vim</a> user for a few decades now, and while developing Haskell code in vim works well enough that I’m comfortable doing it via ssh, a number of Atom packages make development just that little bit nicer.</p>
<p>First, I often use some Markdown somewhere, and as <code>hakyll-site</code> might suggest, I also often wind up generating web sites. Atom has excellent support for HTML, CSS, less, JavaScript, and with the <a href="https://atom.io/packages/markdown-preview-plus">markdown-preview-plus</a> package, <a href="http://pandoc.org/">pandoc</a> Markdown support including LaTeX math.</p>
<p>Second, I rely heavily on <a href="https://hackage.haskell.org/package/hlint">hlint</a> to make me a better Haskell developer, and too much time developing Java has made me fond of autocompletion. To satisfy these needs, and the additional bonus of showing expression types on mouse hover (mitigating my most common use of the REPL: type composition), <a href="https://atom.io/packages/ide-haskell">ide-haskell</a> and its supporting packages really shines.</p>
<h2 id="making-it-work">Making it work</h2>
<p>To make ide-haskell work well, you need to install <a href="https://hackage.haskell.org/package/ghc-mod">ghc-mod</a>, and to work with stack that means version 5.4.0.0. I installed using the Mac homebrew version of Cabal, and given stack tends to prefer my system GHC over installing its own copy, this leaves me with an appropriately linked set of tools. I also installed <a href="https://hackage.haskell.org/package/stylish-haskell">stylish-haskell</a> to clean up my indenting and import lists via the IDE.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">stack</span> install ghc-mod
… <span class="kw">time</span> passes …
$ <span class="kw">stack</span> install stylish-haskell
… <span class="kw">much</span> more time passes …</code></pre></div>
<p>The full set of packages I’m currently making use of are:</p>
<dl>
<dt><a href="https://github.com/atom-haskell/autocomplete-haskell">autocomplete-haskell</a></dt>
<dd>Auto-completion tied to ghc-mod, so it actually knows my code
</dd>
<dt><a href="https://atom.io/packages/haskell-ghc-mod">haskell-ghc-mod</a></dt>
<dd>The autocompletion and ide backend provider. Configuration is mostly about managing paths correctly, now that both this package and ghc-mod fully support stack projects.
</dd>
<dt><a href="https://atom.io/packages/ide-haskell">ide-haskell</a></dt>
<dd>Errors, warnings, lints, hover-over type information, and code clean-up. The linting, in particular, is a real winner.
</dd>
<dt><a href="https://atom.io/packages/language-haskell">language-haskell</a></dt>
<dd>Syntax highlighting for Haskell and cabal files. A requirement for most of the other packages, too.
</dd>
<dt><a href="https://atom.io/packages/markdown-preview-plus">markdown-preview-plus</a></dt>
<dd>The thing that’s showing me my typos in real-time as I make them working on this article. Regrettably, there is no linter available for writing style.
</dd>
<dt><a href="https://atom.io/packages/hard-wrap">hard-wrap</a></dt>
<dd>On demand word-wrap for text or Markdown files. I’m not big on soft wrap, and hard-wrap does the job perfectly for me.
</dd>
</dl>
<p>Configuration overall is pretty straightforward. Atom ties into git flawlessly, to the point that issuing a <code>git mv</code> from a shell results in Atom’s editor pane reflecting the new file name, without losing my cursor position in any open files.</p>
<h2 id="being-productive">Being productive</h2>
<p>My <a href="https://github.com/codebje/vimrc/">vim setup</a> is reasonably complex, and my familiarity with the modal editing gives me plenty of technical efficiency for making changes. But when I write code, I don’t really need technical efficiency so much as I need cognitive efficiency - linting, type checking, quick access to docs, and of course REPL behaviours tend to weigh much more than how rapidly I can indent 20 lines. Atom gives me that cognitive assistance for a wide range of tasks, in one place.</p>
<p>My current project at work involves prototyping a user interface for a new system, and this means some Haskell to generate a static site, some Markdown for the straight up descriptive text, some HTML for the interface prototypes, and a lot of SVG for the shiny new bits. Atom’s made all of that pretty much seamless, with the one minor down side that so far I don’t have a great setup for previewing SVG as I edit it - which is potentially a new project to embark on.</p>
<p>Oh, <a href="https://atom.io/packages/svg-preview">never mind</a>. Time to install a new package.</p>]]></summary>
</entry>
<entry>
    <title>Geometric variables for visualisation</title>
    <link href="https://bje.id.au/blog/posts/2015-07-28-visualisation-geometric-variables.html" />
    <id>https://bje.id.au/blog/posts/2015-07-28-visualisation-geometric-variables.html</id>
    <published>2015-07-28T00:00:00Z</published>
    <updated>2015-07-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>How to map some data into a factor for visualisation is one of the key questions to answer when designing a new graphic. Sometimes, the variables available are fixed by some external consideration, such as a requirement for a particular type of chart, and sometimes the only constraints are those inherent in the message to convey and the data available.</p>
<!--more-->
<p>The table below from a <a href="http://www2.parc.com/istl/groups/uir/publications/items/UIR-1986-02-Mackinlay-TOG-Automating.pdf">paper</a> by J.D. Mackinlay in ’86 signals which variables are the most effective for which types of data. This isn’t anything new or groundbreaking, it’s just sufficiently important to aspects of my work that I wanted to reproduce it here.</p>
<table>
<thead>
<tr class="header">
<th align="right">Quantitative</th>
<th align="center">Ordinal</th>
<th align="left">Nominal</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">Position</td>
<td align="center">Position</td>
<td align="left">Position</td>
</tr>
<tr class="even">
<td align="right">Length</td>
<td align="center">Density</td>
<td align="left">Hue</td>
</tr>
<tr class="odd">
<td align="right">Angle</td>
<td align="center">Saturation</td>
<td align="left">Texture</td>
</tr>
<tr class="even">
<td align="right">Slope</td>
<td align="center">Hue</td>
<td align="left">Connection</td>
</tr>
<tr class="odd">
<td align="right">Area</td>
<td align="center">Texture</td>
<td align="left">Containment</td>
</tr>
<tr class="even">
<td align="right">Volume</td>
<td align="center">Connection</td>
<td align="left">Density</td>
</tr>
<tr class="odd">
<td align="right">Density</td>
<td align="center">Containment</td>
<td align="left">Saturation</td>
</tr>
<tr class="even">
<td align="right">Saturation</td>
<td align="center">Length</td>
<td align="left">Shape</td>
</tr>
<tr class="odd">
<td align="right">Hue</td>
<td align="center">Angle</td>
<td align="left">Length</td>
</tr>
<tr class="even">
<td align="right"><del>Texture</del></td>
<td align="center">Slope</td>
<td align="left">Angle</td>
</tr>
<tr class="odd">
<td align="right"><del>Connection</del></td>
<td align="center">Area</td>
<td align="left">Slope</td>
</tr>
<tr class="even">
<td align="right"><del>Containment</del></td>
<td align="center">Volume</td>
<td align="left">Area</td>
</tr>
<tr class="odd">
<td align="right"><del>Shape</del></td>
<td align="center"><del>Shape</del></td>
<td align="left">Volume</td>
</tr>
</tbody>
</table>
<p>Which of course also implies that position should map to your most important metric, or if possible, your two most important metrics. For a bar chart, the choice of X axis can sometimes fall between category or time, with the Y axis often representing amount. This choice can be informed by these relative strengths.</p>
<p>Hue decreases accessibility, though, so for nominal items I would still favour texture over hue when possible.</p>]]></summary>
</entry>
<entry>
    <title>Installing GHCJS on OS X</title>
    <link href="https://bje.id.au/blog/posts/2015-07-24-ghcjs-on-osx.html" />
    <id>https://bje.id.au/blog/posts/2015-07-24-ghcjs-on-osx.html</id>
    <published>2015-07-24T00:00:00Z</published>
    <updated>2015-07-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Assuming that you’ve installed GHC using Homebrew, the following steps will install GHCJS for you. These instructions perform a global install, but you can do a sandbox install by dropping the <code>--global</code> argument and ensuring your sandbox <code>bin</code> directory is higher on your <code class="sourceCode bash"><span class="ot">$PATH</span></code> than any other cabal binary paths. You can likewise do a user install without <code>--global</code> and ensuring your user cabal <code>bin</code> directory is higher on your <code class="sourceCode bash"><span class="ot">$PATH</span></code> than the homebrew cabal’s <code>bin</code> directory.</p>
<p>I went global.</p>
<!--more-->
<h3 id="upgrade-your-cabal-and-cabal-install-versions">Upgrade your Cabal and cabal-install versions</h3>
<p>GHCJS expects cabal-install 1.22.6.0, and Cabal 1.22.4.0. Homebrew’s most recent version of GHC will leave you with version 1.22.2.0 of both.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cabal</span> update
<span class="kw">cabal</span> install --global Cabal
<span class="kw">cabal</span> install --global cabal-install</code></pre></div>
<p>The order of these two installs is important; if you don’t build Cabal 1.22.4.0 before attempting to install cabal-install, you’ll just link against the old system version. You can verify that all is well with:</p>
<pre><code>$ cabal --version
cabal-install version 1.22.6.0
using version 1.22.4.0 of the Cabal library</code></pre>
<h3 id="enure-youre-happy-alex.">Enure you’re happy, Alex.</h3>
<p>GHCJS has two dependencies you’ll need to manually install: happy and alex.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cabal</span> install --global happy alex</code></pre></div>
<h3 id="install-ghcjs">Install GHCJS</h3>
<p>GHCJS has two git repositories, and no hackage packages. You must git clone and install.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">git</span> clone https://github.com/ghcjs/ghcjs-prim.git
<span class="kw">git</span> clone https://github.com/ghcjs/ghcjs.git
<span class="kw">cabal</span> install --global ./ghcjs-prim ./ghcjs</code></pre></div>
<p>Many dependencies. Perhaps use <code>-j</code> to speed it up.</p>
<h3 id="boot-ghcjs-libraries">Boot GHCJS libraries</h3>
<p>You’ll need a lot of base libraries rebuilt for GHCJS, and <code>ghcjs-boot</code> will do that for you. If you don’t already have <code>nodejs</code> installed, <code class="sourceCode bash"><span class="kw">brew</span> install</code> it before doing this.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">ghcjs-boot</span> --dev --ghcjs-boot-dev-branch ghc-7.10</code></pre></div>
<p>You need to build to the 7.10 development branch, assuming your local install of GHC is 7.10.1 or so. This installs into your user directory, and doesn’t appear to support global or sandbox installs.</p>
<p>But once it’s done, you can compile Haskell for the Web.</p>]]></summary>
</entry>
<entry>
    <title>Hakyll, Clay, and Docker</title>
    <link href="https://bje.id.au/blog/posts/2015-07-23-hakyll-clay-and-docker.html" />
    <id>https://bje.id.au/blog/posts/2015-07-23-hakyll-clay-and-docker.html</id>
    <published>2015-07-23T00:00:00Z</published>
    <updated>2015-07-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I wrote some words recently on monads in C. These are not particularly clever words, and implementing monads in C isn’t a particularly clever idea, but they’re my words, and it’s my idea, and I don’t wish it to vanish into the aether.</p>
<p>I considered, and rejected, using some service like medium.com. I don’t quite know why, maybe it wasn’t interesting enough as an approach. I tried, briefly, using Github Pages, then Jekyll stand-alone, but was dissatisfied with the Ruby underpinnings of Jekyll. Then, like a ray of sunshine on a cloudy day …</p>
<h2 id="hakyll">Hakyll</h2>
<p>… Hakyll appeared. Haskell-based static site generation. It’s like Jekyll, but without the irritating idiom of doing everything implicitly. And with support for literate haskell as a document input type, which I am sure may come in handy.</p>
<p>Perhaps more later on the specifics.</p>
<h2 id="clay">Clay</h2>
<p>Applying some style (I use the word only in its CSS technical sense) to the site took me to Clay. CSS authoring with strict typing, and a chance to experience a bit more of Haskell-backed EDSLs, their uses, and their drawbacks.</p>
<p>See the <a href="/lib/Blog/Css.html">syntax highlighting</a> library file, also a literate Haskell document rendered using Hakyll as a page, for how this looks.</p>
<h2 id="docker">Docker</h2>
<p>And of course, putting all this into Docker, continuing my recent decision to keep my hosting box more or less just a base OS install, obviating the need for OS-level backups. Any old base image will do, as long as it runs dockerd.</p>]]></summary>
</entry>

</feed>
