<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Typed Out</title>
    <link href="https://bje.id.au/blog/atom.xml" rel="self" />
    <link href="https://bje.id.au/blog" />
    <id>https://bje.id.au/blog/atom.xml</id>
    <author>
        <name>Byron Ellacott</name>
        <email></email>
    </author>
    <updated>2023-02-13T00:00:00Z</updated>
    <entry>
    <title>Advent of Z80 - Day 3, 2022</title>
    <link href="https://bje.id.au/blog/posts/2023-02-13-aoc-z80-day03.html" />
    <id>https://bje.id.au/blog/posts/2023-02-13-aoc-z80-day03.html</id>
    <published>2023-02-13T00:00:00Z</published>
    <updated>2023-02-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>It’s day three of the Advent of Z80. As with <a href="2023-01-15-aoc-z80-day01.html">day 1</a> and <a href="2023-01-29-aoc-z80-day02.html">day 2</a> the post will focus more on the Z80 assembly than on the puzzle, and is a “literate assembly” document that will execute in your browser.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>        <span class="bu">JP</span>      DAY03</span></code></pre></div>
<!--more-->
<p>Today’s puzzle introduces some additional solution elements to play with. There’s a bit of string processing to do: input strings need to be split into two equal halves and checked for characters in common.</p>
<p>Here’s the sample input, newline separated, and zero terminated.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">SAMPLE:</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>        db      <span class="st">&#39;vJrwpWtwJgWrhcsFMMfFFhFp\n&#39;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        db      <span class="st">&#39;jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL\n&#39;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        db      <span class="st">&#39;PmmdzqPrVvPwwTWBwg\n&#39;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        db      <span class="st">&#39;wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn\n&#39;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        db      <span class="st">&#39;ttgJtRGJQctTZtZT\n&#39;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        db      <span class="st">&#39;CrZsJsPPZsGzwwsLwLmpwMDw\n&#39;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        db      <span class="bn">0</span></span></code></pre></div>
<p>Star 1’s challenge is to find the character in common between the first and second halves of each string, convert them to a number, and sum the numbers.</p>
<p>I will start by pre-processing the input from characters to priority numbers, 1-52 for a-z and A-Z. This code will convert all other characters to zero, such that those newlines become NULs instead of being mixed up with converted ’m’s.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.block</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">; IN:   hl      the string to convert to priorities</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">; OUT:          all alphabetic characters at (hl) converted</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="fu">@PRIORITISE:</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">af</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">hl</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span>     <span class="at">hl</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="fu">LOOP:</span>   <span class="bu">inc</span>     <span class="at">hl</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">a</span>, (<span class="at">hl</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">; finish on NUL</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">or</span>      <span class="at">a</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      z, DONE</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">; test for A-Z</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">cp</span>      <span class="st">&#39;A&#39;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      <span class="at">c</span>, ZERO</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">cp</span>      <span class="st">&#39;Z&#39;</span>+<span class="bn">1</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      nc, LOWER</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">sub</span>     <span class="at">a</span>, <span class="st">&#39;A&#39;</span>-<span class="bn">27</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (<span class="at">hl</span>), <span class="at">a</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      LOOP</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">; test for a-z</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="fu">LOWER:</span>  <span class="bu">cp</span>      <span class="st">&#39;a&#39;</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      <span class="at">c</span>, ZERO</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">cp</span>      <span class="st">&#39;z&#39;</span>+<span class="bn">1</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      nc, ZERO</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        <span class="bu">sub</span>     <span class="at">a</span>, <span class="st">&#39;a&#39;</span>-<span class="bn">1</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (<span class="at">hl</span>), <span class="at">a</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      LOOP</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a><span class="fu">ZERO:</span>   <span class="bu">xor</span>     <span class="at">a</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (<span class="at">hl</span>), <span class="at">a</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      LOOP</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a><span class="fu">DONE:</span>   <span class="bu">pop</span>     <span class="at">hl</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">af</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ret</span></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.endblock</span></span></code></pre></div>
<p>Let’s see that in action:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode z80 run dump_SAMPLE_PRIORITISE"><code class="sourceCode z80"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">sp</span>, <span class="bn">$8000</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">hl</span>, SAMPLE</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    PRIORITISE</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">halt</span></span></code></pre></div>
<p>The next challenge is to find the midpoint of each string, which involves scanning along the string until a NUL is encountered.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.block</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">; IN:   hl      the data to find the midpoint of</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">; OUT:  a       the number of bytes in each half</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">; This function assumes an even number of bytes. If the terminating NUL</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">; falls on an odd byte location the function will overshoot the NUL.</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="fu">@MIDPOINT:</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">hl</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">bc</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">c</span>, <span class="bn">0</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="fu">LOOP:</span>   <span class="bu">ld</span>      <span class="at">a</span>, (<span class="at">hl</span>)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">or</span>      <span class="at">a</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      z, DONE</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">c</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">hl</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">hl</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      LOOP</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="fu">DONE:</span>   <span class="bu">ld</span>      <span class="at">a</span>, <span class="at">c</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">bc</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">hl</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ret</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.endblock</span></span></code></pre></div>
<p>And let’s see that in action on the sample input (converted):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode z80 run"><code class="sourceCode z80"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">sp</span>, <span class="bn">$8000</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">hl</span>, SAMPLE</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    PRIORITISE</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    MIDPOINT</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">halt</span></span></code></pre></div>
<p>If all went well <code class="sourceCode z80"><span class="at">A</span></code> will contain the midpoint of <code>vJrwpWtwJgWrhcsFMMfFFhFp</code>, which is 12 or <code class="sourceCode z80"><span class="bn">$0c</span></code>.</p>
<p>The next step is to find the letter in common. Rather than naively doing a quadratic comparison approach I will implement a basic bit-based set for numbers 0 to 52, taking up 7 bytes of space . I will need a function to OR a sequence of numbers into a set, for loading the first set of numbers, and a function to AND another sequence in, for mixing the second set of numbers in.</p>
<p>I will require that sets are aligned such that adding up to 6 to the set address doesn’t overflow 8 bits. Finding a bit address can be done cheaply by dividing by 8 then shifting <code class="sourceCode z80"><span class="bn">1000_0000b</span></code> right by the remainder. I shift right rather than left such that value <span class="math inline">\(n\)</span> sets bit <span class="math inline">\(n\)</span> in the set: if I shifted left everything would still work correctly but the bits within each byte would be reversed.</p>
<p>Here’s some space carved out for a set, aligned to not overflow in 8 bits:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.align</span> <span class="bn">256</span>, <span class="bn">0</span>, <span class="bn">7</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">SEEN:</span>   <span class="kw">defs</span>    <span class="bn">7</span></span></code></pre></div>
<p>There will be two pointers in action: one pointing to the 7 bytes of the set, and one pointing to the source number sequence. I can either use <code class="sourceCode z80"><span class="at">DE</span></code> or <code class="sourceCode z80"><span class="at">IX</span>/<span class="at">IY</span></code> for the second pointer. <code class="sourceCode z80"><span class="at">DE</span></code> is generally faster to work with, as swapping <code class="sourceCode z80"><span class="at">DE</span></code> and <code class="sourceCode z80"><span class="at">HL</span></code> with <code class="sourceCode z80"><span class="bu">EX</span> <span class="at">DE</span>, <span class="at">HL</span></code> takes 4 cycles, loading from <code class="sourceCode z80">(<span class="at">HL</span>)</code> takes 7 cycles, and loading from <code class="sourceCode z80">(<span class="at">IX</span>+<span class="bn">0</span>)</code> takes 19 cycles. A sequence of exchange, load from <code class="sourceCode z80">(<span class="at">HL</span>)</code>, and exchange is the same number of bytes as a single load from <code class="sourceCode z80">(<span class="at">IX</span>+<span class="bn">0</span>)</code> but one clock cycle faster, while an <code class="sourceCode z80"><span class="bu">INC</span> <span class="at">DE</span></code> is one byte and six clocks compared to <code class="sourceCode z80"><span class="bu">INC</span> <span class="at">IX</span></code> at two bytes and ten cycles.</p>
<p>Doing OR is straightforward - each value in the source data sets a bit. Loop over the source data, find the address of the bit to set, and set it.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.block</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">; IN:   hl      pointer to the source data to load</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">;       de      pointer to the 7-byte set to update</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">;       c       the number of values to load</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">; OUT:          7-byte set ORed with source data</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="fu">@SET_OR:</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">af</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">bc</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">de</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">hl</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">; for DJNZ...</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">b</span>, <span class="at">c</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="fu">LOOP:</span>   <span class="bu">push</span>    <span class="at">de</span>      <span class="co">; hang onto this</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">a</span>, (<span class="at">hl</span>)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">c</span>, <span class="at">a</span>    <span class="co">; keep it for later</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">; divide by 8</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">srl</span>     <span class="at">a</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">srl</span>     <span class="at">a</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">srl</span>     <span class="at">a</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">; add to set address</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">a</span>, <span class="at">e</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">e</span>, <span class="at">a</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">; get the low 8 bits</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">a</span>, <span class="bn">7</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>        <span class="bu">and</span>     <span class="at">a</span>, <span class="at">c</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">; compute $80 &lt;&lt; a</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">a</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">c</span>, <span class="at">a</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">a</span>, <span class="bn">$80</span></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a><span class="fu">SHIFT:</span>  <span class="bu">dec</span>     <span class="at">c</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      z, DONE</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>        <span class="bu">rrca</span></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      SHIFT</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>        <span class="co">; OR with (de)</span></span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a><span class="fu">DONE:</span>   <span class="bu">ex</span>      <span class="at">de</span>, <span class="at">hl</span></span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a>        <span class="bu">or</span>      <span class="at">a</span>, (<span class="at">hl</span>)</span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (<span class="at">hl</span>), <span class="at">a</span></span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ex</span>      <span class="at">de</span>, <span class="at">hl</span></span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">hl</span></span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">de</span></span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a>        <span class="bu">djnz</span>    LOOP</span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">hl</span></span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">de</span></span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">bc</span></span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">af</span></span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ret</span></span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.endblock</span></span></code></pre></div>
<p>Let’s see what happens when this is run on the first half of the first input string:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode z80 run dump_SEEN_7"><code class="sourceCode z80"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">sp</span>, <span class="bn">$8000</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">hl</span>, SAMPLE</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, SEEN</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    PRIORITISE</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    MIDPOINT</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">c</span>, <span class="at">a</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    SET<span class="bn">_</span>OR</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">halt</span></span></code></pre></div>
<p>The string <code>vJrwpWtwJgWr</code> translates to priorities <code>22, 36, 18, 23, 16, 49, 20, 23, 36, 7, 49, 18</code>, or uniquely <code>7, 16, 18, 20, 22, 23, 36, 49</code>. Writing 7 into the set will turn on bit 7 of byte 0. In byte 2, 16 will set bit 0, 18 will set bit 2, 20, 22, and 23 will set bits 4, 6, and 7. 36 sets bit 4 of byte 4. 49 sets bit 1 of byte 6. All up, these numbers turn into the bit set <code>01 00 ab 00 08 00 40</code>, which is what I get above.</p>
<div class="sourceCode">
<pre>
-abc defg  hijk lmno  pqrs tuvw  xyzA BCDE  FGHI JKLM  NOPQ RSTU  VWXY Z---
0000 0001  0000 0000  1010 1011  0000 0000  0000 1000  0000 0000  0100 0000
       01         00         ab         00         08         00         40
</pre>
</div>
<p>AND is a little less straightforward. Naively one might simply replace the ‘OR’ above with an ‘AND’, but the operation desired is the intersection of two sets. Doing one AND per input value will clear other bits in any updated byte and ignore all bits in any byte that isn’t updated. Preferable is to compute the set for the new input data then perform seven AND operations - this requires an extra seven bytes of space. In <a href="2023-01-15-aoc-z80-day01.html">day 1</a> I used the stack to carve out temporary space. I will do that again here, but as I do so I’ll ensure that the resulting space is aligned. I’ll do this a little bit wastefully by reserving 15 bytes instead of 7, and rounding the set address up to the nearest 8 byte boundary.</p>
<p>Doing arithmetic on <code class="sourceCode z80"><span class="at">SP</span></code> in the frame setup code requires the use of <code class="sourceCode z80"><span class="at">HL</span></code>. I don’t much want to clobber HL, but in my subroutine preamble I’ll preserve registers I modify during the subroutine anyway. The original value will be available at <code>(IX+2)</code>. Accessing word data via <code class="sourceCode z80"><span class="at">IX</span></code> is extremely slow at 38 cycles, so in I will avoid it as much as possible, but the value is there. However, the first thing I’m going to do is OR the incoming source data into the new buffer, so I will want the original <code class="sourceCode z80"><span class="at">HL</span></code> straight away, and to put the address of the new buffer into <code class="sourceCode z80"><span class="at">DE</span></code>, so I’ll swap <code class="sourceCode z80"><span class="at">DE</span></code> and <code class="sourceCode z80"><span class="at">HL</span></code> early on.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.block</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">; IN:   hl      pointer to the source data to load</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">;       de      pointer to the 7-byte set to update</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">;       b       the number of values to load</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">; OUT:          7-byte set ANDed with source data</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="fu">@SET_AND:</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">; save modified registers</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">af</span>      <span class="co">; ix+8,9</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">bc</span>      <span class="co">; ix+6,7</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">de</span>      <span class="co">; ix+4,5</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">hl</span>      <span class="co">; ix+2,3</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">; set up stack frame, 8-16 bytes of local storage</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">ix</span>      <span class="co">; ix+0,1</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">ix</span>, <span class="bn">0</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">ix</span>, <span class="at">sp</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ex</span>      <span class="at">de</span>, <span class="at">hl</span>  <span class="co">; I want the value in HL</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">hl</span>, -<span class="bn">16</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">hl</span>, <span class="at">sp</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">sp</span>, <span class="at">hl</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">; align HL to an 8-byte boundary</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">; HL = (HL + 8) &amp; ~7</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">bc</span>, <span class="bn">8</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">hl</span>, <span class="at">bc</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">a</span>, <span class="bn">1111_1000b</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>        <span class="bu">and</span>     <span class="at">l</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">l</span>, <span class="at">a</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">; initialise the new buffer</span></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">de</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">hl</span></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">d</span>, <span class="at">h</span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">e</span>, <span class="at">l</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">de</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>        <span class="bu">xor</span>     <span class="at">a</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (<span class="at">hl</span>), <span class="at">a</span></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">bc</span>, <span class="bn">6</span></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ldir</span></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>        <span class="co">; these POPs swap DE and HL</span></span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">de</span>      <span class="co">; = stack buffer</span></span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">hl</span>      <span class="co">; = source data</span></span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">; load the source data into the new buffer</span></span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">c</span>, (<span class="at">ix</span>+<span class="bn">6</span>)</span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    SET<span class="bn">_</span>OR</span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-49"><a href="#cb10-49" aria-hidden="true" tabindex="-1"></a>        <span class="co">; AND data between the buffers</span></span>
<span id="cb10-50"><a href="#cb10-50" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">l</span>, (<span class="at">ix</span>+<span class="bn">4</span>)</span>
<span id="cb10-51"><a href="#cb10-51" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">h</span>, (<span class="at">ix</span>+<span class="bn">5</span>)</span>
<span id="cb10-52"><a href="#cb10-52" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">bc</span>, <span class="bn">07ffh</span></span>
<span id="cb10-53"><a href="#cb10-53" aria-hidden="true" tabindex="-1"></a><span class="fu">LOOP:</span>   <span class="bu">ld</span>      <span class="at">a</span>, (<span class="at">hl</span>)</span>
<span id="cb10-54"><a href="#cb10-54" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ex</span>      <span class="at">de</span>, <span class="at">hl</span></span>
<span id="cb10-55"><a href="#cb10-55" aria-hidden="true" tabindex="-1"></a>        <span class="bu">and</span>     (<span class="at">hl</span>)</span>
<span id="cb10-56"><a href="#cb10-56" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ex</span>      <span class="at">de</span>, <span class="at">hl</span></span>
<span id="cb10-57"><a href="#cb10-57" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (<span class="at">hl</span>), <span class="at">a</span></span>
<span id="cb10-58"><a href="#cb10-58" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">hl</span></span>
<span id="cb10-59"><a href="#cb10-59" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">de</span></span>
<span id="cb10-60"><a href="#cb10-60" aria-hidden="true" tabindex="-1"></a>        <span class="bu">djnz</span>    LOOP</span>
<span id="cb10-61"><a href="#cb10-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-62"><a href="#cb10-62" aria-hidden="true" tabindex="-1"></a>        <span class="co">; restore stack frame</span></span>
<span id="cb10-63"><a href="#cb10-63" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">hl</span>, <span class="bn">16</span></span>
<span id="cb10-64"><a href="#cb10-64" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">hl</span>, <span class="at">sp</span></span>
<span id="cb10-65"><a href="#cb10-65" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">sp</span>, <span class="at">hl</span></span>
<span id="cb10-66"><a href="#cb10-66" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">ix</span></span>
<span id="cb10-67"><a href="#cb10-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-68"><a href="#cb10-68" aria-hidden="true" tabindex="-1"></a>        <span class="co">; restore modified registers</span></span>
<span id="cb10-69"><a href="#cb10-69" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">hl</span></span>
<span id="cb10-70"><a href="#cb10-70" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">de</span></span>
<span id="cb10-71"><a href="#cb10-71" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">bc</span></span>
<span id="cb10-72"><a href="#cb10-72" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">af</span></span>
<span id="cb10-73"><a href="#cb10-73" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ret</span></span>
<span id="cb10-74"><a href="#cb10-74" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.endblock</span></span></code></pre></div>
<p>Adding in the <code>AND</code> call should result in a single bit being set:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode z80 run dump_SEEN_7"><code class="sourceCode z80"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">sp</span>, <span class="bn">$8000</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">hl</span>, SAMPLE</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, SEEN</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    PRIORITISE</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    MIDPOINT</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">c</span>, <span class="at">a</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    SET<span class="bn">_</span>OR</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">l</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">l</span>, <span class="at">a</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    SET<span class="bn">_</span>AND</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">halt</span></span></code></pre></div>
<div class="sourceCode">
<pre>
X = vJrwpWtwJgWr && hcsFMMfFFhFp
    -abc defg  hijk lmno  pqrs tuvw  xyzA BCDE  FGHI JKLM  NOPQ RSTU  VWXY Z---
    0000 0001  0000 0000  1010 1011  0000 0000  0000 1000  0000 0000  0100 0000
  & 0001 0010  1000 0000  1001 0000  0000 0000  1000 0001  0000 0000  0000 0000
  = 0000 0000  0000 0000  1000 0000  0000 0000  0000 0000  0000 0000  0000 0000
  =    00         00         80         00         00         00         00
</pre>
</div>
<p>The <code>SET_AND</code> implementation takes around 3,500 clock cycles to execute, around 2ms on a TRS-80 Model 1.</p>
<p>The last function I’ll need will find the first one bit in a set, so I can find the common bit. After finding a non-zero byte I will <code class="sourceCode z80"><span class="bu">rlca</span></code> until the carry flag is set. This instruction rotates the bits in <code class="sourceCode z80"><span class="at">A</span></code> left, with bit 7 going into the carry flag and bit 0. If the carry flag is set on the first rotate it means bit 7 was set. Because <code class="sourceCode z80"><span class="at">A</span></code> is non-zero I know at least one bit is set and I don’t need any other loop guard: just keep rotating until carry is set.</p>
<p>As a small help to myself this function will also unset the discovered bit; if all is going well this will be the only set bit and clearing it will leave the buffer ready to use again for the next pair of input strings.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.block</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">; IN:   de      the set to read</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">; OUT:  a       the first set bit, or 0ffh if none are set</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="fu">@FIRST:</span> <span class="bu">push</span>    <span class="at">bc</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">de</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">; work out of (hl)</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ex</span>      <span class="at">de</span>, <span class="at">hl</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">; for each byte ...</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">bc</span>, <span class="bn">700h</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="fu">BYTE:</span>   <span class="bu">ld</span>      <span class="at">a</span>, (<span class="at">hl</span>)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">; skip zeros</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">or</span>      <span class="at">a</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      nz, FOUND</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">; move along 8 bits</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">a</span>, <span class="bn">8</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">c</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">c</span>, <span class="at">a</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">hl</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">djnz</span>    BYTE</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">; didn&#39;t find anything...</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">c</span>, <span class="bn">0ffh</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a><span class="fu">DONE:</span>   <span class="bu">ld</span>      <span class="at">a</span>, <span class="at">c</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">; switch these back now</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ex</span>      <span class="at">de</span>, <span class="at">hl</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">de</span></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">bc</span></span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ret</span></span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">; found a non-zero byte, clear it and find the first bit</span></span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a><span class="fu">FOUND:</span>  <span class="bu">ld</span>      <span class="at">b</span>, <span class="bn">0</span></span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (<span class="at">hl</span>), <span class="at">b</span></span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">c</span></span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>        <span class="bu">rlca</span></span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      nc, FOUND</span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">; overshot it by one...</span></span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span>     <span class="at">c</span></span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      DONE</span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.endblock</span></span></code></pre></div>
<p>Let’s see if this can successfully find ‘p’ in the sample data:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode z80 run"><code class="sourceCode z80"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.block</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">sp</span>, <span class="bn">$8000</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, ONEBIT</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    FIRST</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">halt</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.align</span> <span class="bn">256</span>, <span class="bn">0</span>, <span class="bn">7</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="fu">ONEBIT:</span> db      <span class="bn">00h</span>, <span class="bn">00h</span>, <span class="bn">80h</span>, <span class="bn">00h</span>, <span class="bn">00h</span>, <span class="bn">00h</span>, <span class="bn">00h</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.endblock</span></span></code></pre></div>
<p>This test is succcessful if <code class="sourceCode z80"><span class="at">A</span></code> is the priority of ‘p’, which is 16 or <code class="sourceCode z80"><span class="bn">$10</span></code>.</p>
<p>It would also be possible to merge <code>SET_AND</code> and <code>FIRST</code> into a single routine that finds an arbitrary bit in common with an input string and a bit set. This would likely shave many cycles off the star 1 test, but at the cost of readability. The Z80 comes from an era where machines had extremely limited resources, and good programmers would always be looking for ways to save a few bytes or cycles in their programs. As this series progresses I will be more aggressively pursuing optimisations, not because there’s any real need for the performance gains here, but to build up more understanding of the ways in which Z80 assembly can be wrangled. Here in day 3, I’ll stick with the more readable version.</p>
<p>Once again, the final output will be a 16-bit number that needs to be printed. Rather than duplicating the same functions over and over again I will refer to external definitions and include them.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>        .<span class="dt">include</span>        <span class="st">&quot;print16.z80&quot;</span></span></code></pre></div>
<p>I now have all the pieces in place to solve star 1: loop over the input, splitting each string into two, putting the two halves into sets, finding the common entry, summing them up, and printing the answer.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode z80 run"><code class="sourceCode z80"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.block</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="fu">@STAR1:</span> <span class="bu">ld</span>      <span class="at">sp</span>, <span class="bn">$8000</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">hl</span>, SAMPLE</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, SEEN</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">; convert to priority values</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    PRIORITISE</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">; loop over each input</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="fu">LOOP:</span>   <span class="bu">ld</span>      <span class="at">a</span>, (<span class="at">hl</span>)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">or</span>      <span class="at">a</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      z, DONE</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">; find the midpoint</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    MIDPOINT</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">b</span>, <span class="bn">0</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">c</span>, <span class="at">a</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">; load it in to SEEN</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    SET<span class="bn">_</span>OR</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">; increment HL past it</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">hl</span>, <span class="at">bc</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">; combine it in SEEN</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    SET<span class="bn">_</span>AND</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">; find the common value and reset SEEN</span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    FIRST</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">; running sum</span></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">hl</span></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">bc</span></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">c</span>, <span class="at">a</span>    <span class="co">; b = 0</span></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">hl</span>, (SUM)</span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">hl</span>, <span class="at">bc</span></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (SUM), <span class="at">hl</span></span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">bc</span></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">hl</span></span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a>        <span class="co">; move to next input</span></span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">hl</span>, <span class="at">bc</span></span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">hl</span> <span class="co">; NUL terminator</span></span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      LOOP</span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-46"><a href="#cb15-46" aria-hidden="true" tabindex="-1"></a><span class="fu">DONE:</span>   <span class="bu">ld</span>      <span class="at">de</span>, (SUM)</span>
<span id="cb15-47"><a href="#cb15-47" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    PRINT16</span>
<span id="cb15-48"><a href="#cb15-48" aria-hidden="true" tabindex="-1"></a>        <span class="bu">halt</span></span>
<span id="cb15-49"><a href="#cb15-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-50"><a href="#cb15-50" aria-hidden="true" tabindex="-1"></a>        <span class="co">; running total of priorities in common</span></span>
<span id="cb15-51"><a href="#cb15-51" aria-hidden="true" tabindex="-1"></a><span class="fu">SUM:</span>    dw      <span class="bn">0</span></span>
<span id="cb15-52"><a href="#cb15-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-53"><a href="#cb15-53" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.endblock</span></span></code></pre></div>
<h2 id="star-2">Star 2</h2>
<p>Now, the puzzle changes to finding a common letter across a group of three inputs. I can re-use my bit set subroutines, but I need to find the length of each full string instead of just the mid point. Since that’s the mid point times two I can also just re-use that subroutine as well. I will assume that the input is well-formed, again: there will always be a multiple of three lines.</p>
<p>The general flow is the same as for Star 1 - convert to priorities, loop while the input doesn’t start with NUL, load one value in with <code>SET_OR</code>, load other value(s) in with <code>SET_AND</code>, find the <code>FIRST</code> bit set, and sum it up.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode z80 run"><code class="sourceCode z80"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.block</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">@STAR2:</span> <span class="bu">ld</span>      <span class="at">sp</span>, <span class="bn">$8000</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">hl</span>, SAMPLE</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, SEEN</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">; convert to priority values</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    PRIORITISE</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">; loop over each input</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="fu">LOOP:</span>   <span class="bu">ld</span>      <span class="at">a</span>, (<span class="at">hl</span>)</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">or</span>      <span class="at">a</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      z, DONE</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">; find the midpoint</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    MIDPOINT</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">rla</span>             <span class="co">; double it</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">b</span>, <span class="bn">0</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">c</span>, <span class="at">a</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">; load in the first input</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    SET<span class="bn">_</span>OR</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">; increment HL past it</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">hl</span>, <span class="at">bc</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">hl</span></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">; second input - find midpoint</span></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    MIDPOINT</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>        <span class="bu">rla</span>             <span class="co">; double it</span></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">b</span>, <span class="bn">0</span></span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">c</span>, <span class="at">a</span></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">; mix it with the first input</span></span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    SET<span class="bn">_</span>AND</span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">; increment HL past it</span></span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">hl</span>, <span class="at">bc</span></span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">hl</span></span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a>        <span class="co">; third input - find midpoint</span></span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    MIDPOINT</span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a>        <span class="bu">rla</span>             <span class="co">; double it</span></span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">b</span>, <span class="bn">0</span></span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">c</span>, <span class="at">a</span></span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a>        <span class="co">; mix it with the first two inputs</span></span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    SET<span class="bn">_</span>AND</span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a>        <span class="co">; increment HL past it</span></span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">hl</span>, <span class="at">bc</span></span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">hl</span></span>
<span id="cb16-52"><a href="#cb16-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-53"><a href="#cb16-53" aria-hidden="true" tabindex="-1"></a>        <span class="co">; find the common value and reset SEEN</span></span>
<span id="cb16-54"><a href="#cb16-54" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    FIRST</span>
<span id="cb16-55"><a href="#cb16-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-56"><a href="#cb16-56" aria-hidden="true" tabindex="-1"></a>        <span class="co">; running sum</span></span>
<span id="cb16-57"><a href="#cb16-57" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">hl</span></span>
<span id="cb16-58"><a href="#cb16-58" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">bc</span></span>
<span id="cb16-59"><a href="#cb16-59" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">c</span>, <span class="at">a</span>    <span class="co">; b = 0</span></span>
<span id="cb16-60"><a href="#cb16-60" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">hl</span>, (SUM)</span>
<span id="cb16-61"><a href="#cb16-61" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">hl</span>, <span class="at">bc</span></span>
<span id="cb16-62"><a href="#cb16-62" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (SUM), <span class="at">hl</span></span>
<span id="cb16-63"><a href="#cb16-63" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">bc</span></span>
<span id="cb16-64"><a href="#cb16-64" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">hl</span></span>
<span id="cb16-65"><a href="#cb16-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-66"><a href="#cb16-66" aria-hidden="true" tabindex="-1"></a>        <span class="co">; go back for more input</span></span>
<span id="cb16-67"><a href="#cb16-67" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      LOOP</span>
<span id="cb16-68"><a href="#cb16-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-69"><a href="#cb16-69" aria-hidden="true" tabindex="-1"></a><span class="fu">DONE:</span>   <span class="bu">ld</span>      <span class="at">de</span>, (SUM)</span>
<span id="cb16-70"><a href="#cb16-70" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    PRINT16</span>
<span id="cb16-71"><a href="#cb16-71" aria-hidden="true" tabindex="-1"></a>        <span class="bu">halt</span></span>
<span id="cb16-72"><a href="#cb16-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-73"><a href="#cb16-73" aria-hidden="true" tabindex="-1"></a>        <span class="co">; running total of priorities in common</span></span>
<span id="cb16-74"><a href="#cb16-74" aria-hidden="true" tabindex="-1"></a><span class="fu">SUM:</span>    dw      <span class="bn">0</span></span>
<span id="cb16-75"><a href="#cb16-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-76"><a href="#cb16-76" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.endblock</span></span></code></pre></div>
<p>Today’s puzzle was again quite a simple one, and the translation to Z80 assembly was correspondingly simple. The second star took around 60,000 cycles to compute on the small sample input alone, clocking in at around 33ms on my imaginary TRS-80 Model 1, or 1.2ms on my real eZ80 board.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">DAY03:</span>  <span class="bu">call</span>    STAR1</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    STAR2</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">halt</span></span></code></pre></div>]]></summary>
</entry>
<entry>
    <title>Advent of Z80 - Day 2, 2022</title>
    <link href="https://bje.id.au/blog/posts/2023-01-29-aoc-z80-day02.html" />
    <id>https://bje.id.au/blog/posts/2023-01-29-aoc-z80-day02.html</id>
    <published>2023-01-29T00:00:00Z</published>
    <updated>2023-01-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>It’s day two of the Advent of Z80. As with <a href="2023-01-15-aoc-z80-day01.html">day 1</a> the post will focus more on the Z80 assembly than on the puzzle, and is a “literate assembly” document that will execute in your browser.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>        <span class="bu">JP</span>      DAY02</span></code></pre></div>
<!--more-->
<p>The second puzzle is based on the venerable rock, paper, scissors game. The puzzle input is a turn by turn list of the gameplay, with the opponent’s move given as one of A, B, or C and the player’s move given as X, Y, or Z. The required output is a score based on the player’s chosen move plus and whether the game was a win, draw, or loss.</p>
<p>For every round I am told what move I will make and what move my opponent makes, and I simply need to translate that into two score values and add that in to a running tally. The first score value is 1, 2, or 3 for rock, paper, or scissors. The second score value will be a lookup into a 3x3 matrix based on the two moves. If I assign 0 to rock, 1 to paper, and 2 to scissors the first score is the move plus one and the second score is a lookup.</p>
<p>When using the lookup table I’ll load the address of the table into <code class="sourceCode z80"><span class="at">HL</span></code> then add the player’s move three times and the opponent’s move once. The maximum total offset is 8, and I’d really like to be able to use 8-bit additions without worrying about carry into <code class="sourceCode z80"><span class="at">H</span></code>, so I will align the lookup table’s address in memory such that the address plus 8 never overflows.</p>
<p>Most assemblers have a <code class="sourceCode z80"><span class="dt">.align</span></code> directive for this purpose. The directive inserts padding into the program until the address modulo the alignment equals zero. For this to prevent overflow when adding the alignment needs to be a power of two - the smallest alignment that will ensure safety is 16. Because I only have 9 bytes of data this means up to 7 bytes of padding will be added even if there’s no chance of overflow.</p>
<p>Some assemblers - including the one used here - allow extra arguments to <code class="sourceCode z80"><span class="dt">.align</span></code> to specify what fill value will be inserted into the output for the padding, and to specify the maximum offset that will be allowed. I can specify that I want my table aligned to 256 bytes, but not to add any padding if the padding to add is greater than 9 bytes - in most cases this will simply leave the table where it is.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.block</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.align</span>  <span class="bn">256</span>, <span class="bn">0</span>, <span class="bn">9</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">WINLOSS:</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">; oppt: R, P, S</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defb</span>    <span class="bn">3</span>, <span class="bn">0</span>, <span class="bn">6</span> <span class="co">; me: R</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defb</span>    <span class="bn">6</span>, <span class="bn">3</span>, <span class="bn">0</span> <span class="co">; me: P</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defb</span>    <span class="bn">0</span>, <span class="bn">6</span>, <span class="bn">3</span> <span class="co">; me: S</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">; IN:   B       opponent&#39;s move (0: Rock, 1: Paper, 2: Scissors)</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">;       C       player&#39;s move (0: Rock, 1: Paper, 2: Scissors)</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co">; OUT:  A       score</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="fu">@SCORE:</span> <span class="bu">push</span>    <span class="at">hl</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">a</span>, WINLOSS &amp; <span class="bn">0ffh</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">a</span>, <span class="at">c</span>    <span class="co">; my move * 1</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">a</span>, <span class="at">c</span>    <span class="co">; my move * 2</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">a</span>, <span class="at">c</span>    <span class="co">; my move * 3</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">a</span>, <span class="at">b</span>    <span class="co">; + your move</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">l</span>, <span class="at">a</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">h</span>, WINLOSS &gt;&gt; <span class="bn">8</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">; score = my move (rock = 1, paper = 2, scissors = 3) ...</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">a</span>, <span class="at">c</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">a</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">; plus win/loss score</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">a</span>, (<span class="at">hl</span>)</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">hl</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ret</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.endblock</span></span></code></pre></div>
<p>Now that I can score a round all I need to do is score all the rounds and sum the scores up.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.block</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">@DAY02:</span> <span class="bu">ld</span>      <span class="at">hl</span>, STRATEGY</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, <span class="bn">0</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="fu">ROUNDS:</span> <span class="bu">ld</span>      <span class="at">a</span>, (<span class="at">hl</span>) <span class="co">; load opponent&#39;s move</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">sub</span>     <span class="at">a</span>, <span class="st">&#39;A&#39;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      <span class="at">c</span>, DONE <span class="co">; finish when &lt; &#39;A&#39;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">b</span>, <span class="at">a</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">hl</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">a</span>, (<span class="at">hl</span>) <span class="co">; load my move</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">hl</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">sub</span>     <span class="at">a</span>, <span class="st">&#39;X&#39;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">c</span>, <span class="at">a</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    SCORE</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">a</span>, <span class="at">e</span>    <span class="co">; add A into DE</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">e</span>, <span class="at">a</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">a</span>, <span class="bn">0</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span>     <span class="at">a</span>, <span class="at">d</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">d</span>, <span class="at">a</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      ROUNDS</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="fu">DONE:</span>   <span class="bu">call</span>    PRINT16</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">halt</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="fu">STRATEGY:</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        db      <span class="st">&#39;A&#39;</span>, <span class="st">&#39;Y&#39;</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        db      <span class="st">&#39;B&#39;</span>, <span class="st">&#39;X&#39;</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>        db      <span class="st">&#39;C&#39;</span>, <span class="st">&#39;Z&#39;</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>        db      <span class="bn">0</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.endblock</span></span></code></pre></div>
<p>Day 1 required printing a 32-bit number. Day 2’s results fits into a 16-bit number on real input - and an 8-bit number for the sample input - which is simpler to print:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.block</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">; IN    DE      a 16-bit unsigned number to print</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">; OUT   A       clobbered</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="fu">@PRINT16:</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">bc</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">de</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">hl</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ex</span>      <span class="at">de</span>, <span class="at">hl</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">c</span>, <span class="st">&#39;0&#39;</span>  <span class="co">; the &#39;non-zero&#39; flag</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, -<span class="bn">10_000</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    DIGIT</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, -<span class="bn">1_000</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    DIGIT</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, -<span class="bn">100</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    DIGIT</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, -<span class="bn">10</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    DIGIT</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">; force last digit to print</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">c</span>, <span class="bn">1</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, -<span class="bn">1</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    DIGIT</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">hl</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">de</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">bc</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ret</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a><span class="fu">DIGIT:</span>  <span class="bu">ld</span>      <span class="at">a</span>, <span class="st">&#39;0&#39;</span>-<span class="bn">1</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a><span class="fu">DLOOP:</span>  <span class="bu">inc</span>     <span class="at">a</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">hl</span>, <span class="at">de</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      <span class="at">c</span>, DLOOP</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>        <span class="bu">sbc</span>     <span class="at">hl</span>, <span class="at">de</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>        <span class="bu">cp</span>      <span class="at">c</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      z, NOPRINT</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>        <span class="bu">out</span>     (<span class="bn">1</span>), <span class="at">a</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">c</span>, <span class="bn">1</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a><span class="fu">NOPRINT:</span></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ret</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.endblock</span></span></code></pre></div>
<p>Let’s fire it up and see what it does.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode z80 run"><code class="sourceCode z80"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jp</span>      DAY02</span></code></pre></div>
<p>Huzzah and hurrah, 15 is printed.</p>
<h2 id="star-2">Star 2</h2>
<p>For star 2, the meaning of the second column has changed: an ‘X’ means to lose, a ‘Y’ to draw, and a ‘Z’ to win. The score is still calculated the same way, so all I need is an extra step to convert the ‘X’, ‘Y’, and ‘Z’ into the appropriate move, then just repeat the first star’s computations.</p>
<p>I can use the same table-based approach as for scoring to translate to a move: the move to be made depends on both the opponent’s move and the desired outcome. Once again ensuring the table is aligned will prevent overflow and allow 8-bit arithmetic to be used.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.block</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.align</span>  <span class="bn">256</span>, <span class="bn">0</span>, <span class="bn">9</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="fu">MOVES:</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">; oppt: R, P, S</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defb</span>    <span class="bn">2</span>, <span class="bn">0</span>, <span class="bn">1</span> <span class="co">; lose</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defb</span>    <span class="bn">0</span>, <span class="bn">1</span>, <span class="bn">2</span> <span class="co">; draw</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defb</span>    <span class="bn">1</span>, <span class="bn">2</span>, <span class="bn">0</span> <span class="co">; win</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">; IN:   B       opponent&#39;s move (0: Rock, 1: Paper, 2: Scissors)</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">;       C       win/loss/draw goal (0: Loss, 1: Draw, 2: Win)</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co">; OUT:  A       score</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="fu">@SCORE2:</span><span class="bu">push</span>    <span class="at">hl</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">bc</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">a</span>, MOVES &amp; <span class="bn">0ffh</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">a</span>, <span class="at">c</span>    <span class="co">; goal * 1</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">a</span>, <span class="at">c</span>    <span class="co">; goal * 2</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">a</span>, <span class="at">c</span>    <span class="co">; goal * 3</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">a</span>, <span class="at">b</span>    <span class="co">; + opponent move</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">l</span>, <span class="at">a</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">h</span>, MOVES &gt;&gt; <span class="bn">8</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">; load the move to make</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">c</span>, (<span class="at">hl</span>)</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">; score it</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    SCORE</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">bc</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">hl</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ret</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.endblock</span></span></code></pre></div>
<p>The remainder of the star 2 implementation is exactly the same as the star 1 implementation save for calling <code class="sourceCode z80">SCORE2</code> instead of <code class="sourceCode z80">SCORE1</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.block</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">@STAR2:</span> <span class="bu">ld</span>      <span class="at">hl</span>, STRATEGY</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, <span class="bn">0</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="fu">ROUNDS:</span> <span class="bu">ld</span>      <span class="at">a</span>, (<span class="at">hl</span>) <span class="co">; load opponent&#39;s move</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">sub</span>     <span class="at">a</span>, <span class="st">&#39;A&#39;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      <span class="at">c</span>, DONE <span class="co">; finish when &lt; &#39;A&#39;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">b</span>, <span class="at">a</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">hl</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">a</span>, (<span class="at">hl</span>) <span class="co">; load my move</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">hl</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">sub</span>     <span class="at">a</span>, <span class="st">&#39;X&#39;</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">c</span>, <span class="at">a</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    SCORE2</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">a</span>, <span class="at">e</span>    <span class="co">; add A into DE</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">e</span>, <span class="at">a</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">a</span>, <span class="bn">0</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span>     <span class="at">a</span>, <span class="at">d</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">d</span>, <span class="at">a</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      ROUNDS</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="fu">DONE:</span>   <span class="bu">call</span>    PRINT16</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">halt</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a><span class="fu">STRATEGY:</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>        db      <span class="st">&#39;A&#39;</span>, <span class="st">&#39;Y&#39;</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>        db      <span class="st">&#39;B&#39;</span>, <span class="st">&#39;X&#39;</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>        db      <span class="st">&#39;C&#39;</span>, <span class="st">&#39;Z&#39;</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>        db      <span class="bn">0</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>        <span class="dt">.endblock</span></span></code></pre></div>
<p>And executing this should print 12.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode z80 run"><code class="sourceCode z80"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jp</span>      STAR2</span></code></pre></div>]]></summary>
</entry>
<entry>
    <title>Advent of Z80 - Day 1, 2022</title>
    <link href="https://bje.id.au/blog/posts/2023-01-15-aoc-z80-day01.html" />
    <id>https://bje.id.au/blog/posts/2023-01-15-aoc-z80-day01.html</id>
    <published>2023-01-15T00:00:00Z</published>
    <updated>2023-01-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This post is the first in a series of articles implementing solutions for the 2022 Advent of Code in Z80 assembly. The series aims to show some examples of programming in Z80 assembly and help newcomers to assembly language begin to think about programs from the assembly perspective, and will focus less on finding clever AoC solutions and more on producing understandable assembly code.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>        <span class="bu">JP</span>      DAY01</span></code></pre></div>
<!--more-->
<p>This post is a “literate assembly” document. The code fragments on the page are assembled and executed in your browser. To the right of each statement you can see the bytes that the statement assembled into.</p>
<p>The first puzzle in the AoC 2022 series provides you with a nested list of numbers and requires you to sum the nested lists and find the maximum. In a high level language this might look something like <code class="sourceCode haskell"><span class="fu">maximum</span> (<span class="fu">map</span> <span class="fu">sum</span> input)</code>, which the compiler will helpfully translate into reasonably efficient code.</p>
<p>What I would like to do is iterate over the input summing numbers as I encounter them and keeping track of the current maximum sum at the end of each nested list. In principle this is not complicated, as even an ancient processor like the Z80 can add and compare. In practice there’s a small complication: the problem’s number space is greater than what a 16-bit number can store.</p>
<p>A processor like the Z80 adds up much the same way I learned to in my early schooling years: add up the 1s column, noting any carry, add up the 10s column including the carry from the 1s column, and so on until I’d added up all my columns. The Z80 does the same thing bit by bit: the least significant bit of both inputs is summed and the carry is pushed along to the next bit, and so on. The Z80 has a <a href="http://www.righto.com/2013/09/the-z-80-has-4-bit-alu-heres-how-it.html">4-bit ALU</a> and does half an addition in one cycle then the other half in the next. For a 16-bit add the Z80 does the low byte then the high byte.</p>
<p>The carry result is exposed to applications through the carry flag: if the most significant bits of the addends plus the carry from the previous bit results in another carry, the carry flag is set. To make chaining additions easier there are also <code class="sourceCode z80"><span class="bu">ADC</span></code> (add-with-carry) instructions that use the value in the carry flag as the carry-in for the least significant bit addition. Adding two 32-bit numbers is more or less as simple as adding two 16-bit numbers, then adding two more 16-bit numbers with carry.</p>
<p>Another wrinkle will emerge about now, however - the Z80 doesn’t have a large number of registers. The other addend for <code class="sourceCode z80"><span class="bu">ADC</span> <span class="at">HL</span>, …</code> must be one of <code class="sourceCode z80"><span class="at">BC</span></code>, <code class="sourceCode z80"><span class="at">DE</span></code>, <code class="sourceCode z80"><span class="at">HL</span></code>, or <code class="sourceCode z80"><span class="at">SP</span></code>. There’s no point adding <code class="sourceCode z80"><span class="at">HL</span></code> to itself, and the stack pointer (<code class="sourceCode z80"><span class="at">SP</span></code>) is needed to hold the current stack value, which only leaves 48 bits of register for 64 bits of value. There are also the <code class="sourceCode z80"><span class="at">IX</span></code> and <code class="sourceCode z80"><span class="at">IY</span></code> index registers that can stand in for <code class="sourceCode z80"><span class="at">HL</span></code> for many, but not all, operations. Importantly they can be used for <code class="sourceCode z80"><span class="bu">ADD</span></code> but not for <code class="sourceCode z80"><span class="bu">ADC</span></code>.</p>
<p>I will choose to store the addends for a 32-bit addition in <code class="sourceCode z80"><span class="at">HL</span>:<span class="at">IY</span></code> and <code class="sourceCode z80"><span class="at">DE</span>:<span class="at">BC</span></code>, so a <code>SUM32</code> function would look like this - more comment than code.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">; IN    HL:IY   the 32-bit accumulator</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">;       DE:BC   the 32-bit addend</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">; OUT:  HL:IY   HL:IY + DE:BC</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">;       S       set if the result is negative</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">;       Z       set if the top 16 bits are zero</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">;       H       set if carry from bit 27</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">;       P/V     set if signed overflow</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co">;       N       reset</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co">;       C       set if carry from bit 31</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="fu">SUM32:</span>  <span class="bu">add</span>     <span class="at">iy</span>, <span class="at">bc</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span>     <span class="at">hl</span>, <span class="at">de</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ret</span></span></code></pre></div>
<p>Some of the flags are a bit nonsensical. The half-carry bit is the result of the penultimate 4-bit ALU operation, so for an 8-bit addition it’s the carry out of bit 3. For a 16-bit operation it’s the carry out of bit 3 in the top 8 bits, or the carry out of bit 11. The zero flag will be set by the <code class="sourceCode z80"><span class="bu">adc</span></code> discarding any information from the <code class="sourceCode z80"><span class="bu">add</span></code>. The other flags will all make sense, however, as they’re based only on the most significant bits.</p>
<p>With a 32-bit addition in hand I’ll also want a comparison of unsigned 32-bit numbers. This will happen using subtraction, because comparison on the Z80 is a subtraction that discards the result and there’s no 16-bit comparison instruction. The routine compares the high words first, only comparing the low words if the high words are equal.</p>
<p>There is no <code class="sourceCode z80"><span class="bu">SUB</span></code> instruction for 16-bit registers. There is, however, <code class="sourceCode z80"><span class="bu">SBC</span></code> for the <code class="sourceCode z80"><span class="at">HL</span></code> register, which is “subtract with carry”. On the Z80, as with many other processors, this is implemented as “subtract with borrow” - the carry flag becomes a borrow flag. <code class="sourceCode z80"><span class="bu">SBC</span> <span class="at">HL</span>, <span class="at">DE</span></code> is computed as <span class="math inline">\(HL - DE - C\)</span>. Before using this instruction the carry flag must be put into a known state. This can be done using the <code class="sourceCode z80"><span class="bu">SCF</span></code> instruction to set the carry flag, but there is no dedicated instruction to clear the carry flag. Fortunately, <code class="sourceCode z80"><span class="bu">OR</span> <span class="at">A</span>, <span class="at">A</span></code> will clear the carry flag in the same number of cycles as <code class="sourceCode z80"><span class="bu">SCF</span></code> sets it, and with a similar set of side effects on flags.</p>
<p>After the subtraction the carry flag will be set if there was a borrow required for the final bit of the operation. This happens only when the minuend is less than the subtrahend. The carry flag distinguishes between <code>a &lt; b</code> when set and <code>a &gt;= b</code> when reset. The zero flag is set only if the two operands are equal.</p>
<p>The 32-bit comparison works by comparing the high words and checking the zero flag. If it’s not set then the carry flag will already show which is greater, and the routine is done. If the zero flag is set then the carry flag must be clear, another subtraction is done, and the flags from that indicate the overall comparison result.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">; IN    HL:IY   the 32-bit minuend</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">;       DE:BC   the 32-bit subtrahend</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">; OUT:  Z       set if minuend == subtrahend</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">;       C       set if minuend &lt; subtrahend</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="fu">CMP32:</span>  <span class="bu">push</span>    <span class="at">hl</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">or</span>      <span class="at">a</span>, <span class="at">a</span>    <span class="co">; reset carry</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">sbc</span>     <span class="at">hl</span>, <span class="at">de</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      nz, CMP32DONE</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">iy</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">hl</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">sbc</span>     <span class="at">hl</span>, <span class="at">bc</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="fu">CMP32DONE:</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">hl</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ret</span></span></code></pre></div>
<p>With 32-bit addition and comparison ready to go the main challenge left to solve is processing the input. For simplicity’s sake the input will be pre-processed to be 32-bit words with zeros separating the sub-lists:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">INPUT:</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defw</span>    <span class="bn">1000</span>, <span class="bn">0</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defw</span>    <span class="bn">2000</span>, <span class="bn">0</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defw</span>    <span class="bn">3000</span>, <span class="bn">0</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defw</span>    <span class="bn">0</span>, <span class="bn">0</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defw</span>    <span class="bn">4000</span>, <span class="bn">0</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defw</span>    <span class="bn">0</span>, <span class="bn">0</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defw</span>    <span class="bn">5000</span>, <span class="bn">0</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defw</span>    <span class="bn">6000</span>, <span class="bn">0</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defw</span>    <span class="bn">0</span>, <span class="bn">0</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defw</span>    <span class="bn">7000</span>, <span class="bn">0</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defw</span>    <span class="bn">8000</span>, <span class="bn">0</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defw</span>    <span class="bn">9000</span>, <span class="bn">0</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defw</span>    <span class="bn">0</span>, <span class="bn">0</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defw</span>    <span class="bn">10000</span>, <span class="bn">0</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defw</span>    <span class="bn">0</span>, <span class="bn">0</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defw</span>    <span class="bn">0</span>, <span class="bn">0</span></span></code></pre></div>
<p>My solution algorithm is going to look like this:</p>
<ol type="1">
<li>Initialise the maximum to zero</li>
<li>While there are lists of numbers left:
<ol type="a">
<li>Initialise the sum to zero</li>
<li>Add each number in the list to the sum</li>
<li>If the sum is greater than the maximum save it as the new maximum</li>
</ol></li>
<li>Print out the result</li>
</ol>
<p>Translating this to Z80 assembly means figuring out what variables I need and where I’ll store them. I’ll use four bytes of memory to hold the maximum, because I will only need that once per outer loop. I’ll keep the current sum in <code class="sourceCode z80"><span class="at">HL</span>:<span class="at">IY</span></code> where it’s ready to use in my addition and comparison subroutines. <code class="sourceCode z80"><span class="at">BC</span></code> and <code class="sourceCode z80"><span class="at">DE</span></code> will be used for addends and subtrahends as needed, and that leaves <code class="sourceCode z80"><span class="at">A</span></code> for general purpose arithmetic and <code class="sourceCode z80"><span class="at">IX</span></code> to point to my input.</p>
<p>I will want to load <code class="sourceCode z80"><span class="at">DE</span>:<span class="at">BC</span></code> from <code class="sourceCode z80">(<span class="at">IX</span>)</code> multiple times, so I’ll pop that in its own routine. It’s important to remember that the Z80 is little endian: when loading or storing a multi-byte value the least significant byte is at the first address. The <code class="sourceCode z80"><span class="kw">DEFW</span> <span class="bn">10000</span>, <span class="bn">0</span></code> above assembles to the hex bytes <code class="sourceCode z80"><span class="bn">$10</span> <span class="bn">$27</span> <span class="bn">$00</span> <span class="bn">$00</span></code>, or <code class="sourceCode z80"><span class="bn">16</span>, <span class="bn">39</span>, <span class="bn">0</span>, <span class="bn">0</span></code> in decimal. <span class="math inline">\(39\times256 = 9984 + 16 = 10000\)</span>. This means I want to load <code class="sourceCode z80"><span class="at">C</span></code> from <code class="sourceCode z80">(<span class="at">IX</span>+<span class="bn">0</span>)</code> up to <code class="sourceCode z80"><span class="at">D</span></code> from <code class="sourceCode z80">(<span class="at">IX</span>+<span class="bn">3</span>)</code>. Every time I load the value I also need to test whether it’s zero, so I’ll set the zero flag appropriately as I load.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">; IN    IX      address of next input to read</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">; OUT   DE:BC   32-bit value loaded from (IX)</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">;       IX      incremented past read input</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">;       A       clobbered</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">;       Z       set if the loaded value was zero</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="fu">READ:</span>   <span class="bu">ld</span>      <span class="at">c</span>, (<span class="at">ix</span>+<span class="bn">0</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">b</span>, (<span class="at">ix</span>+<span class="bn">1</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">e</span>, (<span class="at">ix</span>+<span class="bn">2</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">d</span>, (<span class="at">ix</span>+<span class="bn">3</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">ix</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">ix</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">ix</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">inc</span>     <span class="at">ix</span></span></code></pre></div>
<p>Testing whether <code class="sourceCode z80"><span class="at">DE</span>:<span class="at">BC</span></code> is zero is nice and easy: load one of the 8-bit registers into <code class="sourceCode z80"><span class="at">A</span></code> then <code class="sourceCode z80"><span class="bu">OR</span></code> each of the others in. Only if all of them are zero will <code class="sourceCode z80"><span class="at">A</span></code> be zero afterwards, with the zero flag conveniently holding that information.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">a</span>, <span class="at">b</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">or</span>      <span class="at">a</span>, <span class="at">c</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">or</span>      <span class="at">a</span>, <span class="at">d</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">or</span>      <span class="at">a</span>, <span class="at">e</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ret</span></span></code></pre></div>
<p>It’s time to set up the main program and initialise the input and maximum variables, as well as of course setting a valid stack pointer value so I can call subroutines.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">MAX:</span>    <span class="kw">DEFW</span>    <span class="bn">0</span>, <span class="bn">0</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="fu">DAY01:</span>  <span class="bu">ld</span>      <span class="at">sp</span>, <span class="bn">$8000</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">ix</span>, INPUT</span></code></pre></div>
<p>For my outer loop I will clear <code class="sourceCode z80"><span class="at">HL</span>:<span class="at">IY</span></code> to zero then load <code class="sourceCode z80"><span class="at">DE</span>:<span class="at">BC</span></code> from <code class="sourceCode z80">(<span class="at">IX</span>)</code>. The outer loop is done if that load sets the zero flag.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">OUTER:</span>  <span class="bu">ld</span>      <span class="at">hl</span>, <span class="bn">0</span>   <span class="co">; init sum</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">iy</span>, <span class="bn">0</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    READ</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      z, DONE</span></code></pre></div>
<p>I’m ready to enter the inner loop now, where I’ll add <code class="sourceCode z80"><span class="at">DE</span>:<span class="at">BC</span></code> to the current sum in <code class="sourceCode z80"><span class="at">HL</span>:<span class="at">IY</span></code>, load the next input number, and test whether that’s zero: if it is, I repeat the inner loop.</p>
<p>Because <code class="sourceCode z80">SUM32</code> is so trivial I’m not even going to call it - I will inline the two instructions right here.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">INNER:</span>  <span class="bu">add</span>     <span class="at">iy</span>, <span class="at">bc</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span>     <span class="at">hl</span>, <span class="at">de</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    READ</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      nz, INNER</span></code></pre></div>
<p>Having completed a sum I need to compare it to the maximum and update as needed. I can <code class="sourceCode z80"><span class="at">DE</span>:<span class="at">BC</span></code> directly from fixed memory, being careful with byte order, then use my <code class="sourceCode z80">CMP32</code> routine.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">bc</span>, (MAX)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, (MAX+<span class="bn">2</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    CMP32</span></code></pre></div>
<p>The carry flag is set if <code class="sourceCode z80"><span class="at">DE</span>:<span class="at">BC</span></code> is greater than <code class="sourceCode z80"><span class="at">HL</span>:<span class="at">IY</span></code> -if so I can head straight back into the outer loop.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      <span class="at">c</span>, OUTER</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (MAX), <span class="at">iy</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (MAX+<span class="bn">2</span>), <span class="at">hl</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      OUTER</span></code></pre></div>
<p>There’s nothing left to do now but print out the maximum, using the as-yet undescribed <code class="sourceCode z80">PRINT32</code> routine, then <code class="sourceCode z80"><span class="bu">HALT</span></code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">DONE:</span>   <span class="bu">ld</span>      <span class="at">iy</span>, (MAX)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">hl</span>, (MAX+<span class="bn">2</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    PRINT32</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">a</span>, <span class="st">&#39;\n&#39;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">out</span>     (<span class="bn">1</span>), <span class="at">a</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">HALT</span></span></code></pre></div>
<p>Printing a decimal number is a bit tricky on the Z80. The range of an unsigned 32-bit number is 0 to 4,294,967,295, so one common approach is to subtract 1,000,000,000 from the number to print until borrow is set and print that as the billions digit, then subtract 100,000,000 until borrow is set, and so on down to subtracting 1. A nice little extra feature is to also keep track of whether there’s been a non-zero digit yet and skip the print until either the first non-zero digit or the last digit.</p>
<p>For the in-browser emulator, writing a value to I/O port 1 will print it to a console HTML element.</p>
<p>I am also out of registers to store the flag indicating whether I’ve seen a non-zero digit or not. This is a good time to introduce a stack frame. When the Z80 CPU sees a <code class="sourceCode z80"><span class="bu">CALL</span></code> instruction it stores <code class="sourceCode z80">PC</code> onto the stack and jumps to the target address. When the subroutine is done, it executes a <code class="sourceCode z80"><span class="bu">RET</span></code> and the <code class="sourceCode z80">PC</code> is popped off the stack. Around that return address useful things can be stored. Before the <code class="sourceCode z80"><span class="bu">CALL</span></code> a bit of code might <code class="sourceCode z80"><span class="bu">PUSH</span></code> arguments that don’t fit into registers, and after the call the subroutine may need to allocate a bit of space on the stack for local variables. The structure of data around the return address is called a stack frame.</p>
<div style="margin: 0 auto; text-align: center;">
<svg width="256" height="256">
<rect x="3" y="3" width="220" height="250" style="stroke: #333; stroke-width: 2; fill: none;"/>
<text x="113" y="15.5" text-anchor="middle" dominant-baseline="central" style="stroke: #bbb">… used stack …</text>
<line x1="4" y1="28" x2="222" y2="28" style="stroke: #bbb; stroke-width: 1"/>
<text x="113" y="40.5" text-anchor="middle" dominant-baseline="central">Parameter 3</text>
<line x1="4" y1="53" x2="222" y2="53" style="stroke: #bbb; stroke-width: 1"/>
<text x="113" y="65.5" text-anchor="middle" dominant-baseline="central">Parameter 2</text>
<line x1="4" y1="78" x2="222" y2="78" style="stroke: #bbb; stroke-width: 1"/>
<text x="113" y="90.5" text-anchor="middle" dominant-baseline="central">Parameter 1</text>
<line x1="4" y1="103" x2="222" y2="103" style="stroke: #bbb; stroke-width: 1"/>
<text x="113" y="115.5" text-anchor="middle" dominant-baseline="central" font-weight="bold">Return address</text>
<line x1="4" y1="128" x2="222" y2="128" style="stroke: #bbb; stroke-width: 1"/>
<text x="113" y="140.5" text-anchor="middle" dominant-baseline="central">Saved IX</text>
<text x="230" y="140.5" dominant-baseline="central">IX</text>
<line x1="4" y1="153" x2="222" y2="153" style="stroke: #bbb; stroke-width: 1"/>
<text x="113" y="165.5" text-anchor="middle" dominant-baseline="central">Local var 1</text>
<line x1="4" y1="178" x2="222" y2="178" style="stroke: #bbb; stroke-width: 1"/>
<text x="113" y="190.5" text-anchor="middle" dominant-baseline="central">Local var 2</text>
<line x1="4" y1="203" x2="222" y2="203" style="stroke: #bbb; stroke-width: 1"/>
<text x="113" y="215.5" text-anchor="middle" dominant-baseline="central">Local var 3</text>
<text x="230" y="215.5" dominant-baseline="central">SP</text>
<line x1="4" y1="228" x2="222" y2="228" style="stroke: #bbb; stroke-width: 1"/>
<text x="113" y="240.5" text-anchor="middle" dominant-baseline="central" style="stroke: #bbb">… free stack …</text>
</svg>
</div>
<p>To set up a stack frame the first thing that happens on entry to a subroutine is to save <code class="sourceCode z80"><span class="at">IX</span></code> and then set it to <code class="sourceCode z80"><span class="at">SP</span></code>. There is no instruction to do this directly so <code class="sourceCode z80"><span class="at">IX</span></code> is set to zero then <code class="sourceCode z80"><span class="at">SP</span></code> is added to it. After that space for local variables is reserved by subtracting the required amount from <code class="sourceCode z80"><span class="at">SP</span></code>. Once again there is no handy instruction to add or subtract values to <code class="sourceCode z80"><span class="at">SP</span></code>. Open option is to load the fixed offset into <code class="sourceCode z80"><span class="at">HL</span></code>, add <code class="sourceCode z80"><span class="at">SP</span></code> to it, and transfer the result back to <code class="sourceCode z80"><span class="at">SP</span></code> - but this clobbers <code class="sourceCode z80"><span class="at">HL</span></code>. Another option is to push a register, which decrements <code class="sourceCode z80"><span class="at">SP</span></code> twice but this does unnecessary memory writes. It’s also possible to just <code class="sourceCode z80"><span class="bu">DEC</span> <span class="at">SP</span></code> repeatedly but this is 6 cycles per decrement and doesn’t scale well to multiple local variables.</p>
<p>CPU support is essential to working with stack frames effectively. The Z80 has indexed addressing with the <code class="sourceCode z80"><span class="at">IX</span></code> and <code class="sourceCode z80"><span class="at">IY</span></code> registers, allowing a local variable to be accessed as, eg, <code class="sourceCode z80"><span class="bu">LD</span> <span class="at">A</span>, (<span class="at">IX</span>-<span class="bn">1</span>)</code>, but it doesn’t have good support for setting up or tearing down a stack frame. The 8086 allowed directly moving the stack pointer to the base pointer register, as well as adding constant values to the stack pointer. The 80186 added <code>ENTER</code> and <code>LEAVE</code> instructions that do all the work for you - however, <code>ENTER</code> wound up overspecified and difficult to implement in processors, and as a result neither instruction is typically used by compilers. On the other end of the scale the 6502 lacks the required indexed addressing mode, and usually a different solution will be required.</p>
<p>For <code class="sourceCode z80">PRINT32</code> only a single byte of storage is needed, so <code class="sourceCode z80"><span class="bu">DEC</span> <span class="at">SP</span></code> will work nicely.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">; IN    HL:IY   A 32-bit number to print</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co">; OUT   A       clobbered</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="fu">PRINT32:</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">ix</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">ix</span>, <span class="bn">0</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">ix</span>, <span class="at">sp</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">dec</span>     <span class="at">sp</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">bc</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">de</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">hl</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">iy</span></span></code></pre></div>
<p>The flag for whether a non-zero character has been printed will be stored at <code class="sourceCode z80">(<span class="at">IX</span>-<span class="bn">1</span>)</code>. I will use ‘0’ as the flag indicating that only zeros have been seen so far so I can do an easy comparison between the digit to print and the flag: if they’re equal, don’t print. Any non-digit value will serve to indicate printing should happen.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (<span class="at">ix</span>-<span class="bn">1</span>), <span class="st">&#39;0&#39;</span></span></code></pre></div>
<p>For each of the 10 digit locations <code class="sourceCode z80"><span class="at">DE</span>:<span class="at">BC</span></code> will be loaded with the constant to subtract and a subroutine will be called. For the last digit location the non-zero character flag will be forced true, so at least one digit is printed each time.</p>
<p>One more limitation of the Z80 instruction set now rears its head: there is an <code class="sourceCode z80"><span class="bu">ADD</span> <span class="at">IY</span>, <span class="at">DE</span></code> instruction but no corresponding subtraction. Fortunately subtracing a number is the same as adding its negation and inverting the carry flag’s meaning, so instead of loading positive constants for subtraction I will load negative constants for addition.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">bc</span>, -<span class="bn">1_000_000_000</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, -<span class="bn">1_000_000_000</span> &gt;&gt; <span class="bn">16</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    DIGIT</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">bc</span>, -<span class="bn">100_000_000</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, -<span class="bn">100_000_000</span> &gt;&gt; <span class="bn">16</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    DIGIT</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">bc</span>, -<span class="bn">10_000_000</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, -<span class="bn">10_000_000</span> &gt;&gt; <span class="bn">16</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    DIGIT</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">bc</span>, -<span class="bn">1_000_000</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, -<span class="bn">1_000_000</span> &gt;&gt; <span class="bn">16</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    DIGIT</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">bc</span>, -<span class="bn">100_000</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, -<span class="bn">100_000</span> &gt;&gt; <span class="bn">16</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    DIGIT</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">bc</span>, -<span class="bn">10_000</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, -<span class="bn">10_000</span> &gt;&gt; <span class="bn">16</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    DIGIT</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">bc</span>, -<span class="bn">1_000</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, -<span class="bn">1_000</span> &gt;&gt; <span class="bn">16</span></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    DIGIT</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">bc</span>, -<span class="bn">100</span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, -<span class="bn">100</span> &gt;&gt; <span class="bn">16</span></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    DIGIT</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">bc</span>, -<span class="bn">10</span></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, -<span class="bn">10</span> &gt;&gt; <span class="bn">16</span></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    DIGIT</span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>        <span class="co">; ensure last digit always prints</span></span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (<span class="at">ix</span>-<span class="bn">1</span>), <span class="bn">1</span></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">bc</span>, -<span class="bn">1</span></span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, -<span class="bn">1</span> &gt;&gt; <span class="bn">16</span></span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    DIGIT</span></code></pre></div>
<p>To clean up the stack frame <code class="sourceCode z80"><span class="at">SP</span></code> must be restored to where it was after saving <code class="sourceCode z80"><span class="at">IX</span></code>. The Z80 does have an instruction to set <code class="sourceCode z80"><span class="at">SP</span></code> to the value of <code class="sourceCode z80"><span class="at">IX</span></code>, so this part is easy. It would also be possible here to simply increment <code class="sourceCode z80"><span class="at">SP</span></code> to balance the decrement done on entry.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">iy</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">hl</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">de</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">bc</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">sp</span>, <span class="at">ix</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">ix</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ret</span></span></code></pre></div>
<p><code class="sourceCode z80">DIGIT</code> will add <code class="sourceCode z80"><span class="at">DE</span>:<span class="at">BC</span></code> to <code class="sourceCode z80"><span class="at">HL</span>:<span class="at">IY</span></code> until carry is reset, incrementing <code class="sourceCode z80"><span class="at">A</span></code> each time.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">DIGIT:</span>  <span class="bu">ld</span>      <span class="at">a</span>, <span class="st">&#39;0&#39;</span> - <span class="bn">1</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="fu">DLOOP:</span>  <span class="bu">inc</span>     <span class="at">a</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">iy</span>, <span class="at">bc</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span>     <span class="at">hl</span>, <span class="at">de</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      <span class="at">c</span>, DLOOP</span></code></pre></div>
<p>Once the carry flag is reset <code class="sourceCode z80"><span class="at">DE</span>:<span class="at">BC</span></code> needs to be subtracted from <code class="sourceCode z80"><span class="at">HL</span>:<span class="at">IY</span></code>, which will be a bit of a shuffle through the stack due to the limited instructions for subtraction.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">hl</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">iy</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">hl</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">sbc</span>     <span class="at">hl</span>, <span class="at">bc</span> <span class="co">; &quot;iy&quot;-bc</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">push</span>    <span class="at">hl</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">iy</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">pop</span>     <span class="at">hl</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">sbc</span>     <span class="at">hl</span>, <span class="at">de</span> <span class="co">; hl-de</span></span></code></pre></div>
<p>And last of all, print <code class="sourceCode z80"><span class="at">A</span></code> if it or the non-zero flag are non-zero.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>        <span class="bu">cp</span>      (<span class="at">ix</span>-<span class="bn">1</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      z, NOPRINT</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">out</span>     (<span class="bn">1</span>), <span class="at">a</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (<span class="at">ix</span>-<span class="bn">1</span>), <span class="bn">1</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="fu">NOPRINT:</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ret</span></span></code></pre></div>
<p>Let’s fire it up and see what it does.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode z80 run"><code class="sourceCode z80"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jp</span>      DAY01</span></code></pre></div>
<p>That looks great. I will ask you to take my word for it that it also succeeds with my puzzle input.</p>
<h2 id="star-2">Star 2</h2>
<p>The second star for the day simply expands the problem to tracking the top three values rather than the top one. This is easily accomplished by storing the top three sorted: when a new value comes in, compare to the lowest top three. If it’s greater then discard the 3rd place value and store the new one. Then, see if you need to swap 3rd place and 2nd place. If so, also then check if you need to swap 1st and 2nd place.</p>
<p>The main loop is practically unchanged.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">TOP3:</span>   <span class="kw">defw</span>    <span class="bn">0</span>, <span class="bn">0</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defw</span>    <span class="bn">0</span>, <span class="bn">0</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">defw</span>    <span class="bn">0</span>, <span class="bn">0</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="fu">STAR2:</span>  <span class="bu">ld</span>      <span class="at">sp</span>, <span class="bn">$8000</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">ix</span>, INPUT</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="fu">OUTER2:</span> <span class="bu">ld</span>      <span class="at">hl</span>, <span class="bn">0</span>   <span class="co">; init sum</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">iy</span>, <span class="bn">0</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    READ</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      z, DONE2</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="fu">INNER2:</span> <span class="bu">add</span>     <span class="at">iy</span>, <span class="at">bc</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span>     <span class="at">hl</span>, <span class="at">de</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    READ</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      nz, INNER2</span></code></pre></div>
<p>Here I now do a set of comparisons instead of just one.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>        <span class="co">; check if the new sum is in the top 3</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">bc</span>, (TOP3)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, (TOP3+<span class="bn">2</span>)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    CMP32</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      <span class="at">c</span>, OUTER2</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (TOP3), <span class="at">iy</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (TOP3+<span class="bn">2</span>), <span class="at">hl</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">; need to swap 3rd and 2nd?</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">bc</span>, (TOP3+<span class="bn">4</span>)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, (TOP3+<span class="bn">6</span>)</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    CMP32</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      <span class="at">c</span>, OUTER2</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (TOP3), <span class="at">bc</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (TOP3+<span class="bn">2</span>), <span class="at">de</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (TOP3+<span class="bn">4</span>), <span class="at">iy</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (TOP3+<span class="bn">6</span>), <span class="at">hl</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">; need to swap 2nd and 1st?</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">bc</span>, (TOP3+<span class="bn">8</span>)</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, (TOP3+<span class="bn">10</span>)</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    CMP32</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      <span class="at">c</span>, OUTER2</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (TOP3+<span class="bn">4</span>), <span class="at">bc</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (TOP3+<span class="bn">6</span>), <span class="at">de</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (TOP3+<span class="bn">8</span>), <span class="at">iy</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      (TOP3+<span class="bn">10</span>), <span class="at">hl</span></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jr</span>      OUTER2</span></code></pre></div>
<p>When done there’s also the job of summing the top 3 to take care of.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="fu">DONE2:</span>  <span class="bu">ld</span>      <span class="at">iy</span>, (TOP3)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">hl</span>, (TOP3+<span class="bn">2</span>)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">bc</span>, (TOP3+<span class="bn">4</span>)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, (TOP3+<span class="bn">6</span>)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">iy</span>, <span class="at">bc</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span>     <span class="at">hl</span>, <span class="at">de</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">bc</span>, (TOP3+<span class="bn">8</span>)</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">de</span>, (TOP3+<span class="bn">10</span>)</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">add</span>     <span class="at">iy</span>, <span class="at">bc</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">adc</span>     <span class="at">hl</span>, <span class="at">de</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">call</span>    PRINT32</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">ld</span>      <span class="at">a</span>, <span class="st">&#39;\n&#39;</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">out</span>     (<span class="bn">1</span>), <span class="at">a</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">HALT</span></span></code></pre></div>
<p>And let’s run this one.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode z80 run"><code class="sourceCode z80"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>        <span class="bu">jp</span>      STAR2</span></code></pre></div>
<p>There is the expected value, all done and dusted.</p>]]></summary>
</entry>
<entry>
    <title>Programming the TRS-20's FPGA</title>
    <link href="https://bje.id.au/blog/posts/trs20/018-fpga-programming.html" />
    <id>https://bje.id.au/blog/posts/trs20/018-fpga-programming.html</id>
    <published>2020-11-21T00:00:00Z</published>
    <updated>2020-11-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>There are many things on the virtual TODO list for the TRS-20. But topping them out has to be the final task required to have the board become self-sufficient: making the FPGA capable of burning itself a new bitstream to its SPI Flash ROM.</p>
<p>As I mentioned in my last post, I’m not in this project to do absolutely everything for myself. Where there’s existing code, I’ll happily use it - unless I think I’ve got something to learn or fun to have. This bit of work is both learning and fun (or perhaps <a href="https://www.theoryoffun.com/">both</a>) so I’m going to author my own SPI master in Verilog. But that’s not what this post is about.</p>
<p>Instead, this post talks about the process of building, testing, and understanding Verilog code, from the perspective of a novice to the field.</p>
<!--more-->
<h1 id="getting-started-with-an-fpga">Getting started with an FPGA</h1>
<p>My FPGA is an iCE40HX1K. I chose this particular part for a few reasons. Crucially, it’s available in a TQFP-100 package, which is right at the very extreme edge of my ability to solder. It’s large enough to do interesting things with, supports 3.3V I/O, and can be clocked at speeds much higher than I’m likely to try to clock it. And just as importantly as being able to solder it to a PCB, it is supported by an open source toolchain that I can fit into my usual sort of workflows.</p>
<p>An FPGA is <a href="http://blog.notdot.net/2012/10/Build-your-own-FPGA">more or less</a> a grid of cells, with each cell consisting of a look-up table (LUT) and a D flip-flop (DFF) and routing to connect the cells to each other and to the I/O pins. Almost every aspect of this is controlled by SRAM inside the IC, which in turn is programmed using a bitstream loaded from the SPI Flash.</p>
<p>FPGAs are also known for having pretty horrendously bad vendor software. This is especially true if you’re a Mac user, since no-one seems to support Macs natively. The downloads are huge (if there’s even free tools in the first place) and they’re not always compatible with using git to manage changes. I tried to persevere with Quartus for Altera CPLDs and entry-level FPGAs for a little while, but it just wasn’t a good experience.</p>
<p>Enter <a href="http://bygone.clairexen.net/icestorm/">Project Icestorm</a>. This is a project that documented the bitstream format of the iCE40 family of FPGAs, and created tools to synthesise, route, and program the ICs from Verilog source. The tools work in the way I’m used to toolchains working: read file in, do <em>stuff</em>, write file out. No IDE, no graphical integrated design tool, just source files in text, intermediate files in various formats, and a binary at the end of it all.</p>
<p>All of this settled the matter. I didn’t really need an FPGA on the TRS-20 and in fact it runs just fine with the FPGA sitting there totally inert. Its main functional role is as an interrupt controller: nothing else is wired to the interrupt lines of the processor, and I didn’t want to try making a controller out of discrete logic ICs. I did really want to play with an FPGA, though, so that’s exactly what I’m going to do.</p>
<h1 id="the-basics---building-a-bitstream">The basics - building a bitstream</h1>
<p>I like Make. I’ve used it for decades. It’s far from a perfect tool, and despite having used it for decades it’s in the pile of tools that I wouldn’t be able to use in any non-trivial way if Google were ever offline. But for this sort of task, it’s pretty much perfect. The build process with Project Icestorm takes three steps, each time loading some file(s) from disk and writing further file(s) out to disk.</p>
<ol type="1">
<li><p>Synthesise the design using <code>yosys</code></p>
<p>This step takes in one or more Verilog source files and translates it into the building blocks of an FPGA - LUTs, DFFs, I/O ports, and other special cells. The banner image for this post is a little bit of a graph representation of the synthesised design. Here’s an entire component from the design.</p>
<figure>
<img src="/images/edgedetect.png" alt="A rising edge detector compares the past state of the signal to its current state" />
<figcaption aria-hidden="true">A rising edge detector compares the past state of the signal to its current state</figcaption>
</figure>
<p>The synchronous statement <code class="sourceCode verilog"><span class="kw">always</span> <span class="op">@(</span><span class="kw">posedge</span> clk<span class="op">)</span> past <span class="op">&lt;=</span> in<span class="op">;</span></code> establishes that each rising edge of the clock signal will load the input into the <code>past</code> register, while the continuous statement <code class="sourceCode verilog"><span class="kw">assign</span> rise <span class="op">=</span> in <span class="op">&amp;</span> <span class="op">!</span>past<span class="op">;</span></code> passes the input and the past state through a combinatorial logic circuit. The end result is that at the rising edge of the clock signal <code>rise</code> will be high only when the <code>in</code> signal was low on the last clock edge but is high on the current edge.</p>
<p>The full image for my relatively tiny design is almost unreadably complex. I could see how it may be occasionally useful to trace a particular path with an aim of simplifying the logic involved, but I have not yet done this.</p></li>
<li><p>Place the cells and route connections with <code>nextpnr</code></p>
<p>The synthesised design output by <code>yosys</code> contains all the cells used by the design and the map of how they must be connected. The next stage in getting the design onto silicon is to determine where each cell of the design will lie on the chip and how the routing between them will be arranged. The cells on an FPGA cannot be connected entirely arbitrarily, so the choices of where to place cells and how to connect them become non-trivial. Finding an optimal placement is NP-complete: <code>nextpnr</code> uses simulated annealing to find an approximately optimal solution.</p>
<figure>
<img src="/images/trs20/fpga-layout-miso.png" alt="The lower half of an iCE40 with my design placed and routed." />
<figcaption aria-hidden="true">The lower half of an iCE40 with my design placed and routed.</figcaption>
</figure>
<p>The image here shows part of the design after packing, placing, and routing has been done. It’s produced by an <a href="https://knielsen.github.io/ice40_viewer/ice40_viewer.html">ICE40 floorplan/layout viewer</a>. The path highlighted in red is the <code>SPI_SDI$SB_IO_IN</code> net - it connects the SPI_SDI I/O buffer in the bottom right to the logic that latches values on the appropriate SPI clock edge.</p></li>
<li><p>Pack the chip configuration data into a bitstream</p>
<p>The <code>icepack</code> tool takes the output of <code>nextpnr</code> and produces a bitstream image. These are always exactly 32,220 bytes in length - and it turns out, they always have a Y-modem CRC of E2B5. This might seem foreboding, like something terrible happens because I comically mix up two images. But no, it’s just a thing - the bitstream format has a CCITT 16-bit CRC checksum in it, the E2B5 is the checksum of the headers and footers. I suppose a different CRC might arise if I used a different combination of options and got a different header.</p>
<p>I also use <code>icemulti</code> at this stage to produce a multi-image bitstream, with four images. This allows the cold boot pins on the CPU board to select one of the images at boot, and the use of the <code>SB_WARMBOOT</code> special cell to reboot into one of them under software control. All four images I packed in were identical for flashing to the ROM: I want the right structure in place to be able to flash a single image into the ROM via the FPGA. I also align all images to 32k boundaries, so I can just erase one 32k sector. The way I’ve set it up places the first image at 0x000a0 with the preceding 160 bytes being the multi-image header. Re-flashing the first image requires that this header is prepended.</p></li>
</ol>
<h1 id="testing-a-hardware-design">Testing a hardware design</h1>
<p>For an extremely simple design like my original “proof-of-concept” LED flasher I can be pretty confident that it’s likely to work first go. As I get more complex I’d like to have more certainty that I’ve got it right than just trusting that I would never make a mistaek.</p>
<p>I frequently see mentions of “testbenches” when doing Google queries like “verilog getting started” and “verilog it doesn’t work help help help”. I’m still not sure what the term means - but it’s an approach for writing an additional Verilog module that provides test inputs to the module under test. In these testbench modules one can use Verilog constructs that have no meaning when synthesised for hardware, such as delaying a specific time period.</p>
<p>I didn’t do any of this.</p>
<p>Instead, I used a tool called <a href="https://www.veripool.org/wiki/verilator">Verilator</a>. This compiles your synthesisable Verilog into C++. Armed with this I wrote a test harness (in C++, I feel so dirty) to validate my design against a fairly simple little script emulating CPU signals for a series of <code>in</code> and <code>out</code> instructions. I also wrote a very basic emulation of an SPI Flash ROM, barely enough to test the timing on the SPI lines.</p>
<p>This not only helped me catch a bunch of errors, it also helped me quickly validate changes as I went.</p>
<p>It also supports writing out a waveform file that can be viewed with a VCD reader like <a href="http://gtkwave.sourceforge.net/">GTKWave</a>.</p>
<figure>
<img src="/images/trs20/gtkwave.png" alt="The SPI slave responds to a read request with 0xEF" />
<figcaption aria-hidden="true">The SPI slave responds to a read request with 0xEF</figcaption>
</figure>
<p>Between the test harness and the waveform, I got my SPI code into what looked like good shape pretty quickly.</p>
<h1 id="an-emulator-is-an-approximation">An emulator is an approximation</h1>
<p>But of course, it did not work properly once it hit hardware. Part of the problem is that the FPGA puts the flash IC into power down state once its done, so the only thing it will respond to is a wake-up command, but my code was instead trying to send the manufacturer ID command. Once I fixed that up - it still didn’t work properly. But it was clear it was transmitting properly, because it woke up and responded to the manufacturer ID command. The response was shifted by one bit. This is a pretty common error in SPI implementations - it’s indicative of a clocking fault.</p>
<p>The SPI chip is rated up to 133MHz for all instructions except Read Data, which is rated up to 50MHz. I didn’t exactly design this part of the board with high clock speeds in mind: I know it’s good at 40MHz, which is the speed the FPGA reads from it. My design only pushes it at 50MHz, by toggling the <code>SPI_CLK</code> line high and low on each rising edge of the 100MHz global clock.</p>
<p>There’s useful information given by <code>nextpnr</code> when it lays out your design for the IC: timing approximations for critical paths. One of my critical paths is the asynchronous inputs feeding into the 100MHz clock domain - it takes up to 7.3ns for <code>D2</code> to meander through a handful of cells before reaching the input of a flip-flop clocked in that domain. Another is the time it takes for a signal to go from the output of a flip-flop in the 100MHz domain to the <code>SPI_SS</code> output pin - this is 4.6ns, most of which is just the time it takes for the signal to traverse the various routing components involved in going from one side of the FPGA to the other.</p>
<p>4.6ns is the slowest such signal, which means that both <code>SPI_SCK</code> and <code>SPI_SDI</code> take less time than that. At 50MHz there’s 10ns available from the falling edge when the SPI flash will shift to the rising edge when the FPGA will latch. In theory there shouldn’t be a timing problem. The ROM’s datasheet says it’s at most 6ns after the falling edge of the clock signal before output data is valid - it’s possible it just takes more than 10ns for data to be stabilised and routed. Unlikely, but possible.</p>
<p>I slowed the SPI clock down to 25MHz, and lo! it worked.</p>
<p>However, it also occurred to me that I was latching input when the output clock signal was low but about to go high. This “rising edge” was clear and sharp on the inside of the FPGA, but of course it takes time for that signal to reach the edge of the device and from there get out to the ROM. Likewise, the falling edge takes time to be seen. I switched over to latching the input on the same clock edge that I lower SCK and shift data - this takes into account the delays for signals to move into and out of the FPGA. I think this is how people with experience in this space do it… but I did it myself to learn stuff, like how to see the accumulated delays for paths through the FPGA.</p>
<p>With the clock back up to 50MHz, I tried again… and to my giggly glee, it still worked.</p>
<h1 id="faster-and-faster">Faster and faster</h1>
<p>Moving to 100Mhz would be a little tricky: I could possibly just <code class="sourceCode verilog"><span class="kw">assign</span> SPI_SCK <span class="op">=</span> CLK<span class="op">;</span></code> and basically wire the 100MHz clock directly to the master clock. When I look at how others are doing it, I see tricks like using <a href="https://zipcpu.com/blog/2018/08/16/spiflash.html">DDR cells</a> to toggle the SPI clock on rising and falling edges, with an enable signal to shut it off.</p>
<p>It’s also not really necessary. I added wait state generation - you can see the <code>waitstate</code> signal in the waveform above. One thing to note about wait state generation on the TRS-20 is that it passes through a DFF IC, clocked by the rising edge of <code>PHI</code>. This IC has its own setup time that means the FPGA shouldn’t change <code>/WAIT</code> arbitrarily: it needs to change at least 3ns before <code>PHI</code> rises. I approach this with a rising edge detector on <code>PHI</code> - this is stabilised to CLK and could be up to 20ns behind the real rising edge, which is still ~30ns before the next one.</p>
<p>However, for an I/O operation the CPU will sample <code>/WAIT</code> on the falling edge of the first wait state. The DFF in the way means I need to assert <code>/WAIT</code> before the rising edge of that wait state. Having enough time to guarantee detection of it is implausible with my current approach.</p>
<p><code>/IORQ</code> and <code>/RD</code> will fall up to 25ns after the falling edge of T1. I’ll detect them up to 20ns after that - 45ns after the falling edge of T1. T2 will have risen by then, and could rise even before <code>/IORQ</code> and <code>/RD</code> have both fallen. To catch the read request I could insert an additional cycle on the <code>PHI</code> edge detect so that always comes after the read request control signals. But <code>/WR</code> falls up to 25ns after the rising edge of T2, and I won’t detect it until 45ns later. The rising edge of Tw shouldn’t come sooner than 54ns later. That’s only 6ns left to assert <code>/WAIT</code>, which is pushing up pretty hard against the FPGA’s output delays - and assumes any input delays don’t wind up adding one clock cycle to the stabilisers. Which they will.</p>
<p>A second edition of my CPU board might fix this with something like removing the DFF for <code>/WAIT</code> - the setup time for the signal is 15ns before <code>PHI</code> falls. That would give me a bit longer to get <code>/WAIT</code> in order, probably long enough to solve the problem. Another option that’s appealing is to synchronise the clocks - run the CPU at 20Mhz and use a PLL to run the FPGA at 100Mhz with a shared edge. The HX1K doesn’t have a PLL in the VQFP-100 package though, so I’d also have to go to the HX4K in the TQFP-144 package or pay a hefty fee to get a fab house to solder a BGA package on for me. I can’t divide the 100MHz clock down to drive the CPU, because the CPU runs its own clock generator, and I’ve no idea how well synchronised the <code>PHI</code> output is to the <code>EXTAL</code> input.</p>
<p>For now I’ll just accept the need to have a minimum of one wait state configured on the CPU for I/O.</p>
<p>Another way to get faster results is to use dual I/O mode. I didn’t wire up enough pins to use quad I/O mode, so dual is my limit, but it would give me an effective 100MHz data rate. Doing so requires that the FPGA understands the SPI command set - it needs to know to change outputs to inputs at the right time to avoid frying pins on either FPGA or ROM. Because frying the FPGA’s SPI pins would be such a big ol’ pile of suck I’ve got it actively preventing the dual and quad I/O commands right now. I don’t need it fast as much as I need it not to ruin the part that took me three attempts to solder properly.</p>
<h1 id="the-cpu-board-is-done">The CPU board is done</h1>
<p>The last change to push the clock back up to 50Mhz did not involve removing the flash ROM to reprogram it. Instead, I programmed it at 25MHz. The CPU board is now wholly self-sufficient: I have CP/M commands that will reprogram the ROMs for both the CPU and the FPGA.</p>
<p>The TRS-20 now needs non-volatile file storage. I could probably do something with the excess capacity of the FPGA’s ROM, there’s 3.8Mb to be had. This would involve doing deblocking in the CP/M BIOS and being cautious not to write to it willy-nilly because I’d have no load wearing. Better to look at connecting up an SD card - but whether I choose to design a second revision of the board with the SD card on it or go to a daughter board is still not certain.</p>
<p>Since writing the bulk of this post I went on to update my <a href="https://github.com/codebje/fpga20">FPGA code</a> to support an SD card on external pins. I wound up making my SPI driver asynchronous to the bus: a write begins an SPI exchange, a read returns the value latched from the last exchange (and, optionally, begins another). At 25MHz or higher this happens faster than the CPU can read I/O and write RAM. For both the SD card (at 25MHz) and the Flash ROM (at 50MHz) this gives me bulk reads using <code>inir</code> - but to support this I had to give up my 16-bit I/O addressing and live within 8 bits instead. Replacing the genuine CP/M 2.2 with ZSDOS and ZCPR1 (from <a href="https://github.com/davidgiven/cpmish">CP/Mish</a>) is next on my to-do list, including supporting deblocking and an SD card disk driver.</p>]]></summary>
</entry>
<entry>
    <title>Operating systems</title>
    <link href="https://bje.id.au/blog/posts/trs20/017-operating-system.html" />
    <id>https://bje.id.au/blog/posts/trs20/017-operating-system.html</id>
    <published>2020-10-13T00:00:00Z</published>
    <updated>2020-10-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>My computer has reached the point that I can run arbitrary code on it. Having sorted out how to get a decent chunk of arbitrary code onto the device without removing the Flash ROM and using <a href="013-program-roms.html">frankenprogrammer</a> I’ve turned my attention to what I should run on it.</p>
<p>The TRS-20 is supposed to be able to run old software to tickle my nostalgia. I don’t intend to write everything myself: if I don’t think I’ll learn from it, or have fun with it, I’ll use what already exists. This applies in the case of the operating system, where there’s a wealth of options available for retrobrew Z80/Z180 computers.</p>
<!--more-->
<p>My original TRS-80 Model I didn’t have a disk drive, and so it didn’t have a disk operating system. Instead it had a built-in BASIC interpreter and a tape cassette interface for loading programs. Machine language programs were supported, through trickery I don’t recall using. But, all that aside, I’ve no particular desire to take my nostalgia trip so far as to limit myself to TRS-80 Level 1 BASIC.</p>
<p>The banner image is (as it clearly says) TRSDOS, which I never ran. It might be possible to run it, but I don’t see much reason to try - early versions are extremely limited, and I am not sitting on a trove of TRS-80 software I’m itching to run that would need something it provides.</p>
<p>So we move on to CP/M, the dominant disk operating system of the Z80 era. For those unfamiliar with it, as I was, it’s the progenitor of the venerable MS-DOS: Microsoft’s classic operating system reimplemented large parts of CP/M, accusations were made, unpleasantness abounded, long story short Digital Research didn’t last but Microsoft did. The rights for CP/M bounced around for a while, and eventually the company holding them granted a license to the <a href="http://www.cpm.z80.de/">Unofficial CP/M Web Site</a> to distribute the CP/M source code, amongst other things. So CP/M appears perfectly valid to run.</p>
<p>CP/M’s popularity means there is vast amounts of software written for it. Enthusiasts have kept large archives of the stuff online for decades. Some of it is probably going to be worth running… and CP/M 2.2 is easy to port to a Z180 retrobrew system like mine.</p>
<p>Other alternatives include <a href="http://fuzix.org/">Fuzix</a>, a UNIX for 8-bit processors. It has appeal - but there’s a lot of work involved in porting it to new machines, and I think it’s likely to be permanently in development. On top of that, it’s a ton of C code and expects application software to also be C code, and I’m just not all that keen to pick up an obligation to write more C these days.</p>
<p>There’s also <a href="https://github.com/wwarthen/RomWBW">RomWBW</a> which packs a lot into a ROM image: MMU-capable BIOS, support for CP/M 2.2, CP/M 3, ZSDOS 1.1, NZCOM, ZPM3, and some variant of FreeRTOS. It expects a 512K or 1024K ROM, though, and expects ROM to be at physical address 0, RAM at physical address $80000 - the exact opposite of the TRS-20. This assumption is hard-coded in multiple places. It does have nice ideas for a Z180 BIOS to consider: stubs in the 64K space invoking the MMU to jump to larger functions, for example.</p>
<p>In the end, just a plain old CP/M 2.2 is the most plausible starting point. There’s a <a href="http://cpuville.com/Code/CPM-on-a-new-computer.html">solid guide</a> for porting it to a new Z80 machine, too. So I added a CP/M BIOS to my <a href="https://github.com/codebje/trs20-bootrom">boot ROM code</a>, along with a 32Kb ROM disk. The boot code formats a 192Kb RAM disk as well, giving me a large working area. CP/M itself consists of two parts: the BDOS that stays resident while transient programs run, and the CCP command processor that is reloaded on every warm boot.</p>
<h1 id="running-cpm-on-the-trs-20">Running CP/M on the TRS-20</h1>
<p>To bootstrap this into operation, I used my <a href="https://github.com/codebje/isp-writer">isp-writer</a> project to copy the new boot ROM plus CP/M into the second 64Kb of RAM, patch various locations in it accordingly, then use it to boot CP/M. From there, I wrote a <a href="https://github.com/codebje/cpmsuite/blob/master/src/sst.asm">small tool</a> to write a file into the Flash ROM, and installed the new ROM image. Satisfying.</p>
<p>In the Virtual TRS-20, I wound up doing something slightly different. The VTRS-20 uses ZSDOS and ZCPR as distributed by David Given in <a href="https://github.com/davidgiven/cpmish">cpmish</a>. On my unwritten TODO list for the TRS-20 is to replace CP/M 2.2 with ZSDOS and ZCPR - which will work out easiest if I rewrite my boot code and be more flexible about loading a BDOS and a CCP from fixed locations in ROM. This will let me update all the parts individually in Flash, rather than building a single image.</p>
<p>The VTRS-20 now supports running a CP/M command file directly from the command line, or booting into a CP/M shell with a set of files pre-loaded into the RAM drive.</p>
<p>The last few posts have been a bit of a catch-up exercise in documenting what I’ve done. From the blog alone, it may appear that after I first got some life out of the CPU board everything more or less stopped - but in truth I’ve been playing around with one aspect or another of the board since then, so much that I’ve fallen far behind on writing up what I’ve done. One consequence of that is that these last couple of posts have been written more out of a desire to just get some words committed to files than with any particular attention to editing. I’ve also been working on a LISP interpreter (because it seems like a fun thing to write) and being able to program the FPGA in-system - so perhaps my next few posts will be a bit less dry. I also still owe myself a final reckoning for how much I’ve spent on this project so far, and how much it would cost to build a CPU board given what I know now, so there’s at least one more rather dull post coming.</p>
<p>The TRS-20 is currently running 24/7, with its USB UART connected to a Raspberry Pi. I got heartily sick of fussing with two USB cables to both power and communicate with the device, and took a brief look into possible Bluetooth UART modules, before realising I could just SSH to the Pi and leave the thing plugged in permanently so I can play with it any time. Which works fine, until I lock it up with some shonky code and have to yank power to reset it. Eventually that might irritate me enough to make a remote reboot facility. Or at least try to sort out a reset button somehow.</p>]]></summary>
</entry>
<entry>
    <title>Running code on the TRS-20</title>
    <link href="https://bje.id.au/blog/posts/trs20/016-running-code.html" />
    <id>https://bje.id.au/blog/posts/trs20/016-running-code.html</id>
    <published>2020-10-11T00:00:00Z</published>
    <updated>2020-10-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>After proving that my computer board actually works, it’s time to switch over to software design. This is my core competency, where I’ve spent years professionally, and something I’ve done as a hobby since before I even had a computer. You’d think this part would be easy…</p>
<!--more-->
<p>On the <a href="https://github.com/codebje/vtrs20">Virtual TRS-20</a>, the boot rom starts up, accepts a Y-modem upload, and then jumps to it, happy as Larry. On the real TRS-20, the Y-modem upload fails on the first packet, with nothing more than metadata sent.</p>
<p>The emulator is reasonably faithful to the behaviour of the TRS-20 as I discover its nuances. Memory reads now carry an /M1 flag to allow the ROM masking to more accurately replicate the board, though I didn’t go as far as emulating the timing issue. It’s useful when debugging the boot ROM code as I can stop it, inspect memory and registers, single-step it with ease, and <em>in theory</em> get code working before it hits the real device where debugging is much harder.</p>
<p>In the case of the Y-modem upload, this isn’t the case.</p>
<h1 id="on-with-the-debug">On with the debug</h1>
<p>During the serial debug described in the <a href="015-testing-continues.html">last post</a> I found one possibly significant difference between what I expected to happen and what really happens. The <code>/RTS0</code> signal is not asserted automatically by the Z180 when its own ASCI0 receive buffer is full. The signal is entirely up to software - so I cannot rely on it to prevent overruns when uploading bytes. It may be that I’m dropping bits by blasting Y-modem packets at the CPU as fast as the UART can handle them.</p>
<p>The heart of my Y-modem code is the <code>recv_packet</code> function. The general idea is that it waits for a packet command byte for up to five seconds, then (re)transmits the ACK code assuming the sender didn’t receive it. After that, if it’s a data packet it receives the packet index then the data, with a timeout of one second for each byte. On completion it checks that the CRC matches.</p>
<p>I can work out a lot about what’s going on using some black-box probing of the behaviour. Not transmitting anything gets ‘C’ repeated every five seconds until it gives up after ten failures (‘C’ is used for the first packet to indicate CRC-mode, rather than an ACK). Sending an invalid command byte does the same, but faster. Sending a valid data packet byte <em>appears</em> to work - but then fails. After that, both the number of retry attempts and the ACK byte are corrupted.</p>
<p>This suggests the CRC function isn’t working.</p>
<p>It also suggests I have a way to keep going without removing the IC and flashing new code. The metadata packet is received before the CRC error kicks in, after which the transfer can be aborted with 2x<code>CAN</code>. The metadata packet, however, is stored right where the first data packet should subsequently get written to - and where the boot monitor will jump when executing uploaded code. Using the 1024-byte packet command this gives me a full 1026 bytes of data (packet plus two CRC bytes) that I can upload and execute.</p>
<p>Using a combination of uploading bits of code to run and replacement editions of <code>recv_packet</code> to patch in place of the boot code version, I tracked down my <em>multiple</em> errors. I present them here in source file order, but this is not the order I discovered them.</p>
<h1 id="timeouts-dont-stop-the-transfer">Timeouts don’t stop the transfer</h1>
<p>Failing ten times should abort the transfer. But it doesn’t - the code just keeps on spitting out retry bytes. Eventually I tracked this down to the following few lines of code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">retry:</span>		<span class="bu">djnz</span>	metadata</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">done:</span>		<span class="bu">pop</span>	<span class="at">hl</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>		<span class="bu">pop</span>	<span class="at">de</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>		<span class="bu">ret</span></span></code></pre></div>
<p>A successful run through the code jumps to <code>done</code> with the zero flag reset. An unsuccessful run jumps to <code>done</code> with the zero flag set. I thought that <code class="sourceCode z80"><span class="bu">djnz</span></code> would set the zero flag - but instead it doesn’t affect flags at all. Whatever the zero flag was on entry to <code>retry</code> is what it will be after the <code class="sourceCode z80"><span class="bu">djnz</span></code> has decremented <code class="sourceCode z80"><span class="at">b</span></code> to zero. Just adding <code class="sourceCode z80"><span class="bu">xor</span> <span class="at">a</span></code> will set the zero flag.</p>
<h1 id="the-retry-byte-gets-corrupted">The retry byte gets corrupted</h1>
<p>After attempting to send a valid (meta)data packet the retry byte becomes corrupted. After a failed packet transfer instead of getting a ‘C’ back I start getting NULs. I tracked this down to the code invoked after a data packet command is received.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">recv_body:</span>	<span class="bu">ld</span>	(cmd), <span class="at">a</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>		<span class="bu">ld</span>	<span class="at">de</span>, <span class="bn">1</span>*<span class="bn">100</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>		<span class="bu">call</span>	recv<span class="bn">_b</span>yte</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>		<span class="bu">jr</span>	z, retry</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>		<span class="bu">ld</span>	<span class="at">c</span>, <span class="at">a</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>		<span class="bu">call</span>	recv<span class="bn">_b</span>yte</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>		<span class="bu">jr</span>	z, retry</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>		<span class="bu">cpl</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>		<span class="bu">cp</span>	<span class="at">a</span>, <span class="at">c</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>		<span class="bu">jr</span>	nz, retry</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>		<span class="bu">ld</span>	(seq), <span class="at">a</span></span></code></pre></div>
<p>The problem, of course, is that I assumed early on that <code class="sourceCode z80"><span class="at">c</span></code> would be preserved as my retry byte value, and subsequently also decided to use <code class="sourceCode z80"><span class="at">c</span></code> to store the sequence number to compare to its complement. Oops. I accepted that there’s not many registers on the Z180 and stored the retry byte in memory instead.</p>
<h1 id="going-too-far-the-other-way">Going too far the other way</h1>
<p>Now we come to the headline problem - the CRC validation is failing. The other problems would happen in emulation, if I’d exhaustively tested all possible code paths. My <code class="sourceCode z80"><span class="bu">djnz</span></code> emulation didn’t set flags. Yes, that’s right, I wrote assembly code that assumed one thing about an instruction, and code to emulate that instruction assuming something else. People are fallible, tests never exhaustively test all possible code paths, and trusting to discipline to catch problems is naive.</p>
<p>But this problem was different: the bytes were being received correctly. I could send binary code and run it, which wouldn’t be possible if the transfer were corrupted. The CRC code works fine when testing. There’s only one answer left: the CRC code isn’t being called correctly.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>		<span class="bu">push</span>	<span class="at">hl</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>		<span class="bu">push</span>	<span class="at">bc</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>		<span class="bu">ld</span>	<span class="at">bc</span>, <span class="bn">130</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>		<span class="bu">ld</span>	<span class="at">a</span>, (cmd)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>		<span class="bu">cp</span>	<span class="at">a</span>, YM<span class="bn">_</span>SOH</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>		<span class="bu">jr</span>	z, <span class="bn">$</span>+<span class="bn">5</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>		<span class="bu">ld</span>	<span class="at">bc</span>, <span class="bn">1026</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>		<span class="bu">ld</span>	<span class="at">de</span>, <span class="bn">1</span>*<span class="bn">100</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>		<span class="bu">call</span>	recv<span class="bn">_</span>wait</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>		<span class="bu">pop</span>	<span class="at">bc</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>		<span class="bu">pop</span>	<span class="at">hl</span></span></code></pre></div>
<p>This little bit of code is responsible for receiving either 130 or 1026 bytes, the payload and its CRC, depending on whether it’s a SOH or STX command. I carefully preserve <code class="sourceCode z80"><span class="at">bc</span></code> because <code class="sourceCode z80"><span class="at">b</span></code> contains my retry counter and <code class="sourceCode z80"><span class="at">c</span></code> contains (hah!) my retry byte. Then I set up <code class="sourceCode z80"><span class="at">bc</span></code> to hold the size of the payload and CRC, and receive the data.</p>
<p>Then I restore <code class="sourceCode z80"><span class="at">bc</span></code>.</p>
<p>At this point in receiving the metadata packet <code class="sourceCode z80"><span class="at">bc</span></code> contains <code class="sourceCode z80"><span class="bn">$0a00</span></code>. There are still ten retries allowed, and the retry byte has been replaced by NUL. The payload length I calculated is gone.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode z80"><code class="sourceCode z80"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>		<span class="bu">jr</span>	z, retry</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>		<span class="bu">call</span>	ym<span class="bn">_</span>crc		<span class="co">; CRC should be zero</span></span></code></pre></div>
<p>Then I call the CRC code. This expects the data to checksum in <code class="sourceCode z80"><span class="at">hl</span></code> (check: I preserved <code class="sourceCode z80"><span class="at">hl</span></code> for exactly this reason) and the length of the data in <code class="sourceCode z80"><span class="at">bc</span></code> … but that’s not the length of the received data any more. It’s much, much bigger than the received data.</p>
<p>The Y-modem 16-bit CRC isn’t the world’s best choice of checksum. It’s definitely an improvement over X-modem’s naive 8-bit checksum but it’s a long way short of a reliable hash. In this case one simple flaw plays out: <code class="sourceCode c">crc16<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dv">0</span></code>.</p>
<p>My emulator’s SRAM is initialised to zero. Real SRAM is initialised to the background noise of the universe. On my emulator, I checksum 2560 bytes and come up with the same answer I would if I only checksummed the first 130 or 1026 bytes: zero. On the real board the CRC computes over 130 or 1026 bytes of data, getting zero - and then goes on to incorporate the noise.</p>
<p>Well - SRAM’s initial state isn’t actually noise. It’s the consequence of unstable states in (more-or-less) flip-flops resolving one way or the other, which usually comes down to microscopic manufacturing differences. As a result, I always get the <em>same</em> wrong value, because my SRAM on power-on always got the <em>same</em> uninitialised junk in it.</p>
<p>Nifty.</p>
<h1 id="fixing-it-all">Fixing it all</h1>
<p>I wrote a <a href="https://github.com/codebje/scomm">simple program</a> to transmit a patch for <code>recv_packet</code>, then do a full Y-modem transfer of something bigger.</p>
<p>The code for this, I called the <a href="https://github.com/codebje/isp-writer/blob/ymodem-patch/src/ispwriter.asm">in-system programming writer</a>.</p>
<p>At ths point, I can patch the bad code to upload up to 52k of arbitrary code and run it. But it’s not too satisfying to just have a low effort boot monitor with a Y-modem upload for running new code, so rather than focusing on updating the Flash ROM itself the next task will be to upload an operating system.</p>]]></summary>
</entry>
<entry>
    <title>The TRS-20 - Will it work?</title>
    <link href="https://bje.id.au/blog/posts/trs20/015-testing-continues.html" />
    <id>https://bje.id.au/blog/posts/trs20/015-testing-continues.html</id>
    <published>2020-08-01T00:00:00Z</published>
    <updated>2020-08-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>With the board fully assembled, and USB enumeration working well enough to see the device, it’s time to see if the design is valid. Do I have a working Z180-based computer, or an expensive paperweight?</p>
<!--more-->
<h1 id="first-blink-the-lights">First, blink the lights</h1>
<p>My <a href="https://github.com/codebje/trs20-bootrom">initial bootrom</a> changes the CPU clock divider from EXTAL/2 to EXTAL/1 a few bytes into execution. With the FPGA reprogrammed to flash LED1 on a 24-bit divider, a 9.216MHz PHI will blink LED1 at 0.55Hz and an 18.432MHz PHI will blink it at 1.1Hz. With LED2 still on a 26-bit divider of the 100MHz oscillator, this provides an easy to observe visual guide to whether my boot ROM is executing at all.</p>
<p>Which lead me to discover that my boot ROM was not executing at all. The CPU was putting out a clock signal just fine, but at 9.216MHz, not 18.432MHz.</p>
<p>To verify the CPU was still okay after all my earlier fumbling about I put it back into the old debug board I built early on in the process, with an 18.432MHz can oscillator. My logic analyser showed it doing the expected signal dance - but I also recorded what happened as the CPU came out of /RESET, and saw that A19 stays high after /RESET has gone high. It stubbornly doesn’t fall until the address lines are being settled for the first machine cycle, which is up to 30ns after PHI rises for clock cycle T1. On top of that /M1 falls at most 35ns after PHI rises for T1. To the limits of accuracy of my very cheap 24MHz analyser, in practice /M1 falls at the same time as A19.</p>
<p>This is a significant oversight in my board design - the datasheet shows, if you look properly, that /M1 could fall before the address lines have settled. An earlier revision of my design used /MREQ instead of /M1, which can be seen in <a href="011-motherboard.html#memory">the design post</a> diagram. Despite my excessively detailed blog posts I neglected to document why I changed to /M1, but I believe it’s because I only wanted execution accesses to ROM to trigger the flip-flop. If I’d stuck with /MREQ then A19 would be settled low before /MREQ goes low, and this would have gone a bit smoother.</p>
<p>The consequence of all this is that the ROM overlay DFF is reset before the first memory read even happens, and ROM never gets read.</p>
<p>The good news is that there’s a simple fix to get the ROM overlay active at boot: I’ve put a 10kΩ 0603 resistor between the A19 and GND pins of the CPU socket, underneath the board. This pulls A19 low during reset, and it’s still low when /M1 falls for the first opcode fetch. Thereafter, the CPU continues to hold A19 low for each access.</p>
<p>With this fix in place, the LED starts to blink at twice the speed. I now have a computer that can run code!</p>
<h1 id="communication">Communication?</h1>
<p>After adjusting the clock speed the boot code’s next task is to set up ASCI0. As the ROM progresses from here it prints out the character sequence ‘1234567’, with each character indicating successful completion of another step of the boot-up.</p>
<p>Perhaps predictably by now, my serial terminal remained stubbornly blank. No output at all - but due to another questionable design choice, I wasn’t sure this meant the boot code was failing to transmit a character or not. This time it was the fact that the /RESET line also resets the FT230X USB IC. This causes the serial port to disconnect and reconnect; the FT230X datasheet doesn’t specify a time range for this but it will read the internal memory to configure the USB descriptors, enumerate as a USB device, and negotiate a connection. That’s enough work to be a non-trivial amount of time.</p>
<p>So - with no way to talk to the CPU to find out what’s going on, I resorted to the logic analyser. My analyser has eight lines, so it cannot monitor the entire bus at once, but it can watch some pins and check they’re behaving. I checked the ROM’s /CE and /OE pins, which were firing properly. I checked, rechecked, triple checked, and dispiritedly checked the ASCI0 lines to the FT230X. Without a reset button, I resorted to five second samples at a slow rate, before finally cluing in that I could pull /WAIT low through the bus header, and freeze the CPU to inspect what it was doing.</p>
<p>Freezing the CPU after it had run for a little while showed it had gone out to lunch in the middle of memory where no predictable value could be expected. It also showed that the transceiver pin for A12 was poorly soldered, but while that needed fixing it wasn’t in a position to be causing any faults.</p>
<p>Freezing the CPU before it finished the first opcode fetch showed the right values on address and data lines.</p>
<p>So - somewhere in between the first byte read, and thousands of cycles later, the CPU goes a bit nuts.</p>
<h1 id="debugging-a-cpu-board">Debugging a CPU board</h1>
<p>It’s impractical to try and whip a jumper lead in and out of the /WAIT header and expect to see anything meaningful going on. However, my board has a powerful tool available on in the form of the FPGA. Most of the board’s signals are connected to an FPGA pin so it has broad insight into the workings of the CPU. It also has a view of the /WAIT signal.</p>
<p>What it does need is a way to tell me what’s going on. Since the FPGA is expected to eventually run an I2C bus, I thought it’d be convenient to give it an I2C slave interface for a µC to drive. The FPGA can drive /WAIT low when /MREQ or /IORQ falls, capture address and data lines, and send all that information to the µC in a four byte burst.</p>
<p>Rather than trying to greenfields my own I2C module, I read over a handful of existing implementations. In the end I used one by Daniel Beer that has <a href="https://dlbeer.co.nz/articles/i2c.html">a truly excellent explanation</a>. Since it’s unlicensed, my FPGA code for this single step debugger is unpublished, but it’s not rocket surgery. I did get to learn about crossing clock domains though, to have an effective signal between an I2C event indicating the CPU should proceed to the next instruction and the CPU’s <em>much faster</em> clock cycle.</p>
<p>This work uncovered a bad solder job on A5 of the FPGA, which I also fixed. And amazingly, I had completely failed to solder one side of one of the I2C pull-up resistors. I hope that’s it for bad solder jobs, because the volume of them makes a mockery of the amount of connectivity testing I did.</p>
<p>The FPGA sends /MREQ, /IORQ, /RD, /RW, and the high four bits of the address bus in the first byte. The next two bytes are the rest of the address bus, and the data bus follows. After all four bytes have been read, the CPU is permitted to proceed.</p>
<p>On the µC side of things I just used an ESP8266 as a convenient 3v3 device, and programmed it using Arduino IDE. After a few iterations I wound up with something that could single step, run a number of steps, run to an address access, and set breakpoints. Its output looks something like this:</p>
<pre><code>MiRw 0016D  ED (11101101)
MiRw 0016E  39 (00111001)
MiRw 0016F  38 (00111000)</code></pre>
<p>… which is the CPU fetching and executing <code class="sourceCode z80"><span class="bu">out0</span> (CBR), <span class="at">a</span></code>.</p>
<p>The debug tool showed that without a USB connection, the boot ROM pauses waiting for the transmit data register empty (TDRE) flag to be set for ASCI0. When that flag is set, the CPU writes ‘1’ - and the serial terminal receives it. This confirms my hunch that the USB IC is still resetting when the CPU starts writing to it. And confirms that the serial link works!</p>
<p>I had mixed up my boot code somehow and tried to do the MMU work right in the middle of setting up the DMA registers. Once I fixed this, I could watch the DMA executing its copy loop, reading from ROM and writing to RAM byte by byte.</p>
<p>I also discovered that the MMU base registers are added to the logical address: if Common Area 1 starts at <code class="sourceCode z80"><span class="bn">$F000</span></code> with a base register of <code class="sourceCode z80"><span class="bn">$80</span></code> the physical address is <code class="sourceCode z80"><span class="bn">$8F000</span></code>. This makes sense from an implementation perspective - it’s a single 8-bit adder involved - and was an easy fix to set CBAR to <code class="sourceCode z80"><span class="bn">$71</span></code> instead.</p>
<p>The remaining consequences of my choice to use /M1 then became apparent. A memory access to ROM space would set A19 high, with /M1 also high, no problem so far. But the next machine cycle would lower /M1 at around the same time as A19, with enough overlap between them for my flip-flop to be reset. The safest action is to jump to ROM as soon as possible, without allowing any other access to ROM space to happen first.</p>
<p>I re-ordered the boot code to set up the MMU first, jumped to ROM space, ran the DMA copy from there, then jumped back to, in theory, SRAM.</p>
<p>A transmit test that modified code showed that yes, I had code running out of SRAM.</p>
<h1 id="rough-consensus-and-running-code"><del>Rough consensus and</del> running code</h1>
<p>Let’s take a moment to absorb this.</p>
<p>I have a <em>working computer</em>. It has boot ROM, working memory, and enough peripherals for me to interact with it.</p>
<p>There’s plenty more to do from here, the Y-modem upload doesn’t work, I have nothing useful to upload, the FPGA isn’t capable of self-programming yet, and there are other boards I expect to add on over time. There’s even a laundry list of things I’d do differently on a second revision of the CPU board.</p>
<p>But none of that matters just as this exact moment: demonstrating running code on the board means this project is now a success.</p>
<p><img src="/images/trs20/logo.svg" /></p>]]></summary>
</entry>
<entry>
    <title>The TRS-20 - Finishing assembly</title>
    <link href="https://bje.id.au/blog/posts/trs20/014-finish-assembly.html" />
    <id>https://bje.id.au/blog/posts/trs20/014-finish-assembly.html</id>
    <published>2020-07-21T00:00:00Z</published>
    <updated>2020-07-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I claimed in the last post that, with blinking lights achieved, the job was done.</p>
<p>Of course, the job is not really done. Most of the board’s parts aren’t soldered on, and while it’s great that the FPGA works I’ve still yet to get the CPU on. Not to mention all the supporting chips. Time to break out the heat gun and get on with the task.</p>
<!--more-->
<p>I put on the FT230X USB IC first, plus its supporting connector and passives. This is for two reasons: I can program the GPIOs on it to ensure the correct VBus sense function and LED output, and because this is the last checkpoint beore I solder on every other part. This worked out fine - the device enumerates correctly, programs fine, and the RX LED flickers in time to keystrokes via USB serial.</p>
<figure>
<img src="/images/trs20/enumerated.png" alt="My shell history is chockers full of lsusb commands now." />
<figcaption aria-hidden="true">My shell history is chockers full of <code>lsusb</code> commands now.</figcaption>
</figure>
<p>Soldering everything else took a few evenings. My process was to squeeze a blob of solder paste onto the DDPAK tab copper area on a board with a bad FPGA solder job, align the target IC with its pads, then use a toothpick to place a sparing amount of paste on the pins. The heat gun then melts the paste onto the pins, and any faults are touched up with the iron.</p>
<figure>
<img src="/images/trs20/memory-pins.jpg" alt="I really should get some kind of macro lens for this stuff." />
<figcaption aria-hidden="true">I really should get some kind of macro lens for this stuff.</figcaption>
</figure>
<p>The best result was the SRAM. It’s possible there’s not quite enough solder on these pins, but I tested every one - I actually found two cold solder joints on the FPGA during this process - and I’m confident they’re all wetted properly.</p>
<p>The worst result was the 18.432MHz oscillator. I underestimated the difficulty of this job, and wound up with far too much solder on it. Solder from the NC pad reached the ground-connected case, and removing it was difficult. I do not feel confident that this part is healthy now.</p>
<h2 id="install-a-rom">Install a ROM</h2>
<p>The trouble with having finished the soldering is that I don’t much want to blindly power up. The ROM should contain <code>FF</code> endlessly, which will result in the CPU executing <code class="sourceCode z80"><span class="bu">RST</span> <span class="bn">$38</span></code> forever, but it’d be nice to be able to verify in some way that everything’s working as it should. This takes me back to writing a ROM again, but this time for the CPU.</p>
<p>So I wrote a <a href="https://github.com/codebje/trs20-bootrom/blob/master/src/bootrom.asm">ROM image</a> that sets up ASCI0 to 38400 baud, 8n1, and starts transmitting single character “printf debugging” style progress markers. The only things I do first are to disable DRAM refresh, disable external interrupts, and set the clock rate to the full oscillator speed.</p>
<p>After that, the boot ROM attempts to copy ROM into RAM, reset the ROM overlay D flip-flop, configure the MMU, set up a 100Hz timer, set up a stack, then run a very simple boot monitor that permits a binary to be uploaded using ymodem and executed.</p>
<p>Because I really don’t want to yank the PLCC-32 ROM chip in and out frequently, I don’t want too many rounds of corrections. My <a href="https://github.com/codebje/vtrs20">emulator</a> is therefore developing more or less in lockstep with the needs of the boot ROM so that I at least have to implement the same bug twice in more or less the same way to miss it. This is a feat I have accomplished in the past, and it’s surprisingly easy to do.</p>
<p>I burned the ROM, plugged it into the board, and with bated breath powered the board up. Good news: the FLT light doesn’t immediately go on, so there’s no major short circuit anywhere. The FPGA still blinks its LED, and the rest sits there, reminding me that I didn’t design in an obvious indicator of CPU health.</p>
<p>I plugged the USART USB cable in, and …</p>
<p><img src="/images/trs20/whereswally.png" /></p>
<p>… used some adult language.</p>
<h2 id="debugging-a-usb-ic">Debugging a USB IC</h2>
<p>Nothing felt warm. The FLT light was still off. The FPGA was still blinking its LED, now looking more like a taunt than a sign of success.</p>
<p>I busted out the multimeter and did a bit of a probe around, carefully - there’s 3V3 and GND pins right next to each other on the FT230X - only to see all the expected levels. The reset supervisor is not touching /RESET, so it is pulled high by a resistor. The USB cable is delivering ~5V to the voltage divider network. With power removed, I rechecked everything for good solder joints or shorts - everything seems fine.</p>
<p>At a loss, I thought I may as well also test whether the CPU is at least clocking along, so I ran a logic analyser on PHI (and /RESET, to verify the supervisor at the logic level) - and saw only a flat line. The clock was not ticking. It turns out the oscillator just isn’t at all happy, and is not generating any signals. It may still have a short, it may just be toast, either way it’s gotta come off.</p>
<p>I’ve never had much luck desoldering through-hole parts. Solder wick takes a <em>lot</em> of heat to work, and isn’t great even then. My solder sucker was bundled with a cheap soldering iron, and was broken on arrival. I never replaced it. So with a bit of concern that it’d go wrong, I put some heatproof tape on the CPU’s socket and got to work with the heat gun.</p>
<p>To my surprise, I removed the oscillator quite easily. I figured I may as well also remove the FT230X - and this also went far better than I anticipated. Well enough, in fact, that I soldered the removed IC onto a TSSOP-16 breakout board. I replicated the CPU board’s USB circuitry fairly closely on a breadboard, then plugged it in.</p>
<figure>
<img src="/images/trs20/enumerated.png" alt="wat." />
<figcaption aria-hidden="true">wat.</figcaption>
</figure>
<p>The chip is (I think) fine. I can dump its ROM, and I can make an LED flicker by sending to it using the virtual COM port driver.</p>
<p>So I rechecked the CPU board. I checked all the connections into the CPU, which are the only parts I didn’t replicate on the breadboard. I checked all the passives, in case I had a dud resistor or capacitor. Everything looked fine - so, not having much to lose here, I desoldered the poor IC from the breakout board and resoldered it to the CPU board.</p>
<figure>
<img src="/images/trs20/whereswally.png" alt="I admit I felt a little glum." />
<figcaption aria-hidden="true">I admit I felt a little glum.</figcaption>
</figure>
<p>Well, that’s it. I can’t communicate with the CPU, I can’t see if it’s working, I’ve no idea what I could possibly do. I am unwilling to risk the price of another board assembly when there’s no apparent reason for failure.</p>
<p>I packed everything away, and nearly didn’t even write this post.</p>
<h2 id="the-next-day">The next day</h2>
<p>The only substantive difference between the breadboard setup and the CPU board setup is my admittedly less than perfect USB socket. So after <del>sulking</del>sleeping on it I tried measuring voltage levels on the breadboard vs. on the CPU board. I ran the USB socket without the main USB power applied to the board: this <em>in theory</em> is perfectly fine, as the FT230X tolerances are absolute, not expressed in terms of its supply voltage. But what I noticed was that VBUS was running at 2V, and D- at -0.5V, relative to ground supplied via the data USB. I checked an unconnected USB socket and got 5V and 0V respectively, with D+ at 3.3V. Hmm.</p>
<p>I reconnected the supply power for the CPU board, and re-measured. Now I saw 5V, 3.3V, and 0V for VBus, D+, and D-, which seemed right. At a loss, I tried one last thing:</p>
<figure>
<img src="/images/trs20/enumerated.png" alt="Why do you taunt me so?" />
<figcaption aria-hidden="true">Why do you taunt me so?</figcaption>
</figure>
<p>It was enumerating again.</p>
<p>This should feel like a victory, but in truth it does not. I don’t know why it didn’t work, I don’t know why it started working, I don’t know whether it will stop working again in the future. But I ordered a replacement oscillator, and may as well press on.</p>
<figure>
<img src="/images/trs20/assembled%20board.jpg" alt="The fully assembled board." />
<figcaption aria-hidden="true">The fully assembled board.</figcaption>
</figure>]]></summary>
</entry>
<entry>
    <title>The TRS-20 - ROM programming</title>
    <link href="https://bje.id.au/blog/posts/trs20/013-program-roms.html" />
    <id>https://bje.id.au/blog/posts/trs20/013-program-roms.html</id>
    <published>2020-07-10T00:00:00Z</published>
    <updated>2020-07-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>The <a href="/posts/trs20/012-build-it.html">last post</a> left off after soldering on the FPGA and its companion parts: the SPI Flash ROM, the 100MHz oscillator, all the power parts, and the programmable LEDs. The only way to know if it’s been designed properly and attached to the board without error is to have it do something observable, like control the LEDs. And the only way to do that is to program the SPI ROM.</p>
<p>The easy way is to order a ROM programmer that can handle SPI Flash ROMs (and, preferably, also handle the parallel ROM). But what would I learn from that?</p>
<!--more-->
<p>Instead, let’s use my STM32 “black pill” board as a programmer, using the USB serial interface to control it. The STM32 is a 3.3v board with an on-die SPI controller - with only one hitch. My black pill no longer powers up. I’ve no idea why, it seems to be failing to get power through the USB C socket, but there’s nothing wrong by a visual inspection.</p>
<p>Oh well.</p>
<p>The idea works well enough for me that I don’t want to just leave it there. Instead, I’m replacing my black pill board with a Nucleo-64, specifically the NUCLEO-F411RE. This is a slightly improved IC compared to the black pill’s STM32F401CC, and the Nucleo board is likely to be a higher quality product than a $6 part from an anonymous manufacturer. The Nucleo-64 board format has enough pins for me to directly program the parallel ROM without using shift registers.</p>
<h1 id="spi-flash-wiring">SPI Flash wiring</h1>
<p>Pin selection for the SPI ROM is a little fiddly, as STM32CubeMX presents me with an image of the IC’s pins, but I care about the board’s layout. The ’F411 has five SPI peripherals, and each peripheral has a few options for pins; after not too much time I’d selected SPI3 using pins PC10, 11, and 12 for SCK, MISO, and MOSI respectively. These pins are all grouped together on a pair of pin headers on one side of the board, close enough to the power pins that a <a href="https://docs.wemos.cc/en/latest/d1_mini_shiled/protoboard.html">D1 protoshield board</a> with a 2x8 female header can cover GND, 3V3, the three SPI pins, and an arbitrary pin (PD2) for slave select.</p>
<p>The circuit on the protoshield is trivial - a pull-up for /CS and a socket for the ROM - and you can see my handiwork in the image at the top of the post.</p>
<p>I won’t go into detail on the code work involved. I wrote a simple <a href="https://github.com/codebje/romble/blob/master/Src/flashrom.c">interface</a> for the Flash ROM, and implemented a <a href="https://github.com/codebje/romble/blob/master/Src/ymodem.c">YModem</a> receiver so I could upload over the ST-LINK’s USB serial port.</p>
<p>I burned on a simple image that just sets one LED to be always off, and binds the other to the 100MHz oscillator’s input via a 26-bit counter. This is around a 1.5Hz blink - if it works.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> poc<span class="op">(</span>CLK1<span class="op">,</span> LED1<span class="op">,</span> LED2<span class="op">);</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">input</span> CLK1<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">output</span>              LED1<span class="op">,</span> LED2<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assign</span> LED1 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">reg</span> <span class="op">[</span><span class="dv">25</span><span class="op">:</span><span class="dv">0</span><span class="op">]</span>          counter<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">reg</span>                 toggle<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">always</span> <span class="op">@(</span><span class="kw">posedge</span> CLK1<span class="op">)</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        counter <span class="op">&lt;=</span> counter <span class="op">+</span> <span class="bn">1&#39;b1</span><span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assign</span> LED2 <span class="op">=</span> counter<span class="op">[</span><span class="dv">25</span><span class="op">];</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">endmodule</span></span></code></pre></div>
<p>While I was at it, I figured I may as well make two images like this, one with <code>assign LED1 = 0;</code> and the other with <code>assign LED1 = 1;</code>. <a href="http://bygone.clairexen.net/icestorm/">Project IceStorm</a> supports multi-image bitstreams, so I can exercise my boot selector jumpers as well.</p>
<p>After straightening the ROM’s pins back out (use a removal tool: flat tweezers are excellent, fingers are not) and plugging it into the main board, well:</p>
<video controls="true" autoplay="true" loop="true" style="width: 100%">
<source type="video/mp4" src="/images/trs20/blinky-led.mp4">
</video>
<p>I stared at a blinking light for a somewhat absurd amount of time. The FPGA works. The oscillator works. The ROM works. The power works. Job more or less done!</p>
<h1 id="the-parallel-rom">The parallel ROM</h1>
<p>I thought about how I might want to do this. A neat job would be female headers on a board for the Nucleo to plug into, programming the ROM IC in a PLCC socket beside it. I could add a DIP8 socket and have a programmer for both ROMs in short order. But this is a lot of jumper wires to mess about with, and frankly I’m not really keen on it. So - pretty much every jumper lead I have is now in Frankenprogrammer.</p>
<figure>
<img src="/images/trs20/plcc-programmer.jpg" alt="So much better than a TL866II, right?" />
<figcaption aria-hidden="true">So much better than a TL866II, right?</figcaption>
</figure>
<p>I hope to minimise my programming cycles - I need to work out how I can verify the whole CPU board is good, then work on producing enough of a ROM that I can boot up to something that’ll program other parts of the ROM over USB. PLCC sockets are only good for a few tens of insertions, so I want to be bootstrapped on-board ASAP.</p>
<p>Next up: completing the CPU board assembly.</p>]]></summary>
</entry>
<entry>
    <title>The TRS-20 - Assembling the board</title>
    <link href="https://bje.id.au/blog/posts/trs20/012-build-it.html" />
    <id>https://bje.id.au/blog/posts/trs20/012-build-it.html</id>
    <published>2020-06-26T00:00:00Z</published>
    <updated>2020-06-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I have all my parts, I have my boards, it’s time to assemble this thing. I’ll be starting with the highest risk components first, on the grounds that if I muck up I will have less to replace to try again.</p>
<!--more-->
<h2 id="soldering-round-one">Soldering, round one</h2>
<p>I’ve attempted the iCE40 IC first, as the most likely to fail. And indeed, it hasn’t gone at all well. There were terrible solder bridges on two sides, and while I’ve eventually figured out the technique for dealing with these I’ve applied substantial heat to get there. The board looks in good nick, perhaps due to the two large inner copper planes wicking heat away, but there’s a persistent short from 3.3V to GND that, obviously, is a deal-breaker. I’ve tested the other four boards and they’re all short-free so it’s very likely this is a soldering issue. I found and removed another short on two address lines, and think everything else is clear (no test points - a board design issue), but I don’t even know which of the supply/ground pin pairs has the short. I fear it may have somehow happened beneath the IC where I can’t see it, or with excess heat down a ground via delaminating the board enough for solder to worm its way to a connection with the power layer. It may just be solder sitting sneakily behind some pins, but there’s only two supply pins that are adjacent and I’ve inspected the everloving out of them both.</p>
<figure>
<img src="/images/trs20/dodgy-solder.png" alt="That big one on the left I’ve nicknamed ‘The Bridge of Sighs’." />
<figcaption aria-hidden="true">That big one on the left I’ve nicknamed ‘The Bridge of Sighs’.</figcaption>
</figure>
<p>I’ve ordered three more FPGAs, and I’ll try again, armed perhaps with a greater fear of excessive solder paste, a new multimeter that doesn’t have one lead replaced by an alligator clip holding a screw, and my improved techniques for fixing small bridges. They won’t arrive until the end of the week, so I’ve put board assembly aside for now.</p>
<h2 id="programming-roms">Programming ROMs</h2>
<p>I have two ROMs to program: the bitstream to configure the FPGA (assuming I ever get it soldered on safely) and the boot/BIOS ROM. The bitstream ROM is programmed over SPI, and is a DIP-8 in a socket. I’m fairly confident I can solder up something to program bitstreams using my STM32F401 black pill board. The boot/BIOS ROM is a bit more difficult, as it’s a parallel device with 18 address pins, 8 data pins, and a little assortment of control pins. I’ll need shift registers to handle this. Luckily I have a little pile of 74HC595s lying around unused. Two of those gives me 16 of my 18 address pins at the cost of two µC pins, and two more for A<sub>16</sub> and A<sub>17</sub>. I can wire up the µC directly to the data pins, and to /OE and /WR, and I’ve only used 14 pins.</p>
<p>I will load up a perfboard with sockets, and then have to figure out how to have the STM32 read a programming bytestream over USB serial. But this can wait while I perform main board assembly - I don’t need more parts, just more time.</p>
<p>I’m also slowly working on a TRS-20 emulator, so I can crack on with writing a boot ROM that’s got a halfway decent chance of actually running on the real deal.</p>
<h2 id="soldering-round-two">Soldering, round two</h2>
<p>My replacement FPGAs arrived earlier than expected. I got in plenty of practice on the first board for dealing with 0.5mm pitch pins using an iron and absurd amounts of flux, so I thought I’d try drag soldering one. Now I have two badly soldered FPGAs on two boards. I don’t really think it’s worth trying to fix the second IC it’s that bad, and the first has been subject to so much heating and cooling and <em>still</em> has a sneakily hidden bridge somewhere between 3V3 and GND.</p>
<p>I tried a third FPGA on a fresh board. I have one spare FPGA and two spare boards. This time, I carefully lined up the IC then used a toothpick to put as little solder paste on as I could, then cracked in with the heat gun. There were a few bridges left, but this time I was able to get in and clean them up without using crazy heating cycles. I’ve checked all 100 pins to confirm they’re connected to what they should be, and not to what they shouldn’t be, and it’s all looking good.</p>
<p>So I got stuck into getting a few more components on the board. I have <em>absolutely no idea</em> if my 100MHz oscillator is on right. It’s a tiny QFN - the only no-lead part on the board - and I can see that at least two pads are soldered, the others <em>probably</em> are, and maybe it doesn’t have bridges, or heat damage from the hot air gun. I can’t really test it, and I didn’t have any particular use for it.</p>
<figure>
<img src="/images/trs20/power-components.png" alt="100 0.5mm pitch pins soldered neatly - and a handful of capacitors on crazy angles." />
<figcaption aria-hidden="true">100 0.5mm pitch pins soldered neatly - and a handful of capacitors on crazy angles.</figcaption>
</figure>
<p>The 1.2V regulator is a DDPAK, an absolutely enormous beast of a part. It features a large tab for heat transfer, and again I can’t see underneath it to know if solder paste melted or not. The DDPAK is designed to dissipate heat, so it fights every step of the way when soldering. Even the three pins wick heat magically away into the large copper pours and are difficult to solder. It’s on - but the tab might not be soldered down as well as it should be.</p>
<p>I am filled with regrets about choosing to use 0603 bypass capacitors, they’re fiddly. I’ve put on a half dozen or so, plus a few larger capacitors around the power management. My goal is to get enough soldered on to verify the power circuitry, and then to verify the FPGA is on safely, so I’ve done the DDPAK, the eFuse, and capacitors. I’ve yet to do the resistors, diode, and the R-78 3.3V regulator, more caps, and perhaps the MIC803.</p>
<p>That’s all for another day.</p>
<h2 id="soldering-round-three">Soldering, round three</h2>
<p>It is another day. I’ve pressed on, popping on a stack of resistors for the LEDs, eventual I2C bus pull-ups, CDONE pull-up, and power management resistors. I’ve finished off all the capacitors for the regulators, the FPGA, and its ROM. I’ve added the ROM’s socket, and an unprogrammed ROM is sitting in it, tempting fate. I’ve also added the power USB port, which in hindsight I should have done before the whopping great big capacitor that made access to the USB pins much harder than I’d have liked. All of it went pretty well, I only lost one 0603 resistor (and found it again when cleaning up, amazingly), most of my parts aren’t on <em>too</em> crooked, and there’s no shorts or, as far as I can determine, bad joints.</p>
<p>And finally, I added one LED, the power indicator LED. This is my first SMD LED, and finding the polarity of these parts proved a little harder than I’d expected. The data sheet said the underside would indicate the cathode with a single horizontal line, but the actual underside had a turnstile symbol instead. I wound up relying on the advice in the sheet that the anode is closest to the holes on the tape.</p>
<p>It is time to apply power. If I’ve done anything wrong in design or assembly, magic smoke will now escape.</p>
<h2 id="powering-up-round-one">Powering up, round one</h2>
<p>I pushed the USB cable into the socket, fearing the worst, hoping for the best. Today, I got the best: the power LED lit up. The board has juice! This LED is wired straight to the USB power supply, so it tells me that I don’t have a critical short somewhere, and that I do have a successfully soldered USB port, resistor, and correctly oriented LED. That’s quite a moment, but not the end of the story, not just yet.</p>
<figure>
<img src="/images/trs20/power-on.jpg" alt="Just an LED - and an important milestone." />
<figcaption aria-hidden="true">Just an LED - and an important milestone.</figcaption>
</figure>
<p>I have two regulators and a voltage divider network in my power circuitry. The RECOM should be converting the 5V supply from USB via the eFuse into 3.3V, while the DDPAK linear regulator supplies 1.2V from the same source. I gave them both a probe with the multimeter, and to my delight, both are showing the expected levels. The voltage divider for the MIC2774 reset controller is also performing properly, delivering 315mV to the 300mV comparator input. Nothing is unduly warm, so I feel confident in declaring my power circuitry design and assembly a success.</p>
<p>I have no idea just yet whether the FPGA, ROM, and 100MHz oscillator are in a good place. Tomorrow’s soldering task will be to add the remaining LEDs (including the two USR LEDs wired to the FPGA), the MIC803 supervisor, and the pull-up for the ROM’s Slave Select that I missed - U20 and R13 in the above image. After that I’ll choose between testing the FPGA out before committing RAM, ROM, and CPU, or pressing on with the actual computer part of this circuit.</p>
<p>The ROM programmers are becoming more important with every additional blob of solder hitting the board.</p>
<h2 id="soldering-round-four">Soldering, round four</h2>
<p>This time I’m methodically placing capacitors and resistors, aiming to complete all of each particular size. I’ve knocked out the 0.1µFs, although one is dangerously close to forming a bridge and needs fixing. I’ve put on all the 10kΩ and 2.2kΩ resistors - including deciding that I would use 10kΩ for the /INTx pull-ups instead of 2.2kΩ. I’ve finished all the LEDs off, five are the yellow-green diffuse diodes and three are green low-current clear. The clear LEDs have a dome on top which makes them a little fiddly to hold in place for hand soldering, but didn’t give too much trouble. I also put in the MIC803, which I realised I’d made harder for myself by soldering the SPI Flash socket in place first. There wasn’t much room to get in and heat it up, and it took a few goes to ensure the pin near the socket was adequately wetted.</p>
<p>I put on the 10kΩ resistor R12, which forms part of the voltage divider for VBUS sense on the FT230X USB chip. Since the FT230X isn’t currently programmed for VBUS sense, this means I’ve wired up an output chip with a resistor into GND, and this will draw 0.33mA current when that output is HIGH. I need to be careful not to solder on R11 until I’ve programmed the IC.</p>
<p>Foolishly, I also soldered on the PLCC-32 socket. Progress is barely visible after doing a few tens of 0603 parts, so I wanted some big visible progress in place. However, this is now going to get in the way for soldering the ICs close to the socket: U1 and U30 are SOIC8 ICs with one side of pins each about 7mm away from the socket. They’re handsolder pads, at least, so it should be okay, but I need to take the lesson to heart and not rush in to the big parts until I’ve dealt with the parts needing easier access.</p>
<p>Sadly, on power-up my LEDs didn’t light up as expected. 5V is still lighted, which is good news, but 3V didn’t light up while both USR LEDs wired to the FPGA did, albeit not as bright as the others. Since my understanding of the FPGA is that every IO pin goes Hi-Z during configuration, this seems like terrible news - if power is coming through that IC might be on the fritz. I re-read the iCE40 Programming and Configuration Guide, which does definitely say those pins are Hi-Z with pull-ups. The iCE40 family data sheet says both that I/O pins default to weak pull-down and weak pull-up, depending on which part of the sheet you’re at, but clearly these two pins at least are not wired to GND. There are 2.2kΩ resistors on those LEDs already, so for them to be visibly lit up the weak pull-up resistors can’t be that weak - or the FPGA might still be on the fritz.</p>
<p>The 3V LED was nothing more serious than a bad solder joint on one side, easily fixed.</p>
<p>At this point I’m confident that everything on the board so far has been soldered on correctly (if not necessarily neatly) but I have some doubts about whether the FPGA is still good, or if it’s been fried by clumsy handling or soldering. My next work is therefore going to focus on programming the SPI Flash ROM with a bitstream that can demonstrate the FPGA is good.</p>
<h2 id="errata">Errata</h2>
<ul>
<li>U7 has four floating pins that will become inputs if /BUSACK is active, and four pins that will be outputs wired directly into ground. I can perhaps fix it by also wiring the floating pins to ground - without doing that, using /BUSRQ might result in a short through the ’245 buffer.</li>
<li>There’s no solder mask between the pins of most of my SMD ICs. It’s not a critical failure by itself, but it significantly increases the risk of solder bridges. This may have contributed to my difficulty with the iCE40, and may cause problems for the 0.65mm pitch ICs I have yet to do.</li>
<li>The reset button. I didn’t check pins on this part, and they’re wrong. When the button is soldered on the reset input on the supervisor is always pulled low. I may try to jury rig something down the line, but for now I will just go without.</li>
</ul>
<h2 id="potential-improvements">Potential improvements</h2>
<ul>
<li>Yanking a USB cable in and out for power is not great. I considered a power toggle switch, but chose to omit it - I think putting one in would be a substantial improvement.</li>
<li>The FPGA’s default pin state includes pull-ups; the USR LEDs are on at boot, until configuration is complete. Inverting these LEDs to be wired to +3.3V with an open drain pin configuration would prevent this.</li>
<li>The CBSEL jumpers could have been spaced 2.54mm apart and used a double row pin header, or perhaps DIP switches, though I wanted something with low chance of mechanical failure.</li>
<li>There’s a row of resistors for pull-ups that could have been replaced by two resistor arrays to take a bit less board real-estate up. Fixing U7’s floating and shorted pins will require resistor arrays to fit without major board layout changes.</li>
<li>The 100MHz oscillator in a QFN package is difficult, as I expected it would be. It’s also more important than I counted on, as it’s the only available clock for the FPGA without the processor’s PHI output. Using a bigger package for this oscillator would be a good change.</li>
</ul>
<h2 id="budget-summary">Budget summary</h2>
<p>The budget is blown. I bought three more iCE40HX1Ks to cope with my first failure at soldering, I forgot I needed PLCC-32 sockets, and for the ROM programmer I’ve also had to buy replacements for failed parts. I’ll track my total spend and when I’ve either succeeded or admitted defeat on the CPU board I’ll tally the cost in parts for just the board, but I will no longer pretend I’m going to build a retrocomputer for $400.</p>
<table style="width:65%;">
<caption>Project status update</caption>
<colgroup>
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 10%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">CPU</th>
<th style="text-align: center;">Power</th>
<th style="text-align: center;">Keyboard</th>
<th style="text-align: center;">Video</th>
<th style="text-align: center;">Memory</th>
<th style="text-align: center;">Debug</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">███─</td>
<td style="text-align: center;">done</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">███─</td>
<td style="text-align: center;">done</td>
</tr>
</tbody>
</table>]]></summary>
</entry>

</feed>
