<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Typed Out</title>
    <link href="https://bje.id.au/blog/atom.xml" rel="self" />
    <link href="https://bje.id.au/blog" />
    <id>https://bje.id.au/blog/atom.xml</id>
    <author>
        <name>Byron Ellacott</name>
        <email></email>
    </author>
    <updated>2020-02-19T00:00:00Z</updated>
    <entry>
    <title>The TRS-20 - boot up</title>
    <link href="https://bje.id.au/blog/posts/trs20/009-boot-it.html" />
    <id>https://bje.id.au/blog/posts/trs20/009-boot-it.html</id>
    <published>2020-02-19T00:00:00Z</published>
    <updated>2020-02-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>My 128 bytes each of ROM and RAM are working: the Z180 is executing my code.</p>
<!--more-->
<p>With my test rig re-wired using 22AWG wire (from a kit, I don’t have a nice stock of the stuff to trim to length myself yet) and looking neat, despite still only having eight address lines, I fired the thing up. Not pictured is a small extension that ties RESET high with a 10k resistor and adds a tactile switch to pull it low, as the Z180 doesn’t really behave properly without being reset.</p>
<p>The <a href="https://github.com/codebje/trs20-debug/blob/fe11a903a1df9553ae3c87e779e340607668d3f4/trs20.asm">code</a> that should be executed disables DRAM refresh, so my logic analyser images don’t have so much noise in them. After that, it just loops forever not doing anything.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode z80asm"><code class="sourceCode z80asm"><span id="cb1-1"><a href="#cb1-1"></a><span class="fu">reset:</span>	<span class="dt">.org</span>	<span class="bn">$0000</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>	ld	<span class="at">a</span>, <span class="bn">0</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>	out0	(RCR), <span class="at">a</span>	<span class="co">; disable the DRAM refresh</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>	jp	_start</span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="co">; … other RST vectors omitted …</span></span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="fu">_start:</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>	nop</span>
<span id="cb1-10"><a href="#cb1-10"></a>	jp	_start</span></code></pre></div>
<p>After a reset, the data lines look like this. I’ve added handy little labels for the signals.</p>
<figure>
<img src="/images/boot-from-rom.png" alt="" /><figcaption>On reflection, it probably would have been easier to read as D7:0.</figcaption>
</figure>
<p>Decoding and cross-referencing these binary values with the listing file for the ROM image shows it executing exactly what it should, and it’s apparent that immediately after the <code class="sourceCode z80asm">out0</code> the DRAM refresh ceases, and the CPU repeatedly requests the <code class="sourceCode z80asm">nop</code> and <code class="sourceCode z80asm">jp</code> instructions</p>
<table>
<thead>
<tr class="header">
<th>bits</th>
<th>hex</th>
<th>assembly</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>00111110</code></td>
<td><code>3E</code></td>
<td><code class="sourceCode z80asm">ld <span class="at">a</span>, <span class="bn">0</span></code></td>
</tr>
<tr class="even">
<td><code>00000000</code></td>
<td><code>00</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>11101101</code></td>
<td><code>ED</code></td>
<td><code class="sourceCode z80asm">out0 (RCR), <span class="at">a</span></code></td>
</tr>
<tr class="even">
<td><code>00111001</code></td>
<td><code>39</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>00110110</code></td>
<td><code>36</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>11000011</code></td>
<td><code>C3</code></td>
<td><code class="sourceCode z80asm">jp <span class="bn">$0038</span></code></td>
</tr>
<tr class="odd">
<td><code>00111000</code></td>
<td><code>38</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>00000000</code></td>
<td><code>00</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>00000000</code></td>
<td><code>00</code></td>
<td><code class="sourceCode z80asm">nop</code></td>
</tr>
</tbody>
</table>
<p>I don’t think I’ve convinced friends or family that this is, in fact, quite an exciting milestone. Nevertheless, it is: I have written code that runs on my CPU. The rest of the computer is just details…</p>
<p>The STM32’s usefulness for this stage of the project is, I think, now at an end. It may return as a USB keyboard controller down the line, but this project is ready for PCB design.</p>
<p>Meanwhile, the PC104 headers I ordered arrived, after 84 days. My guess is they fell behind something in Customs and were only recently found. They were very well packed, and are undamaged, so I contacted the seller and placed another order that the seller didn’t ship. Since my refund didn’t include the tax I paid, and my new order did, I’ve now paid twice the tax on the headers, taking their total cost up to $12.70 for five 40-pin headers and two 64-pin headers. My stand-offs also arrived, so there’s now nothing in transit.</p>
<p>I also ordered and received an Altera MAX II CPLD minimal development board, for $11.56. This board saves me a lot of fiddly soldering making my own on perfboard, and will let me trial the use of a relatively cheap CPLD IC for address decoding or video output. I booted up Intel’s Quartus II to a sufficient level to verify the board works - to cut a long story short on it, it’s just a lot easier on a Mac to run Quartus in a desktop Linux VM than it is to try to make it work in Docker.</p>
<p>I’m going to mark the Debug section of the project as complete. It’s possible I’ll need further debugging aids later in the project, but each quarter I’ll want to review my targets and check they still make sense given what I’ve learned so far.</p>
<table style="width:86%;">
<caption>Project status update</caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 10%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Budget</th>
<th style="text-align: center;">CPU</th>
<th style="text-align: center;">Power</th>
<th style="text-align: center;">Keyboard</th>
<th style="text-align: center;">Video</th>
<th style="text-align: center;">Memory</th>
<th style="text-align: center;">Debug</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">$233.61 of $400</td>
<td style="text-align: center;">██──</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">done</td>
</tr>
</tbody>
</table>]]></summary>
</entry>
<entry>
    <title>Testing STM32 code</title>
    <link href="https://bje.id.au/blog/posts/trs20/008-test-it.html" />
    <id>https://bje.id.au/blog/posts/trs20/008-test-it.html</id>
    <published>2020-02-09T00:00:00Z</published>
    <updated>2020-02-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>There’s now code worth testing in my project: address line decoding. Let’s take another sidebar journey into automated testing of embedded code, and see where it leads.</p>
<!--more-->
<p>I’ve been claiming loudly for a while now that there’s no good reason to begin any new projects in C when there’s Rust available instead, and that there’s precious little reason for new projects in C++, barring libraries you just cannot expose to Rust and cannot live without. As a result, this project is done in Rust.</p>
<p>The basic problem facing me is that I’m extremely inexperienced with ARM assembly and the Thumb-2 instruction set. I’d like to be able to test my ideas and expectations before flashing code to my device, which means I want to execute my code on my development host.</p>
<p>I originally considered firing up <a href="https://www.qemu.org/">QEMU</a>. The current master branch has support for one STM32F4 processor, so it’s not an outrageous stretch to build a black pill emulator, but the support is threadbare and QEMU isn’t set up for being a unit test executor.</p>
<p>My <a href="https://github.com/codebje/rustmtest/">solution</a> uses the <a href="http://www.unicorn-engine.org/">Unicorn engine</a>, which is backed by QEMU, to set up the memory map of an STM32F401. I then load my ELF intermediate output, which has a symbol table, and copy the loadable segments into the emulator’s memory.</p>
<p>Tests are defined as a DSL that specifies the input and output register states, and selects a symbol to call.</p>
<p>The GitHub workflow for this project builds a binary, automatically tags a new release if the version number in <code>Cargo.toml</code> has changed, and publishes the binary to the release.</p>
<p>I can now take this local function for breaking my 8 bits of address space out of port B and into an address in either RAM or ROM:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode armasm"><code class="sourceCode armasm"><span id="cb1-1"><a href="#cb1-1"></a>        .type           memaddr, %function</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="fu">memaddr:</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>        // the memory address is in PB0:<span class="bn">1</span>, <span class="bn">5</span>:<span class="bn">10</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>        movw            <span class="at">r2</span>, <span class="bn">0</span>b11111100</span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a>        // top <span class="bn">6</span> bits into <span class="at">r1</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>        and             <span class="at">r1</span>, <span class="at">r2</span>, <span class="at">r0</span>, lsr <span class="bn">3</span></span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a>        // assemble full address into <span class="at">r0</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>        and             <span class="at">r0</span>, <span class="at">r0</span>, <span class="bn">0</span>b11</span>
<span id="cb1-11"><a href="#cb1-11"></a>        orr             <span class="at">r0</span>, <span class="at">r1</span>, <span class="at">r0</span></span>
<span id="cb1-12"><a href="#cb1-12"></a></span>
<span id="cb1-13"><a href="#cb1-13"></a>        // check if RAM or ROM</span>
<span id="cb1-14"><a href="#cb1-14"></a>        movw            <span class="at">r1</span>, <span class="bn">1</span></span>
<span id="cb1-15"><a href="#cb1-15"></a>        eors            <span class="at">r1</span>, <span class="at">r1</span>, <span class="at">r0</span>, lsr <span class="bn">7</span></span>
<span id="cb1-16"><a href="#cb1-16"></a></span>
<span id="cb1-17"><a href="#cb1-17"></a>        ite             eq</span>
<span id="cb1-18"><a href="#cb1-18"></a>        ldreq           <span class="at">r2</span>, =RAM_BASE</span>
<span id="cb1-19"><a href="#cb1-19"></a>        ldrne           <span class="at">r2</span>, =ROM_BASE</span>
<span id="cb1-20"><a href="#cb1-20"></a></span>
<span id="cb1-21"><a href="#cb1-21"></a>        <span class="kw">add</span>             <span class="at">r0</span>, <span class="at">r0</span>, <span class="at">r2</span></span>
<span id="cb1-22"><a href="#cb1-22"></a></span>
<span id="cb1-23"><a href="#cb1-23"></a>        <span class="kw">bx</span>              <span class="at">lr</span></span>
<span id="cb1-24"><a href="#cb1-24"></a></span>
<span id="cb1-25"><a href="#cb1-25"></a>        .size           memaddr, . - memaddr</span></code></pre></div>
<p>… and confirm that my use of unfamiliar instructions like <a href="http://infocenter.arm.com/help/topic/com.arm.doc.kui0100a/armasm_cjabicci.htm">ite</a> work the way I expect with a test script:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode armasm"><code class="sourceCode armasm"><span id="cb2-1"><a href="#cb2-1"></a><span class="fu">test:</span> Memory Address decode</span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="fu">setup:</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    <span class="at">r0</span> = <span class="bn">0</span>b10111011101</span>
<span id="cb2-5"><a href="#cb2-5"></a></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="fu">call:</span> memaddr</span>
<span id="cb2-7"><a href="#cb2-7"></a></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="fu">check:</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="at">r0</span> = <span class="bn">0</span>x200000b9</span>
<span id="cb2-10"><a href="#cb2-10"></a>    <span class="at">r1</span> = <span class="bn">0</span></span></code></pre></div>
<p>It’s easy to also wrap a download of the released binary from GitHub into an action in the <a href="https://github.com/codebje/stm32-debug/">RAM/ROM project</a> and have automatic unit testing take place.</p>
<p>Constantly practicing repeatable and automated processes for building, testing, and deploying makes it easier and more habitual to do for everything. I may have lost two or three days of STM32F4 assembly coding time in writing my test executor and its workflow actions, but I’ve gained a lot more confidence that the code will work as expected once it hits the μC, and I expect I’ll easily make back that time in fewer mistakes on device, where it’s harder to inspect.</p>]]></summary>
</entry>
<entry>
    <title>The TRS-20 - STM32F4 driver</title>
    <link href="https://bje.id.au/blog/posts/trs20/007-build-it.html" />
    <id>https://bje.id.au/blog/posts/trs20/007-build-it.html</id>
    <published>2020-02-02T00:00:00Z</published>
    <updated>2020-02-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>With my <a href="/post/trs20/006-fake-it.html">plan</a> sorted out, it’s time to get down to code. I’ll set up my build environment, take a look at testing options, configure timers, make a bunch of mistakes, and eventually test my hypothesis that an STM32F4 is fast enough to pretend to be the RAM and ROM for a 1MHz Z180.</p>
<!--more-->
<h2 id="build-first">Build first</h2>
<p>I find it to be good practice for any project to start with the build and deployment processes. I want to be able to evolve my processes as my project evolves, and I don’t want to encounter infrastructure surprises late in the project when everything is more complicated and change is costlier.</p>
<p>My initial build process was a straightforward Makefile to build a single assembly source file with a single <code class="sourceCode armasm"><span class="dt">.text</span></code> section and link it as per the <a href="http://www.martinhubacek.cz/arm/arm-cortex-bare-metal-assembly/stm32f0-cortex-m0-bare-metal-assembly">Cortex M0 example</a> I mentioned in the last post. This got me far enough to inspect binary outputs, which leads to understanding why my assembly sources should begin with the following three directives.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode armasm"><code class="sourceCode armasm"><span id="cb1-1"><a href="#cb1-1"></a>        .thumb</span>
<span id="cb1-2"><a href="#cb1-2"></a>        .cpu            cortex-m4</span>
<span id="cb1-3"><a href="#cb1-3"></a>        .unified</span></code></pre></div>
<p>The STM32F series is based on a Cortex M4 design. The M4 permits two instruction sets, the ARMv7 and Thumb sets - the Thumb set has 32-bit extensions (sometimes called Thumb v2), and the STM32F4 only supports Thumb mode. The directives then tell the assembler to emit Thumb opcodes, to use the set of opcodes supported by the M4, and to use a unified syntax common to both sets as the original Thumb mnemonics kind of sucked.</p>
<p>Switching between ARMv7 and Thumb modes is accomplished with a couple of branch-and-exchange-mode instructions. If the target address has its least significant bit set, then Thumb mode is enabled. Otherwise, ARMv7 mode is enabled. I’ll never use the <code class="sourceCode armasm"><span class="kw">bx</span></code> instructions, but this LSB signal also crops up for the processor’s vector table.</p>
<p>You could simply set the LSB on each address in the vector table with something like <code class="sourceCode armasm"><span class="dt">.word</span> _start + <span class="bn">1</span></code>, but the GNU ARM assembler knows its business and will set the bit for you if you tell it that a symbol is for a function entry point, with <code class="sourceCode armasm">.type _start, %function</code>.</p>
<h2 id="but-what-of-the-tests">But what of the tests?</h2>
<p>Testing embedded code brings some interesting challenges, ones I’m not familiar with. Checking that the code builds and opening up an ELF file in GDB don’t get you a whole lot of assurance. My first thought was to use QEMU to emulate the STM32F4, as this lets me test code without worrying about plugging a device in. Sadly, QEMU does not support any STM32s out of the box, and my Googling found only a project for an STM32F103. Firing up QEMU with some other Cortex M4 based system doesn’t help much, since the M4 is only the processor. The STM32F4 and other M4 based designs are differentiated by their peripherals, including their memory maps. Since my code is linked at 0x08000000, most CPUs won’t even see my vector table or code in the right places.</p>
<p>As it turns out, in the current (as of writing) master branch of qemu, some gentle soul has added an STM32F405 SoC, and a machine built on top of it. It’s quick work to add an STM32F401 SoC and a Black Pill machine to my local checkout, so I now have the capacity to run my ARM code on an emulator for the target device.</p>
<p>Testing chip configuration via an emulator is of limited value though - the emulator’s peripherals all do nothing - so I will leave off any further investigation of automated testing until I have something worth testing.</p>
<h2 id="on-to-the-code">On to the code!</h2>
<p>I’ve refactored my code base to have a separate startup module in <code>start.s</code>, which configures the clocks and then calls <code>main</code>. This code broadly follows the outline of my last post, with the configuration of the APB1 prescaler moved to happen first. This prescaler <em>must</em> be set before the system clock ramps up from 16MHz to 84MHz for the APB1 bus to never exceed 42MHz, but it can take up to 16 AHB cycles for a change to the prescalers to take effect. With a populated pipeline, most STM32F4 instructions take only one cycle.</p>
<p>I’d like to test my clock configuration, so I’ll fire up one of the timers to emit what should be a 1MHz signal. TIM2 is on the supposedly 42MHz APB1 bus, and TIM9 is on the supposedly 84MHz APB2 bus. I’ll test TIM2’s output first. By using channel 3 of TIM2, and channel 1 of TIM9 all my output will be on the same pin, PA2, so I won’t have to change my wiring.</p>
<p>An STM32 timer’s output frequency is governed by its clock frequency, its prescaler, and its period. With a clock of 42MHz and a desired output frequency of 1MHz, this means the prescaler times the period must equal 42. Integer factors of 42 include 6 and 7, which are fine for what I want. This means I’ll set the <code>TIM2_PSC</code> prescale register to 6, and the <code>TIM2_ARR</code> auto-reload register to 5. The minus one happens because the STM32 timers count from zero and do not reset until overflow. A prescale value of 6 means the timer will count <code>[0, 1, 2, 3, 4, 5, 6]</code> and then reset, taking seven time intervals to complete.</p>
<p><span class="math display">\[F = \frac{\mathrm{CK\_INT}}{(\mathrm{TIM2\_PSC} + 1)\times(\mathrm{TIM2\_ARR} + 1)}\]</span></p>
<p>With the timer ticking away at what I expect to be 1MHz, the next task is to produce a square wave on an output pin. There’s an output compare mode in which a pin can be set, reset, or toggled when the timer’s counter reaches a configured value. Using this mode would produce a square wave at 500KHz, so I would have to double the timer’s frequency. Using Pulse Width Modulation (PWM) modes, a duty cycle is established based on the <code>TIM2_CCRx</code> capture/compare register, where <code>x</code> is the channel being used. The <code>OCREF</code> output compare reference signal is high while the timer’s counter is lower than the CCR, otherwise it’s low. By setting <code>TIM2_CCR3</code> to 3, I should see a nice square wave 1MHz signal on the output pin.</p>
<table>
<caption>The subset of registers and bits that must be configured.</caption>
<colgroup>
<col style="width: 12%" />
<col style="width: 6%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Register</th>
<th style="text-align: center;">Bits</th>
<th style="text-align: center;">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">TIM2_CR1</td>
<td style="text-align: center;">CEN</td>
<td style="text-align: center;">Counter enable, set to start the timer.</td>
</tr>
<tr class="even">
<td style="text-align: center;">TIM2_EGR</td>
<td style="text-align: center;">UG</td>
<td style="text-align: center;">Update generation, set by software to reset the timer and update shadow registers.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">TIM2_CCMR2</td>
<td style="text-align: center;">OC3M CC3S</td>
<td style="text-align: center;">Output compare mode. Set to 0b100 for PWM mode 1. Capture/Compare selection. Set to 0b00 for output mode.</td>
</tr>
<tr class="even">
<td style="text-align: center;">TIM2_CCER</td>
<td style="text-align: center;">CC3E</td>
<td style="text-align: center;">Capture/Compare output enable.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">TIM2_PSC</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Prescaler, to be set to 6.</td>
</tr>
<tr class="even">
<td style="text-align: center;">TIM2_ARR</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Auto-reload, to be set to 5.</td>
</tr>
<tr class="odd">
<td style="text-align: center;">TIM2_CCR3</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">Capture/Compare register, to be set to 3.</td>
</tr>
</tbody>
</table>
<p>All of the timer registers are reset to zero except for the auto-reload register which is set to 0xffff ffff. This means any settings I’m not interested in that are safe to leave at zero can be ignored. The code to configure TIM2 is <a href="https://github.com/codebje/trs20-debug/blob/fe11a903a1df9553ae3c87e779e340607668d3f4/main.s#L46">here</a>. It’s time to flash this sucker to a device and see what’s on pin A2.</p>
<p>To flash the device, I’m programming over USB. I could use the SWDIO pins for this, which would give me debugging support too. However, those pins don’t supply power, and I’d need to run the USB cable anyway. The open-source [dfu-util][dfu] tool will program many ST devices, including the STM32F4 using the bootloader. The STM32F4 can be reset to boot from the bootloader by asserting BOOT0 during a reset (with BOOT1 low). The Black Pill board has a button for this purpose, and pulls BOOT1 (aka PB2) low at all times. Programming the board via USB is as simple as holding BOOT and pressing NRST, then using a magic invocation of <code>dfu-util</code> to flash my binary image at the right address, into the right device target.</p>
<h2 id="experiments">Experiments</h2>
<p>Because I have no facility to test register configuration, I’m taking a cautious approach. I’ve commented out all code to write to the clock configuration registers, leaving only the timer output. With the HSI running at 16MHz, I expect to see a signal of <span class="math inline">\(\frac{16\mathrm{MHz}}{42} = ~381\mathrm{KHz}\)</span>.</p>
<figure>
<img src="/images/timers%20-%20flatline.png" alt="" /><figcaption>I’m no electrical engineer, but I’m pretty sure that’s a 0Hz signal.</figcaption>
</figure>
<p>I made several mistakes, which isn’t entirely unexpected. I can’t debug on the device itself, because my st-link clone appears to be broken, possibly fried by my own actions, but I can inspect my code in a debugger.</p>
<p>The first problem is that my linker script wasn’t quite right. You are free to name your output sections anything you like, and I chose <code>.vectors</code> for my vector table. However, that freedom is limited by your output format. In an ELF binary, however, certain section names are magical.</p>
<pre><code>Idx Name          Size      VMA       LMA       File off  Algn
  0 .vectors      0000001c  08000000  08000000  0001803c  2**0
                  CONTENTS, READONLY
  1 .text         000000dc  08000000  08000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00007f60  080000dc  080000dc  000100dc  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.attributes 00000021  00000000  00000000  00018058  2**0
                  CONTENTS, READONLY</code></pre>
<p>As I planned it, my <code>.vectors</code> section is at VMA 0x08000000, hooray. But its flags don’t include ALLOC or LOAD, so the section is never loaded into memory, or flashed onto the device. Instead, the <code>.text</code> section is loaded at VMA 0x08000000, and the processor attempts to jump to 0x60b00000 to run code, as shown in gdb with <code>x/2xw 0x08000000</code>. This does not succeed. The problem is easily solved: I put the <code>.vectors</code> input section into the <code>.text</code> output section.</p>
<p>The next problem is in this little excerpt of code, that is supposed to set pin A2’s mode to its alternate function.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode armasm"><code class="sourceCode armasm"><span id="cb3-1"><a href="#cb3-1"></a>        <span class="kw">ldr</span>     <span class="at">r0</span>, [<span class="at">r6</span>, GPIOx_MODER]</span>
<span id="cb3-2"><a href="#cb3-2"></a>        orr     <span class="at">r0</span>, <span class="at">r0</span>, GPIOx_MODER_MODE_ALT</span>
<span id="cb3-3"><a href="#cb3-3"></a>        <span class="kw">str</span>     <span class="at">r0</span>, [<span class="at">r6</span>, GPIOx_MODER]   // set PA2 to mode AF</span></code></pre></div>
<p>Symbolic constants abound. I can check those by cross-referencing where they’re defined, but I can also fire up a debugger and look at what code is in the byte stream.</p>
<pre><code>0x080000a2 &lt;+46&gt;:	ldr	r0, [r6, #0]
0x080000a4 &lt;+48&gt;:	orr.w	r0, r0, #2
0x080000a8 &lt;+52&gt;:	str	r0, [r6, #0]</code></pre>
<p><code>#0</code> is the right offset for <code>GPIOx_MODER</code>, but what’s this? <code>#2</code> is definitely not the right constant for setting pin 2 to AF - it’s the right constant for setting pin 0 to AF. I neglected to shift my symbolic constant into the right spot for the pin I want to affect.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode armasm"><code class="sourceCode armasm"><span id="cb5-1"><a href="#cb5-1"></a>        orr     <span class="at">r0</span>, <span class="at">r0</span>, GPIOx_MODER_MODE_ALT &lt;&lt; <span class="bn">4</span></span></code></pre></div>
<p>And now, I see output.</p>
<figure>
<img src="/images/timers%20-%20heartbeat.png" alt="" /><figcaption>The earlier peaks here measure as 375KHz, so I cherry picked the best one.</figcaption>
</figure>
<p>I see the output I predicted, no less. The time there is 2.625μs, which is exactly 42 divided by 16. Every few intervals, the measured frequency is 375KHz, which I would expect is because either the internal oscillator or my cheap logic analyser’s clock are not perfectly accurate. A 2.625μs measurement is 63 samples at 24MHz, while a 2.667μs measurement is 64 samples.</p>
<h2 id="changing-clocks">Changing clocks</h2>
<p>Able to see output, it’s now time to start changing my clock speeds. I’ll start by verifying I can change the APB1 divider, because that’s the one I need to get right before mucking with the system clock. This means re-including stores to <code>RCC_CFGR</code>. While I’m there, I’ll also turn on the HSE and wait for it to be ready, and as the last thing I do in my <code>main</code>, I’ll turn on PC13 as a push-pull output, driven low, to turn on the board’s blue LED. This will give me a quick visual indicator that my code has made it through all of the configuration, instead of hitting a trap or an endless loop.</p>
<p>With the APB1 divider set to 2, I now expect to see 5.25μs between peaks, a 190KHz rate, taking 126 samples. I may see 189KHz as well, which is 127 samples. Let’s take a look.</p>
<figure>
<img src="/images/timers%20-%20heartbeat.png" alt="" /><figcaption>Yes, this is the same image as before.</figcaption>
</figure>
<p>Well, hmm. Am I failing to configure the APB1 clock divider? If so, how? A peek at my code shows I forgot to actually set <code class="sourceCode armasm"><span class="at">r6</span></code> to <code>RCC</code>, so I’m attempting to set the clock by writing a word into Flash. This does not succeed. I fix that up, and…</p>
<figure>
<img src="/images/timers%20-%20heartbeat.png" alt="" /><figcaption>Yes, this is still the same image as before.</figcaption>
</figure>
<p>Uh. Well, it’s midnight, I should sleep.</p>
<h2 id="finding-the-mistake">Finding the mistake</h2>
<p>There is a very good reason for the timer output being unchanged despite the APB1 clock divider being set to two. The reason for it is right there on the clock tree diagram from the <a href="006-fake-it.html">last post</a>: the timers on APB1 and APB2 have their clocks multiplied by a value that’s set by the microcontroller, based on the APBx prescaler. From the reference manual (RM0368 rev. 5, p94):</p>
<blockquote>
<p>If the APB prescaler is configured to a division factor of 1, the timer clock frequencies (TIMxCLK) are set to HCLK. Otherwise, the timer clock frequencies are twice the frequency of the APB domain to which the timers are connected: TIMxCLK = 2xPCLKx.</p>
</blockquote>
<p>So it turns out that I am seeing what I would expect to see if I set the APB1 divider to 2.</p>
<p>It’s also around this point that I reflect on the fact that my logic analyser has eight inputs, and I’m only using one. I can observe both TIM9 and TIM2 at once. I’ll use PA3 for TIM9 channel 2, and switch to PA1 for TIM2 channel 2, so I can re-use the timer setup code trivially.</p>
<p>With a big change to my port setup code, I’ll check my constants via gdb again:</p>
<pre><code>   0x08000088 &lt;+32&gt;:	ldr	r6, [pc, #108]	; (0x80000f8)
   0x0800008a &lt;+34&gt;:	mov.w	r0, #204	; 0xcc
   0x0800008e &lt;+38&gt;:	str	r0, [r6, #8]
   0x08000090 &lt;+40&gt;:	movw	r0, #12304	; 0x3010
   0x08000094 &lt;+44&gt;:	str	r0, [r6, #32]
   0x08000096 &lt;+46&gt;:	ldr	r0, [r6, #0]
   0x08000098 &lt;+48&gt;:	orr.w	r0, r0, #136	; 0x88
   0x0800009c &lt;+52&gt;:	str	r0, [r6, #0]</code></pre>
<p>Address <code>0x80000f8</code> has the right value for <code>GPIOA</code>. <code>0xcc</code> is <code>1100 1100</code>, which sets very high speed on pins 1 and 3. <code>0x3010</code> is <code>0011 0000 0001 0000</code>, written to <code>GPIOx_AFLR</code>, sets pin 3 to AF03, and pin 1 to AF01. And finally, <code>0x88</code> is <code>1000 1000</code>, written to <code>GPIOx_MODER</code>. This assumes the modes for pins 1 and 3 are in their reset state, and sets them to AF mode.</p>
<p>With APB1’s clock now divided by four, I’m ready to run this sucker.</p>
<figure>
<img src="/images/timers%20-%20paired.png" alt="" /><figcaption>If this were a gif sort of blog, there’d be a celebratory dance of some kind right here.</figcaption>
</figure>
<p>I configured both timers with prescale 7, counter 6. With APB2’s timers running twice as fast as APB1’s, I now expect to see TIM9 spitting out a 381KHz signal, and TIM2 spitting out a 190KHz signal.</p>
<h2 id="the-rest-of-the-owl">The rest of the owl</h2>
<p>With the most risky part out of the way, it’s time to fire up the whole configuration scheme and get the part running at 84MHz. I’ve set APB2’s divider back down to two, which means both TIM2 and TIM9 will be running at 84MHz. The settings I have for prescaler and counter should produce a 2MHz signal (84/6/7 = 2).</p>
<figure>
<img src="/images/timers%20-%202mhz.png" alt="" /><figcaption>Sort of anticlimatic, when everything works as predicted.</figcaption>
</figure>
<p>Now I need to refer back to my notes so I can start reacting to signals. The pins I’ve defined are:</p>
<table>
<thead>
<tr class="header">
<th>STM32</th>
<th>Z180</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PA0:7</td>
<td>D0:7</td>
<td>Data bus, in/out</td>
</tr>
<tr class="even">
<td>PA9</td>
<td>-</td>
<td>STM32’s “processing read” flag</td>
</tr>
<tr class="odd">
<td>PB0:1</td>
<td>A0:1</td>
<td>First two address lines</td>
</tr>
<tr class="even">
<td>PB5:10</td>
<td>A2:7</td>
<td>Next six address lines</td>
</tr>
<tr class="odd">
<td>PB12</td>
<td>IORQ</td>
<td></td>
</tr>
<tr class="even">
<td>PB13</td>
<td>MREQ</td>
<td></td>
</tr>
<tr class="odd">
<td>PB14</td>
<td>WR</td>
<td></td>
</tr>
<tr class="even">
<td>PB15</td>
<td>RD</td>
<td></td>
</tr>
</tbody>
</table>
<p><em>Note: the mistake I made in the previous post to somehow forget that the address bus is 16-bits continues here. I won’t fix it, I’ll live with it and move on to using real memory.</em></p>
<p>The code to watch for a memory request and react to it is straightforward. I read from the GPIOB input data register and check to see if MREQ and RD (bits 13 and 15) are set. If not, I loop and read again.</p>
<p>If so, then I set PA9 using the bit set/reset register for GPIOA, then I wait for either MREQ or RD to clear. I then reset PA9, and loop back to wait for MREQ and RD again.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode armasm"><code class="sourceCode armasm"><span id="cb7-1"><a href="#cb7-1"></a><span class="fu">loop:</span>   // wait for MREQ and RD to be set</span>
<span id="cb7-2"><a href="#cb7-2"></a>        <span class="kw">ldr</span>             <span class="at">r0</span>, [<span class="at">r6</span>, GPIOx_IDR]</span>
<span id="cb7-3"><a href="#cb7-3"></a>        ands            <span class="at">r1</span>, <span class="at">r0</span>, <span class="bn">0</span>b1010000000000000</span>
<span id="cb7-4"><a href="#cb7-4"></a>        <span class="kw">beq</span>             loop</span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a>        // set PA9 to indicate memory read is active</span>
<span id="cb7-7"><a href="#cb7-7"></a>        <span class="kw">ldr</span>             <span class="at">r0</span>, =<span class="bn">1</span> &lt;&lt; <span class="bn">9</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>        <span class="kw">str</span>             <span class="at">r0</span>, [<span class="at">r5</span>, GPIOx_BSRR]</span>
<span id="cb7-9"><a href="#cb7-9"></a></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="fu">reading:</span>// wait for MREQ and RD to go inactive</span>
<span id="cb7-11"><a href="#cb7-11"></a>        <span class="kw">ldr</span>             <span class="at">r0</span>, [<span class="at">r6</span>, GPIOx_IDR]</span>
<span id="cb7-12"><a href="#cb7-12"></a>        ands            <span class="at">r1</span>, <span class="at">r0</span>, <span class="bn">0</span>b1010000000000000</span>
<span id="cb7-13"><a href="#cb7-13"></a>        <span class="kw">bne</span>             reading</span>
<span id="cb7-14"><a href="#cb7-14"></a></span>
<span id="cb7-15"><a href="#cb7-15"></a>        // reset PA9</span>
<span id="cb7-16"><a href="#cb7-16"></a>        <span class="kw">ldr</span>             <span class="at">r0</span>, =<span class="bn">1</span> &lt;&lt; <span class="bn">25</span></span>
<span id="cb7-17"><a href="#cb7-17"></a>        <span class="kw">str</span>             <span class="at">r0</span>, [<span class="at">r5</span>, GPIOx_BSRR]</span>
<span id="cb7-18"><a href="#cb7-18"></a></span>
<span id="cb7-19"><a href="#cb7-19"></a>        b               loop</span></code></pre></div>
<p>There’s a logic error in here I introduced in the 11th hour, so it works <em>almost</em> as expected. The logic analyser’s capture shows the STM32 dropping PA9 low when MREQ and RD are low, and PA9 staying high during a DRAM refresh cycle when only MREQ goes low. Of course, I wrote it thinking I was asserting PA9 high when MREQ/RD were active, but I forgot to take into account that these two lines are active low. Despite this, the timing here shows the STM32F4 will comfortably respond to a read request in time, and have no trouble turning output off when it should relinquish the bus.</p>
<figure>
<img src="/images/timers%20-%20reacting.png" alt="" /><figcaption>The slowest reaction I could find in here was 166.667ns.</figcaption>
</figure>
<p>A few other things have gone a little bit wrong, of course. I was having trouble getting the STM32 to boot up correctly: it would only work immediately after being flashed on. Turns out I forgot to uncomment the Flash wait state register write, which as promised crashes the μC. I have to plug in the STM32’s USB cable before the logic analyser: I suspect a ground loop is at fault. And my ghetto breadboard header for the 50-pin IDC socket is really not a good piece of engineering, so A1 isn’t wired up right. This final point means I’ve got to bust out a soldering iron before I can make the STM32 act as RAM and ROM.</p>
<figure>
<img src="/images/timers%20-%20test%20rig.jpg" alt="" /><figcaption>There’s a cheeky 74HC245N photobombing my rig.</figcaption>
</figure>
<p>I also don’t really like my chances of fitting enough wires on this breadboard to wire up the data lines via a ’245. Another round of fiddly soldering of 40 or so wires, here I come.</p>
<p>This experiment has been a great success. I’ve programmed my STM32F4 from the ground up, detected the Z180’s memory requests, and confirmed that an 84MHz μC is easily fast enough to be RAM and ROM for a 1MHz processor. Nice.</p>
<table style="width:86%;">
<caption>Project status update</caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 10%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Budget</th>
<th style="text-align: center;">CPU</th>
<th style="text-align: center;">Power</th>
<th style="text-align: center;">Keyboard</th>
<th style="text-align: center;">Video</th>
<th style="text-align: center;">Memory</th>
<th style="text-align: center;">Debug</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">$209.35 of $400</td>
<td style="text-align: center;">██──</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">███─</td>
</tr>
</tbody>
</table>]]></summary>
</entry>
<entry>
    <title>The TRS-20 - fake it 'til you make it</title>
    <link href="https://bje.id.au/blog/posts/trs20/006-fake-it.html" />
    <id>https://bje.id.au/blog/posts/trs20/006-fake-it.html</id>
    <published>2020-01-27T00:00:00Z</published>
    <updated>2020-01-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>My processor appears to be happy in its perfboard home for now. While I can get pretty excited over seeing signal probes confirm data sheet timing diagrams, I’ll admit that it’s a limited success. There is still a long road to having a homebrew computer built. What I’d like to do next is give the processor some RAM and ROM, and have it execute programs more significant than endless <code>NOP</code>s. I’d like to exercise the other major machine cycles - memory write, and I/O reads and writes, so I can get excited about signal probes confirming a whole new swathe of timing diagrams.</p>
<p>To achieve this, I’ll use my STM32F401CC “black pill” board to act as the RAM and ROM, and use its connection to my LCD to display runtime status information. With 256KiB of Flash and 64KiB of SRAM, there’s space on the black pill to share with the Z180… but can the 84MHz STM32F401CC react fast enough to deliver data smoothly to the 1MHz Z180?</p>
<!--more-->
<p><em>Note: this post contains a significant mistake that flows on to the next post. I’ve annotated the mistake in a subsequent edit, but have otherwise left it as-is.</em></p>
<h2 id="will-they-blend">Will they blend?</h2>
<p>At a physical level, there’s no particular problem with wiring up the STM32 to the Z180. The STM32 is 5V tolerant, so as long as voltage levels, current limits, and impedance requirements line up, I can wire the two up directly.</p>
<p><span class="math display">\[\begin{array}{rrcll}
&amp; \text{STM32} &amp; &amp; \text{Z180} &amp; \\\hline
V_{IL} &amp;1V &amp;\leq&amp;  0.45V &amp;V_{OL} \\
V_{IH} &amp;2.3V &amp;\leq&amp; 2.4V &amp;V_{OH} \\
V_{OL} &amp;0.4V &amp;\geq &amp; 0.8V &amp;V_{IL} \\
V_{OH} &amp;2.4V &amp;\geq &amp; 2.0V &amp;V_{IH} \\
\end{array}
\]</span></p>
<p>There’s a possible concern with the V<sub>IH</sub> for the STM32 at 2.31V, and the V<sub>OH</sub> of the Z180 at 2.4V. 100mV is not a lot of margin. The datasheet indicates that the Z180 will put out a voltage of V<sub>CC</sub>-1.2 if the output current is 20μA or less. The dynamic current consumption of the STM32 is calculated below, based on a pin capacitance on the Z180 of up to 12pF plus some stray capacitance.</p>
<p><span class="math display">\[\begin{aligned}
I_{SW}  &amp;= C_L \times V_{DD} \times F_{SW} \\
        &amp;= 20\mathrm{pF} \times 3.3\mathrm{V} \times 1\mathrm{MHz} \\
        &amp;= 20\times10^{-12} \times 3.3 \times 1\times10^6 \\
        &amp;= 20\times10^{-6} \times 3.3 \\
        &amp;= 60\times10^{-6} \\
        &amp;= 60\textrm{μA}
\end{aligned}\]</span></p>
<p>60μA means the high output voltage will be somewhere between 2.4V and 3.8V. There’s no curve provided, alas, but having a lower current than 200μA means the high level will be over 2.4V, and the circuit should behave correctly.</p>
<figure>
<img src="/images/black-pill-schematic.png" alt="" /><figcaption><a href="https://user-images.githubusercontent.com/26240765/60139875-2fb05880-97e2-11e9-9a82-5670e73c8bd1.png">This</a> might not be the same thing that I have, but it will be close to it.</figcaption>
</figure>
<p>There’s also the matter of pin assignments. The black pill board has an STM32F401CCU6 processor on it, which is a 48-pin device. Ten pins are supply pins, two pins are boot/reset signals, and the remaining 36 pins are GPIO - or special purpose. PC14 and PC15 are attached to the external low-speed oscillator, as shown above. According to the full schematic, PC13 is wired to the board’s user LED. PA11 and PA12 are wired to the USB-C socket. PA4 (F_CS), PA5, PA6 (MISO), and PA7 (MOSI) are all wired up to U3, which by the schematic is a 32M SPI Flash chip - this Flash has not been installed on my board, so these pins are available for GPIO. PA13 and PA14 are wired to the serial debug header, and are SWDIO and SWCLK respectively. PB3, PB4, and PA15 are also JTAG pins, but there’s no JTAG header exposed, so I can configure these pins for GPIO. However, PB4 and PA15 are in pull-up state after reset, so care must be taken if they’re wired directly to the Z180.</p>
<p>I2C3 uses PA8 and PB4. PB2 is tied to ground, as it also serves as BOOT1 and must be low when BOOT0 is high to select the bootloader. This leaves PB0:1 and PB5:10 free for the address bus, and PB12:15 for signals. Pulling in MREQ, IORQ, RD, and WR gives me 95% of what I’ll need - I can’t detect an interrupt acknowledge, differentiate opcode fetch from other memory reads, or see a bus request acknowledgement. PA0:7 are open to be the data bus, so long as I can switch them from output to input fast enough to avoid a bus collision with the Z180. I’m left with PA8:10 for any further signals required.</p>
<p><em>Note: here is my mistake: the address bus on the Z180 is not 8-bit, it’s 20-bit. I never intended to use the full 20 bits, but I did intend to use 16 bits. I’ve only assigned 8 pins for the address bus, which gives me 128 bytes each of RAM and ROM. This isn’t a disaster, since I need to wean myself off the μC anyway, but it is a pretty big error in planning! I’m proceeding with an 8-bit address bus, and if I get desperate PA8:10 can give me 8x the address space.</em></p>
<h2 id="racing-electrons">Racing electrons</h2>
<p>The STM32F4 can be configured to operate at 84 times the system clock speed of the Z180. At this speed, there’s a good chance that the STM32 will have enough time to observe signal changes and connect SRAM or Flash to the data bus depending on the operation involved. And, of course, if there’s any bug in my code then I’ll either lock the data bus on output and possibly burn out pins, or lock it on input and the Z180 will see only noise. A transceiver with its enable and direction inputs controlled by glue logic may be worthwhile to protect my hardware from me.</p>
<p>The basic loop looks something like this:</p>
<p><img src="/images/stm32-ram-rom-flowchart.png" /></p>
<p>There’s 4,500ns available between the fall of T1 and the rise of T3 with a 1MHz clock and three wait states. MREQ and RD may fall as much as 50ns after the fall of T1, and data must be present at least 25ns before the rise of T3, so with the magic of rounding that’s 4,400ns to recognise a memory read request and respond to it. If a read is immediately followed by a write, then the Z180 might be asserting data on the bus as soon as the fall of T1, so it’s imperative that the STM32 stops asserting data as soon as RD rises - that’s one full clock cycle, less the maximum 50ns delay that RD may have, or around 950ns at 1MHz.</p>
<p>I don’t think I can reasonably pre-determine how many clock cycles the STM32 will take for its work, as this isn’t your simple 8-bit 1980s era processor any more. It has an instruction cache (in the Flash interface, not the Cortex-M4 itself), multiple bus masters, and a pipelined CPU with instruction prefetch and branch prediction. Even with interrupts disabled, I don’t think I’d be comfortable declaring that any measurement I make gives a definitive answer of clock cycles used. However, each clock cycle is around 12ns, so I have a hair over 75 cycles to detect RD rising and to change the I/O ports to inputs again.</p>
<p>I can wire up signals in and out of the STM32, but leave address and data disconnected, to see how quickly it can respond to the Z180’s changing signals.</p>
<h2 id="programming-the-stm32">Programming the STM32</h2>
<p>Since this project is about doing pointlessly difficult things for no reason other than learning something that others have already done before me, and better, I’ll program the STM32 in assembly. The bare bones of this is straightforward, as the GCC port for ARM does everything except writing to the device with a minimum of fuss.</p>
<p>There’s only a few details to worry about. The first is that the Flash memory on the STM32F4 series is at 0x08000000:0x08040000, so the linker must be told to place sections into that region. The second is that there is a vector table to place at 0x08000000, containing an initial stack pointer, the reset vector, and a handful of other vectors. Using the <code>-Ttext 0x08000000</code> argument to <code>ld</code> will put the text section at the right offset, and putting the reset vector at the start of the text section more or less does the trick. As my code gets bigger, though, I’ll want to use a linker script to ensure all sections are placed correctly, and that the vector table is placed first, even when I’m linking multiple object files. The trivial method is shown by example <a href="http://www.martinhubacek.cz/arm/arm-cortex-bare-metal-assembly/stm32f0-cortex-m0-bare-metal-assembly">here</a>, and the linker script can easily be cribbed from the output of CubeMX.</p>
<p>After those details are squared away, it’s down to code. The STM32 chips are interesting in that they boot up kind of brain-dead. Most of the peripherals are off, the clock runs off an internal oscillator at a low speed, and there’s no fuses to pre-configure everything like on an AVR. This allows much more software control over the chip’s power consumption, but requires that the chip is configured after every reset, from which peripherals will be used to how the clock runs.</p>
<h2 id="clocking-in">Clocking in</h2>
<p>The STM32F4 has a moderately complex clock tree, compared to the old 8 bit CPUs. There are two internal oscillators, at 32KHz and 16MHz. The low speed internal (LSI) oscillator feeds the RTC system and the internal watchdog, neither of which I will use for now. The high speed internal (HSI) oscillator feeds into the PLL source mux, along with the high speed external (HSE) oscillator. The PLL feeds the USB 48MHz clock, and all three of PLL, HSI, and HSE feed into the system clock mux. From here, the clock is prescaled, then drives the various peripheral buses and such.</p>
<figure>
<img src="/images/stm32-cube-clocks.png" alt="" /><figcaption>Image from STM32CubeMX, which makes all of this easier to work out.</figcaption>
</figure>
<p>Solving the clock tree puzzle means finding values for M, N, P, and Q in the PLL subsystem such that 84MHz can be fed into the system clock mux, and 48MHz can be fed into the USB clock. The high speed oscillator is divided by M, then multiplied by N. This value is divided by P to get the system clock, and by Q to get the USB clock. P is constrained to be 2, 4, 6, or 8, while Q is anything from 2 to 15.</p>
<p><span class="math display">\[\begin{aligned}
    ((25MHz / M) \times N) / P &amp;= 84MHz &amp; \text{system clock} \\
    ((25MHz / M) \times N) / Q &amp;= 48MHz &amp; \text{USB clock}
\end{aligned}\]</span></p>
<p>The trick, at least according to one <a href="https://stm32f4-discovery.net/2015/01/properly-set-clock-speed-stm32f4xx-devices/">tutorial</a>, is to start by ensuring <span class="math inline">\(M\)</span> matches your high speed oscillator so you feed a 1MHz signal into the PLL.</p>
<p><span class="math display">\[\begin{aligned}
    N / P &amp;= 84MHz &amp; \text{system clock} \\
    N / Q &amp;= 48MHz &amp; \text{USB clock}
\end{aligned}\]</span></p>
<p>Now the constraints on <span class="math inline">\(P\)</span> limit the possibilities to finding a value for <span class="math inline">\(N\)</span> that can be divided by 2, 4, 6, or 8 to get 84MHz, and that can be divided by 2 to 15 to get 48MHz. <span class="math inline">\(N\)</span> will be one of 168, 336, 504, or 672. Since <span class="math inline">\(N\)</span> is constrained to be between 50 and 432, the choices are 168 or 336. Of those two, only 336 has no remainder when divided by 48, so the PLL settings are <span class="math inline">\(M\)</span> at 25, <span class="math inline">\(N\)</span> at 336, <span class="math inline">\(P\)</span> at 4, and <span class="math inline">\(Q\)</span> at 7. After that it’s just a matter of setting the prescalers and multipliers for the peripheral clocks to keep everything at 84MHz except for PCLK1, which maxes out at 42MHz instead.</p>
<p>All of this is communicated to the chip by writing to the Reset and Clock Control (RCC) registers, described in gory detail in the STM32F401xx reference manual (RM0368, pp. 103-139).</p>
<ol type="1">
<li><p>The HSE must be turned on. In the case of the black pill board, this is an external crystal, so the RCC Control Register (RCC_CR) will have bit 16 turned on. The software should then wait until bit 17 (HSE RDY) of RCC_CR is set by hardware.</p></li>
<li><p>The PLL must be configured via the RCC PLL configuration register (RCC_PLLCFGR). The PLL is disabled on reset, so it is safe to write to the register in one go, setting M, N, P, Q, and the PLL source. The PLL is then enabled via the RCC_CR, and the program should wait until the PLL is flagged as ready.</p></li>
<li><p>The Flash interface must be configured to use a sufficient number of wait states for the chosen clock speed. At 84MHz, three CPU cycles are required to read from the Flash memory, and so two wait states must be inserted. Writing to the Flash Access Control Register (FLASH_ACR) achieves this - the low byte can be used to select between zero and fifteen wait states.</p></li>
<li><p>The system and peripheral bus clocks must be configured. The APB1 peripheral clock must not exceed 42MHz, so the APB1 prescaler needs to be set before the system clock source is changed to the PLL. When the APB1 prescaler, AHB prescaler, and SYSCLK source have all been configured via the RCC Configuration Register (RCC_CFGR), the clock tree is configured and ready to go.</p></li>
</ol>
<p>There’s one part in this that concerns me a little. The reference manual (RM0368) states that some bits of the RCC_PLLCFGR are reserved and “must be kept at reset value.” The reset value from the manual has one reserved bit set, but the HAL library code happily constructs a value for this register that obliterates that bit. Are they important? Who knows. The HAL certainly has its share of bugs, so my inclination is to stick to what the manual describes, and set the bit.</p>
<h2 id="general-purpose-io-sir">General Purpose IO, <em>sir</em>!</h2>
<p>The final boot-up task is to configure the GPIO pins. PB0:1, PB5:10, and PB12:15 are all to be inputs, while PA0:7 will be inputs unless a read is requested. The two ports are enabled using the RCC AHB1 peripheral clock enable register (RCC_AHB1ENR), bits 0 and 1. However, the errata sheet ES0182 (rev 11, pp 16) notes that there must be a delay between enabling an RCC peripheral clock and any access to that peripheral. One of the three work-arounds suggested is to read back from the register immediately after writing to it.</p>
<p>The reference manual has a chapter explaining the GPIO system. Configuration is managed through four registers per port: the GPIOx_MODER mode register, the GPIOx_OTYPER output type register, the GPIOx_OSPEEDR output speed register, and the GPIOx_PUPDR pull-up/pull-down register. At reset, most GPIO pins are configured as inputs, with the exception of PA13 (analog input) and PB3/4 (alternate function: JTAG/SWD). PA13 and PB3 are configured for very high output speeds, with all other pins at low speed. PA15, PA13, and PB4 are all configured to pull up, with PA14 configured to pull down.</p>
<p>All of port B should stay as inputs; all pins on the port will either be tied to something on the Z180, or already configured to not be floating. Most of port A should stay as it is on reset as well. PA8:10 will be floating, and should have an internal pull-up enabled. PA0:7 are the data lines, and will be shared between the Z180 and the STM32. Setting A0:7 to push-pull in GPIOA_OTYPER should allow a single half-word store to GPIOA_MODER to flip modes. Between the time each IC is trying to drive the lines they will be left floating. Putting an external pull-up resistor on the data lines will help ensure that both ICs always see a valid logic level.</p>
<p>The minimum resistance for the pull-up is determined by how much current will flow through the resistor and into an N-MOS gate driving the line low. The Z180 does not want to sink more than around 2.2mA on an output line being pulled low, while the STM32 claims to be comfortable with 25mA per pin, but only 120mA total across all pins, so around 2mA is a reasonable target for both ICs. This sets the lower bound for the pull-up resistor at 5V/2.2mA or 2.3kΩ.</p>
<p>The maximum resistance depends on both the impedance of the input pin (as the pull-up resistor and the pin’s impedance form a resistor divider that limits the input voltage level seen by the pin), and on the acceptable rise time for a floating line to be pulled high. CMOS high-Z impedance is usually in the MΩ range: the STM32’s leakage current is 3μA, and the Z180’s is 1μA, putting their respective impedances at around 333kΩ and 1MΩ respectively. This caps the pull-up resistor at 33.3kΩ. Assuming around 25pF capacitance for the wires and input pins, the RC time constant will be 33kΩ × 25pF = 33e3 × 25e-12 = 825e-9 or 825ns, and the time to reach approx. 2.5V from 0V is 0.693 825ns = 572ns.</p>
<p>Selecting a resistor value that will give a faster rising edge will leave both ICs in their defined voltage ranges for more total time. A 10k resistor will reach 2.5V in 173ns and consume 500μA, and a 4.7k resistor will reach 2.5V in 81ns and consume 1mA. Lower resistance is a stronger pull-up, and causes more work to be done by a driver pulling the line low, but will reduce the work done to pull the line high.</p>
<p>The effect of resistance on rise time can be seen in this interactive chart. The chart shows a 500kHz signal with a pull-up resistor and 25pF capacitance. The fastest signal out of the Z180 is PHI at 1MHz, but most information bearing signals are 500kHz or slower.</p>
<canvas id="canvas" height="300" style="width:100%">
</canvas>
<p>There are two advantages to using a strong pull-up in my design. Assisting the Z180 to pull the data lines high will help the STM32 see a higher voltage level on its inputs, and configuring the STM32’s pins as open-drain outputs means they will never be driving a line high while the Z180 is driving it low. Unfortunately the reverse is not true, as the Z180 operates its data lines in push-pull mode, and will push high when it needs a high signal. If it pushes high when the STM32 is pulling low, both ICs will be at risk of damage. A ’245 transceiver is still the real answer to this problem.</p>
<p>The next step is to <a href="https://github.com/codebje/trs20-debug/">write the code</a> to implement chip configuration. My logic probe is a 24MHz device, so it can’t directly observe an 84MHz clock, but I can certainly drive a timer on the STM32 to produce what I think should be a 1MHz signal, and observe that. Then I can observe the μC reacting to the CPU’s control signals, and verify that an 84MHz μC can react fast enough to appear like RAM to a 1MHz CPU.</p>
<table style="width:86%;">
<caption>Project status update</caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 10%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Budget</th>
<th style="text-align: center;">CPU</th>
<th style="text-align: center;">Power</th>
<th style="text-align: center;">Keyboard</th>
<th style="text-align: center;">Video</th>
<th style="text-align: center;">Memory</th>
<th style="text-align: center;">Debug</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">$209.35 of $400</td>
<td style="text-align: center;">██──</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">██──</td>
</tr>
</tbody>
</table>]]></summary>
</entry>
<entry>
    <title>The TRS-20 - apply power here</title>
    <link href="https://bje.id.au/blog/posts/trs20/005-power-up.html" />
    <id>https://bje.id.au/blog/posts/trs20/005-power-up.html</id>
    <published>2020-01-15T00:00:00Z</published>
    <updated>2020-01-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>With my plan for a perfboard in hand, I finally broke out the soldering iron and started assembling. The board has a socket for an oscillator, a socket for the CPU, and IDC connectors for both 50-pin and 10-pin links. This is a <em>lot</em> of little wires to cut, strip, and solder. Let’s see how it goes.</p>
<!--more-->
<h2 id="data-address-and-more">Data, address, and more</h2>
<figure>
<img src="/images/z80-basic-wiring.jpg" alt="" /><figcaption>Marge! We need more red, blue, yellow, white, red, and black hookup wire!</figcaption>
</figure>
<p>The first pass at it all involved 8 white wires for data, 16 yellow wires for address, some black and red for power lines, and not quite enough blue left for all the signals. There’s a capacitor that snuck its way on the board, since it’ll be noisy enough as it is. The soldering went as well as one might expect, you can see a few wires where the insulation has melted apart, a few suspiciously large blobs of solder, but everything’s clean and bridge-free.</p>
<p>The set of signals I chose to hook up with the blue I had are the CPU’s inputs: the four interrupts, reset, wait, and bus request. Wiring these seven signals high, and the eight data signals low, will put the CPU into a NOP loop through the low 8 bits of address space.</p>
<figure>
<img src="/images/z80-low-address-probe.png" alt="" /><figcaption>A0 to A4 showing doubling of frequency at each bit. Just ignore the noise…</figcaption>
</figure>
<p>Using my ghetto fixed logic probe, the main thing I see is a smattering of chaos. The CPU has not been told otherwise, and so it is refreshing DRAM it doesn’t have. Each DRAM refresh sets some address lines and leaves others floating. The result on the probe is that I can find spans in which the low order address lines show a satisfying binary counting pattern, but the high order lines barely show structure at all.</p>
<figure>
<img src="/images/z80-basic-board.jpg" alt="" /><figcaption>Eight address lines into the probe, seven signal lines tied high, eight data lines tied low.</figcaption>
</figure>
<h2 id="wiring-up-the-rest">Wiring up the rest</h2>
<p>That’s okay. It’s time to wire up the remaining signals anyway. A quick trip to the local Jaycar (shout out to the Jaycar Aspley folks who’re super helpful every time I come in!) and I’m $9 down, but two packs of jumper wire up, and I can finish off the soldering. Except for the USART stuff to the 10-pin header, which I’ll leave for when I need it.</p>
<p>This time around, I’ll want to see what’s going on with the CPU status pins. I know that it should only be doing opcode fetches and refreshes, which means M1, MREQ, and RD are the only interesting signals. Connecting four pins of the probe to A0 through A3, and the other four pins to M1, MREQ, RD, and PHI lets me take a peek at what’s going on.</p>
<figure>
<img src="/images/z80-rfsh-probe.png" alt="" /><figcaption>Ah logic probe, well worth what I paid for you. I think I forgot to include you in my costings, though…</figcaption>
</figure>
<p>This image shows <em>exactly</em> what I expect. When M1 and RD are high but MREQ is low, the CPU is in a refresh cycle. The address lines will make some sort of sense, but not the sense I’m looking for. When M1. RD, and MREQ are all low, the CPU is fetching an opcode. The address lines are behaving as they should at these times.</p>
<figure>
<img src="/images/z180%20timing%20diagram.png" alt="" /><figcaption>This timing diagram is from PS014005-0817, the Z80180 MPU product specification document, page 31.</figcaption>
</figure>
<p>The synchronisation of signals matches the data sheet. Very shortly after Ф rises for T1, M1 falls. So shortly, in fact, my cheap logic probe records them as happening simultaneously, which means they are less than 41.7ns apart. At 10MHz, the data sheet promises these two events happen no slower than 60ns apart, and that looks to hold true at 1MHz as well. T1’s falling edge MREQ and RD both falling, no more than 50ns after. These three events coincide at a finer resolution than my probe. With T3’s rise, M1 rises. With T3’s fall, MREQ and RD rise.</p>
<figure>
<img src="/images/z180%20one%20cycle.png" alt="" /><figcaption>Zoomed in on one opcode fetch machine cycle.</figcaption>
</figure>
<p>Since the CPU is only executing NOP instructions, all registers are at their RESET defaults. This includes the DMA/WAIT Control (DCNTL) register, which sets bits MWI0 and MWI1 at RESET, inserting three wait states to memory access cycles. The Refresh Control (RCR) register is also in its RESET state, which enables DRAM refresh, inserts one wait state in the refresh cycle to take it to three clocks, and requires one refresh cycle every 10 clock cycles. In practice, this means that there’s a memory refresh cycle between almost every opcode fetch cycle - every 7th fetch cycle skips a refresh cycle. In the image above, you can see a refresh cycle beginning. M1 and RD are high, MREQ is low.</p>
<p>The Z8018x Family MPU User Manual (UM005004-0918) has a table on page 287 that indicates a memory refresh cycle has M1, IORQ, RD, WR, HALT, and BUSACK high, and has MREQ and RFSH low. No other operating modes have MREQ active without either RD or WR active, that is <span class="math inline">\(\overline{RFSH} = \overline{MREQ} \land \lnot(\overline{RD} \lor \overline{WR})\)</span>. I don’t need to expose the RFSH line to know when a refresh cycle is active, and my boot ROM will disable memory refresh very early on in any case, so there’s no need to expose this signal.</p>
<p>One oddity does stand out. The system clock on PHI is running at 1MHz, the same as the oscillator. However, the Z8018x User Manual claims that “[T]he frequency of this output is equal to one-half that of the crystal or input clock frequency.” (UM005004-0918, pp. 7) This same claim is repeated in the Z80180 MPU Product Specification (PS014005-0817, pp. 9) for the CLOCK signal. This isn’t a problem, exactly, save that I have an 18MHz oscillator on back order, and that’ll be far too fast for my 10MHz rated chip.</p>
<p>Nevertheless, my chip starts up and looks on the surface to be behaving correctly. And perhaps more surprisingly, my soldering looks to have been done correctly!</p>
<h2 id="spending-is-a-habit">Spending is a habit</h2>
<table>
<caption>I warned myself about a Jaycar spree…</caption>
<colgroup>
<col style="width: 34%" />
<col style="width: 6%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Item</th>
<th style="text-align: left;">Price</th>
<th style="text-align: left;">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">SM1024</td>
<td style="text-align: left;">$2.40</td>
<td style="text-align: left;">8-way DIP switch</td>
</tr>
<tr class="even">
<td style="text-align: left;">WH3009</td>
<td style="text-align: left;">$24.95</td>
<td style="text-align: left;">8 spools of 25m hookup wire</td>
</tr>
<tr class="odd">
<td style="text-align: left;">PB8819</td>
<td style="text-align: left;">$9.95</td>
<td style="text-align: left;">Breadboard w/ power supply and jumpers</td>
</tr>
<tr class="even">
<td style="text-align: left;">RC5360</td>
<td style="text-align: left;">$1.60</td>
<td style="text-align: left;">10x 100nF ceramic cap, through hole</td>
</tr>
<tr class="odd">
<td style="text-align: left;">RR0596</td>
<td style="text-align: left;">$1.65</td>
<td style="text-align: left;">24x 10kΩ ±1% 0.5W resistor</td>
</tr>
<tr class="even">
<td style="text-align: left;">PP1116</td>
<td style="text-align: left;">$0.95</td>
<td style="text-align: left;">1x 50-pin IDC header</td>
</tr>
<tr class="odd">
<td style="text-align: left;">PP1100</td>
<td style="text-align: left;">$1.90</td>
<td style="text-align: left;">2x 10-pin IDC header</td>
</tr>
<tr class="even">
<td style="text-align: left;">HP9540</td>
<td style="text-align: left;">$4.50</td>
<td style="text-align: left;">Stripboard, 95x75mm</td>
</tr>
<tr class="odd">
<td style="text-align: left;">WH3032</td>
<td style="text-align: left;">$9.00</td>
<td style="text-align: left;">2x breadboard jumper wire</td>
</tr>
</tbody>
</table>
<p>I picked up 8 spools of hookup wire. It’s wider than the jumper wire, and multi-core, so I haven’t used any yet. It’s great stuff for crimping into connectors and the like, but not so fun for soldering with - I expect it to last for years, but probably not see much use on this project. Towards the end of my $400 budget I will sort out what’s been used on the project and what hasn’t, so I can assess costs better.</p>
<p>The ceramic caps are handy for decoupling ICs: you can see one embedded in the processor board. The resistors are for pulling signals high or low. One 50-pin IDC header is now attached to a small section of stripboard, with male headers soldered beneath, as an IDC-to-DIP connector. It’s tricky, soldering to both sides of one-sided stripboard. The DIP switch was bought with dreams of toggling data lines high or low, but I’m not sure I’ll ever want to do that.</p>
<p>My PC104 stackable headers have failed to clear customs. I’ve received a refund, though sadly it looks like my refund doesn’t include the GST I paid for, so I’m out a dollar or so out of pocket, and I’ll need to re-order them sooner or later. Also from Aliexpress, I bought the logic probe from the last post for $12.93, but forgot to list it in any post, and have since also bought a MAX II CPLD minimum system board for $11.56 so I can experiment with a CPLD without soldering a hundred little wires, and some brass spacers for $5.20 for the PC/104 stack.</p>
<p>I think I can claim an extra mark on the CPU progress meter, since I have a working CPU.</p>
<table style="width:86%;">
<caption>Project status update</caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 10%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Budget</th>
<th style="text-align: center;">CPU</th>
<th style="text-align: center;">Power</th>
<th style="text-align: center;">Keyboard</th>
<th style="text-align: center;">Video</th>
<th style="text-align: center;">Memory</th>
<th style="text-align: center;">Debug</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">$209.35 of $400</td>
<td style="text-align: center;">██──</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">██──</td>
</tr>
</tbody>
</table>]]></summary>
</entry>
<entry>
    <title>The TRS-20 - arrivals from China</title>
    <link href="https://bje.id.au/blog/posts/trs20/004-china-cargo.html" />
    <id>https://bje.id.au/blog/posts/trs20/004-china-cargo.html</id>
    <published>2020-01-01T00:00:00Z</published>
    <updated>2020-01-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Ordering a stack of parts from China always brings to my mind the idea of space-based mining operations loading packages of extracted minerals onto a linear accelerator, resulting in a line of packages drifting towards a rendezvous point to be collected on arrival. Since AliExpress is a brokerage for individual traders, placing an order like mine means almost everything comes in its own separate package.</p>
<!--more-->
<p>The space rocks have been arriving at my Lagrange point since the start of December. My STM32F401 “black pill” board and LCD panel arrived first, followed by my Z180 processor and the PLCC extractor tool. Just before Christmas, my practice SMD kits and logic analyzer arrived, along with a brand new order from Digi-Key detailed below, followed shortly by a USB Blaster for programming a CPLD. The CPLD and some PLCC sockets are awaiting collection from my Lagrange point now.</p>
<p>Sadly, one space rock has been stuck in Sydney awaiting clearance since November. Unfortunately it will probably never arrive. Fortunately, though, it’s the PC/104 headers, which I can go without while I wait for the delivery window to expire, get a refund, and order more.</p>
<h2 id="damaged-goods">Damaged goods</h2>
<p>Ordering from AliExpress is usually a mixed bag of results, and this set of orders is no different. The LCD panel has a lovely big impact fracture in it, obsuring ten characters. Despite this, it works, and I have the black pill STM32 driving it happily - all I/O ports on the STM32F4 are 5V tolerant, so there’s no problem controlling the 5V LCD panel from the 3.3V STM32. A refund should be processed shortly, but I don’t think I’ll bother ordering another - I’d need to order the I²C adapter as well, and it’ll take a month to arrive. I’ll work around the damage.</p>
<figure>
<img src="/images/lcd-cracked.jpg" alt="" /><figcaption>Taking a photo of a backlit LCD panel is surprisingly difficult.</figcaption>
</figure>
<p>The logic analyzer powered up its LEDs just fine, but wasn’t recognised as a USB device. It’s easy to take apart, but scanning over the circuit board showed no obvious problems. This device is quite simple, with a Cypress CY7C68013A USB controller with integrated 8051 μC at its heart. The μC is supported by a 2K EEPROM and a 24MHz crystal, and the usual scattering of resistors and such. With no obvious problems on the board, I took a peek at the USB socket. The ground pin was missing, which is a problem and a surprise - despite this missing pin, the board was powering up, so it was finding a return path somewhere.</p>
<figure>
<img src="/images/logic-analyzer.jpg" alt="" /><figcaption>This photo shows the part markings, with a hint of ghetto repair.</figcaption>
</figure>
<p>A $5 part is worth taking the risk on for a repair, so I took the shield off the USB socket and found the ground pin was present but not inserted correctly. It’s possible the board was getting an intermittent connection from it. I straightened the pin out a little and the board was recognised immediately, and could analyze my I²C link to the LCD panel. Of course without the shield and its solder connections, the remaining stub of USB socket quickly broke off, so I lopped the head off the supplied USB cable and soldered it directly to the board, which you can see at the bottom of the image, beside the exposed FR4 substrate where I ripped the pad right off removing the shield. Hot glue will provide sufficient strain relief for this device.</p>
<h2 id="soldering-with-fire">Soldering with fire</h2>
<p>My SMD practice kits also arrived, so I took a moment to solder two QFP 44s, some SOT-23s, 0612 resistor arrays, and even some 0402 resistors. I tried drag soldering, heating solder paste with the iron, and heating paste with a butane hot air torch. The image below shows the hot air soldering on the QFP on the left, and the SOIC and SOT-23s at the top. Heating paste with an iron is the QFP on the right, and the SOIC/SOTs at the bottom. The drag soldering was an attept to correct the hot air QFP having been lifted slightly off the pads on one side, and since I dont have any flux that isn’t inside a solder wire or in the paste, it went very poorly. You can see a big ol’ solder bridge between the 4th and 5th pins from the bottom.</p>
<figure>
<img src="/images/qfp-solder-kit.jpg" alt="" /><figcaption>I don’t even know what these chips do. They’re probably not functional though, since they’re in a cheap practice kit.</figcaption>
</figure>
<p>The hot air soldering did a very neat job on the SOICs and the SOT-23s, and a reasonably neat job on the 0402s. I’ll still call 0603 my lower limit, but if I ever need a 0402 in a pinch I’m confident I could manage. The 0612 arrays (marked as 0606 on the board, but definitely not square parts) were surprisingly fiddly, but also went on okay. I singed the board in two places trying to fiddle with the arrays, though.</p>
<p>I’ll definitely use the hot air approach for most SMD work. The solder paste heated with an iron leaves a lot of mess behind that I suspect may corrode the board or cause bridges down the line, and I don’t see any reason to use flux paste and try again on the drag soldering given how quick and effective the hot air soldering was. The fact that one row of legs didn’t make contact means I’ll try again on the second practice board and see if it was insufficient paste, bent pins, or a lack of pressure on the chip, but I expect that a cheap butane torch is enough to run with QFPs and even stuff with thermal pads.</p>
<h2 id="christmas-shopping">Christmas shopping</h2>
<p>Meanwhile, I placed and received an order from Digi-Key, and I got a refund for the broken LCD panel. This puts me $5.32 up, and $66.28 down, or $124 through my $400 budget, with no operational circuits or PCBs yet. With Jaycar putting a hot air rework station on special, I need to pay close attention to my spending habits, lest I wind up $400 in with a bunch of loose parts and nothing else.</p>
<p>The Digi-Key order gives me a handful of 74 logic ICs from the HC and AHCT families - NAND gates, D flip-flops, multivibrators, and in/out shift registers. These logic ICs will allow my STM32F4 to link up to the system bus. With a 1MHz oscillator the processor will be running at 500KHz, giving me a whopping 2ms to establish /WAIT and process signals. The STM has 64Kb of SRAM, it can deliver 16Kb to the Z180 comfortably, and 16Kb of its 256Kb of Flash can serve as a ROM.</p>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 6%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Item</th>
<th style="text-align: left;">Price</th>
<th style="text-align: left;">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">AE11164-ND</td>
<td style="text-align: left;">$6.24</td>
<td style="text-align: left;">2x right-angle 50-pin IDC header</td>
</tr>
<tr class="even">
<td style="text-align: left;">ED3044-5-ND</td>
<td style="text-align: left;">$1.20</td>
<td style="text-align: left;">5x 8-pin IC sockets, for oscillators</td>
</tr>
<tr class="odd">
<td style="text-align: left;">2015-CY7C1049CV33-12ZSXA-ND</td>
<td style="text-align: left;">$6.96</td>
<td style="text-align: left;">2x 4Mbit 12ns SRAM, TSOP-II, total 1Mbyte</td>
</tr>
<tr class="even">
<td style="text-align: left;">MCP2221A-I/P-ND</td>
<td style="text-align: left;">$3.42</td>
<td style="text-align: left;">USB to I2C/UART IC, for serial comms</td>
</tr>
<tr class="odd">
<td style="text-align: left;">296-36142-5-ND</td>
<td style="text-align: left;">$4.30</td>
<td style="text-align: left;">5x 74HC595 shift registers (DIP), debug board</td>
</tr>
<tr class="even">
<td style="text-align: left;">296-8251-5-ND</td>
<td style="text-align: left;">$3.60</td>
<td style="text-align: left;">5x 74HC165 shift registers (DIP), debug board</td>
</tr>
<tr class="odd">
<td style="text-align: left;">296-4632-5-ND</td>
<td style="text-align: left;">$5.89</td>
<td style="text-align: left;">10x 74AHCT00 NAND gates (DIP), debug board</td>
</tr>
<tr class="even">
<td style="text-align: left;">296-4772-5-ND</td>
<td style="text-align: left;">$5.89</td>
<td style="text-align: left;">10x 74ACHT74 D-type flip flops (DIP), debug board</td>
</tr>
<tr class="odd">
<td style="text-align: left;">296-41620-5-ND</td>
<td style="text-align: left;">$4.50</td>
<td style="text-align: left;">5x 74AHCT123 multivibrators (DIP), debug board</td>
</tr>
<tr class="even">
<td style="text-align: left;">CKN12306-ND</td>
<td style="text-align: left;">$1.50</td>
<td style="text-align: left;">10x through-hole tactile switches, debug board</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CKN12219-1-ND</td>
<td style="text-align: left;">$1.56</td>
<td style="text-align: left;">10x SMD tactile switches</td>
</tr>
<tr class="even">
<td style="text-align: left;">H3DDH-5018G-ND</td>
<td style="text-align: left;">$5.60</td>
<td style="text-align: left;">450mm 50-way IDC ribbon cable</td>
</tr>
<tr class="odd">
<td style="text-align: left;">H3DDH-5006G-ND</td>
<td style="text-align: left;">$3.99</td>
<td style="text-align: left;">150mm 50-way IDC ribbon cable</td>
</tr>
<tr class="even">
<td style="text-align: left;">110-MXO45HS-3C-1M000000-ND</td>
<td style="text-align: left;">$3.26</td>
<td style="text-align: left;">1MHz oscillator, processor board</td>
</tr>
<tr class="odd">
<td style="text-align: left;">AE10059-ND</td>
<td style="text-align: left;">$2.34</td>
<td style="text-align: left;">68-pin PLCC socket, processor board</td>
</tr>
</tbody>
</table>
<p>The next task is to bust out the soldering iron to get some wires hooked up on the perf board. I can’t put it off forever: if I wait much longer I may as well have just ordered a PCB instead.</p>
<table style="width:86%;">
<caption>Project status update</caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 10%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Budget</th>
<th style="text-align: center;">CPU</th>
<th style="text-align: center;">Power</th>
<th style="text-align: center;">Keyboard</th>
<th style="text-align: center;">Video</th>
<th style="text-align: center;">Memory</th>
<th style="text-align: center;">Debug</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">$124.09 of $400</td>
<td style="text-align: center;">█───</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">██──</td>
</tr>
</tbody>
</table>]]></summary>
</entry>
<entry>
    <title>The TRS-20 - make it run</title>
    <link href="https://bje.id.au/blog/posts/trs20/003-basic-board.html" />
    <id>https://bje.id.au/blog/posts/trs20/003-basic-board.html</id>
    <published>2019-12-30T00:00:00Z</published>
    <updated>2019-12-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>My Z8018010VSC processor is here!</p>
<p>Also arrived is the LCD screen, the STM32F401CC dev board, and most of the other junk I ordered. This post explores what else I need to prepare to be able to make something operational.</p>
<!--more-->
<p>The minimum circuit for the Z180 will need a power source and a clock. With only these things supplied, the processor will be shouting addresses into the void and receiving opcodes to execute from the ether, so tying some of the address lines to LEDs, the data lines to 00H (aka NOP), and other input lines high will let me confirm the processor is running.</p>
<p>The PLCC sockets are through-hole parts, allowing me to simply use perf board to get some kind of initial circuit up and running. Power can be supplied by header pins fed from a 5V breadboard supply, and a cheap oscillator in a DIP socket gets me a clock source quickly.</p>
<p>With clock and power sorted out, it’s time to look at the signals. The PLCC chip has 68 pins, of which 5 are supply pins (four Vss, one Vcc) and two are clock input pins (EXTAL and XTAL, only EXTAL needed with an oscillator). This leaves 61 signals and two power lines to sort out. TEST must be left floating, and RFSH is pointless without DRAM, which leaves me with 61 lines to assign. I can use a 10-pin header for the serial signals and a 50-pin IDC header for everything else, with one signal to discard. I’ve chosen to leave out the E secondary bus signal, which is active only when bus requests are active.</p>
<figure>
<img src="/images/trs20-basic-circuit.png" alt="" /><figcaption>The basic circuit wires the processor to a 50-pin IDC socket and an oscillator.</figcaption>
</figure>
<p>Soldering 60+ wires to perfboard is a fiddly task, as I need to take care to solder wires on in an order that doesn’t leave me melting one wire while trying to solder another. I also don’t want to wind up with something looking like the banner image of this post. This means carefully inspecting the processor’s pin diagram and arranging the order of signals on the IDC connector to avoid crossing the wires. Selecting a non-interfering wire order now will have later benefits should I get a PCB made up, as I can stick to routing signals on the top layer and have a broad ground plane.</p>
<figure>
<img src="/images/trs20-basic-circuit-wiring.png" alt="" /><figcaption>It’s a work of art. Not, you know, great art. More the sort of art that goes on a parent’s fridge for a few months, then quietly thrown out when the child has forgotten it.</figcaption>
</figure>
<p>I need to run supply and ground on the bottom layer in a few places, and there’s a short stint on the bottom layer for DREQ0, but otherwise everything is on the top layer. This particular circuit is more of a wiring plan for a breadboard than anything else, as I think it would not be a good idea to run traces underneath an oscillator, for example.</p>
<p>The Z80180 cannot run slower than 0.5MHz, by the datasheet. The processor’s clock runs at one-half of the external oscillator’s rate, so a 1MHz oscillator is the slowest that I can use. However, if I want to communicate over the USART, I need a clock rate that can work with the USART’s baud rate generator divider pipeline. This pipeline first divides my external clock by two to get the system clock. This can then be divided by a power of two from 1 to 64, then by 10 or 30, and then by 16 or 64. If I want to run my ASCI at 9600 baud, I need a clock that’s at least 16 x 10 x 2 x 9600 = 3.072MHz. Regrettably, DigiKey don’t want to sell me a through-hole oscillator at that speed, nor at 9.216MHz, or in fact any of the speeds that divide into a common baud rate, except for 6.144MHz and 18.432MHz. The latter clocks my processor at 9.216MHz and allows me to operate at baud rates from 57600 down to 300.</p>
<p>Alternatively, an external clock that’s less than or equal to the system clock divided by 40 can be used, divided by 16 or 64. A 1MHz oscillator is a 500KHz system clock, requiring an external clock slower than 12.5KHz. Since I have to divide it by 16, I’d need a 4.8KHz oscillator, which I’m pretty sure don’t exist. I’m calling this option a dead end - I don’t want to have a large BOM just to be generating a USART-compatible clock when I can use a system clock that’s suitable.</p>
<figure>
<img src="/images/z8x180-asci-clock.png" alt="" /><figcaption>This little flow chart is responsible for a lot of time staring at oscillator product lists. Source: Z8018x MPU user manual, page 141.</figcaption>
</figure>
<p>So: two oscillators. One to run the processor at its lowest speed of 500KHz with no serial access, and one to run it near its top speed at 9.216MHz. At low speeds, don’t expect serial comms to work: it’s flashing lights and I/O decoders all the way. At the higher speed, I should be able to run a USART link at up to 57600 baud. I can also consider a third oscillator at 3.57MHz, which runs the processor at 1.785MHz, as close as I’m likely to get to the 1.774MHz of the original TRS-80 Model I. To have both a TRS-80 Model I and USART at the same time would require an external clock source for the USART. An MCP2221 USB to USART bridge can output various clocks, with a stack of glue to divide down to a useful speed, or the CPLD may be able to generate a useful clock signal.</p>
<p>The 50-way IDC connector needs 2x25 holes, and is 2.54mm x 25 + 7.62 + 0.3 = 71.42mm wide. Jaycar’s got a 29x50 hole perf board that comfortably fits everything with plenty of space for wires. And a handful of other stuff: some sockets for logic chips, a larger 24x67 perfboard, and a 50-pin IDC header. Jaycar also gave me a $10 loyalty reward, bringing the price of this little splurge down to a more manageable level.</p>
<table>
<caption>Parts from Jaycar</caption>
<colgroup>
<col style="width: 34%" />
<col style="width: 6%" />
<col style="width: 58%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Item</th>
<th style="text-align: left;">Price</th>
<th style="text-align: left;">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">PI6501</td>
<td style="text-align: left;">$1.35</td>
<td style="text-align: left;">14-pin IC sockets, for debug board</td>
</tr>
<tr class="even">
<td style="text-align: left;">PI6502</td>
<td style="text-align: left;">$0.90</td>
<td style="text-align: left;">16-pin IC sockets, for debug board</td>
</tr>
<tr class="odd">
<td style="text-align: left;">HP9554</td>
<td style="text-align: left;">$8.95</td>
<td style="text-align: left;">24x67 hole perf board, debug board</td>
</tr>
<tr class="even">
<td style="text-align: left;">HP9552</td>
<td style="text-align: left;">$6.95</td>
<td style="text-align: left;">29x50 hole perf board, as initial CPU board</td>
</tr>
<tr class="odd">
<td style="text-align: left;">PP1116</td>
<td style="text-align: left;">$0.95</td>
<td style="text-align: left;">50-pin IDC header</td>
</tr>
</tbody>
</table>
<p>This board is beyond bare-bones: the CPU won’t run correctly with just this board. There’s a handful of inputs that need to be tied high or low, including /RESET. With everything except E exposed, however, it’s fairly straightforward to plug into a breadboard to get something going, and to subsequently build a companion board with the STM32F4 to get some traction on doing more interesting things with the CPU.</p>
<table style="width:86%;">
<caption>Project status update</caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 10%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Budget</th>
<th style="text-align: center;">CPU</th>
<th style="text-align: center;">Power</th>
<th style="text-align: center;">Keyboard</th>
<th style="text-align: center;">Video</th>
<th style="text-align: center;">Memory</th>
<th style="text-align: center;">Debug</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">$63.13 of $400</td>
<td style="text-align: center;">█───</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">█───</td>
</tr>
</tbody>
</table>]]></summary>
</entry>
<entry>
    <title>Advent of Code, Day 2</title>
    <link href="https://bje.id.au/blog/posts/2019-12-03-advent.html" />
    <id>https://bje.id.au/blog/posts/2019-12-03-advent.html</id>
    <published>2019-12-03T00:00:00Z</published>
    <updated>2019-12-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>The <a href="aoc">Advent of Code</a>, day 2, involves an interpreted integer computer, with three opcodes. The first task is to interpret the (self-modifying) program and find the output value - this is straightforward. The second task is to find two initial memory values that produce a fixed output value. This task is the subject of today’s post.</p>
<p><!--more--></p>
<p>This post is presented as literate Haskell, but since I don’t provide you with the source of the site you’ll have to cut and paste it bit by bit to run it. Maybe some day I’ll improve on that, but not today.</p>
<p>No imports, no language extensions, let’s keep this one simple.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span></code></pre></div>
<p>Each participant gets a unique puzzle input. Mine has been cut and pasted into the program code below, because reading a text file isn’t the interesting part of the problem.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">puzzle ::</span> [<span class="dt">Int</span>]</span>
<span id="cb2-2"><a href="#cb2-2"></a>puzzle <span class="ot">=</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    [  <span class="dv">1</span>, <span class="dv">12</span>,  <span class="dv">2</span>,  <span class="dv">3</span>,  <span class="dv">1</span>,  <span class="dv">1</span>,  <span class="dv">2</span>,  <span class="dv">3</span>,  <span class="dv">1</span>,  <span class="dv">3</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    ,  <span class="dv">4</span>,  <span class="dv">3</span>,  <span class="dv">1</span>,  <span class="dv">5</span>,  <span class="dv">0</span>,  <span class="dv">3</span>,  <span class="dv">2</span>,  <span class="dv">6</span>,  <span class="dv">1</span>, <span class="dv">19</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    ,  <span class="dv">1</span>, <span class="dv">19</span>,  <span class="dv">5</span>, <span class="dv">23</span>,  <span class="dv">2</span>, <span class="dv">10</span>, <span class="dv">23</span>, <span class="dv">27</span>,  <span class="dv">2</span>, <span class="dv">27</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    , <span class="dv">13</span>, <span class="dv">31</span>,  <span class="dv">1</span>, <span class="dv">10</span>, <span class="dv">31</span>, <span class="dv">35</span>,  <span class="dv">1</span>, <span class="dv">35</span>,  <span class="dv">9</span>, <span class="dv">39</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    ,  <span class="dv">2</span>, <span class="dv">39</span>, <span class="dv">13</span>, <span class="dv">43</span>,  <span class="dv">1</span>, <span class="dv">43</span>,  <span class="dv">5</span>, <span class="dv">47</span>,  <span class="dv">1</span>, <span class="dv">47</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>    ,  <span class="dv">6</span>, <span class="dv">51</span>,  <span class="dv">2</span>,  <span class="dv">6</span>, <span class="dv">51</span>, <span class="dv">55</span>,  <span class="dv">1</span>,  <span class="dv">5</span>, <span class="dv">55</span>, <span class="dv">59</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>    ,  <span class="dv">2</span>,  <span class="dv">9</span>, <span class="dv">59</span>, <span class="dv">63</span>,  <span class="dv">2</span>,  <span class="dv">6</span>, <span class="dv">63</span>, <span class="dv">67</span>,  <span class="dv">1</span>, <span class="dv">13</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>    , <span class="dv">67</span>, <span class="dv">71</span>,  <span class="dv">1</span>,  <span class="dv">9</span>, <span class="dv">71</span>, <span class="dv">75</span>,  <span class="dv">2</span>, <span class="dv">13</span>, <span class="dv">75</span>, <span class="dv">79</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>    ,  <span class="dv">1</span>, <span class="dv">79</span>, <span class="dv">10</span>, <span class="dv">83</span>,  <span class="dv">2</span>, <span class="dv">83</span>,  <span class="dv">9</span>, <span class="dv">87</span>,  <span class="dv">1</span>,  <span class="dv">5</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>    , <span class="dv">87</span>, <span class="dv">91</span>,  <span class="dv">2</span>, <span class="dv">91</span>,  <span class="dv">6</span>, <span class="dv">95</span>,  <span class="dv">2</span>, <span class="dv">13</span>, <span class="dv">95</span>, <span class="dv">99</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>    ,  <span class="dv">1</span>, <span class="dv">99</span>,  <span class="dv">5</span>,<span class="dv">103</span>,  <span class="dv">1</span>,<span class="dv">103</span>,  <span class="dv">2</span>,<span class="dv">107</span>,  <span class="dv">1</span>,<span class="dv">107</span></span>
<span id="cb2-14"><a href="#cb2-14"></a>    , <span class="dv">10</span>,  <span class="dv">0</span>, <span class="dv">99</span>,  <span class="dv">2</span>,  <span class="dv">0</span>, <span class="dv">14</span>,  <span class="dv">0</span></span>
<span id="cb2-15"><a href="#cb2-15"></a>    ]</span></code></pre></div>
<p>Each number is a memory cell value. The interpreter has an instruction pointer initialised to zero, and recognises three opcodes: <code>1</code> is addition, <code>2</code> is multiplication, and <code>99</code> halts the program. The two numeric instructions have three arguments, each an indirect address. The first is the address of the left operand, the second the right operand, and the third the result address. In the puzzle input above, <code class="sourceCode haskell"><span class="dv">1</span>, <span class="dv">12</span>, <span class="dv">2</span>, <span class="dv">3</span></code> represents the addition opcode, which will add the contents of memory cells 12 and 2 and store the result in memory cell 3.</p>
<p>The second and third cells are the variables. The numbers above are the required values for the first part of the task - what value do you get in memory cell zero after executing this program. The second part of the task is to find values that mean the end result is the value 19690720 (the date of the first moon landing). The obvious approach is to try combinations until the right answer is output: my initial solution was to manually try a few numbers to see how the output varied with respect to the input, and derive a formula.</p>
<p>Hoever, this problem should be solvable directly, without using trial and error.</p>
<p>Each step of the program computes a new value for some memory cell using other memory cells. The trick with the second task is that two of the memory cells have no defined value: the final value in cell zero will be some expression of two variables. The solution, then, is to construct that expression directly, and solve it for the two variables.</p>
<p>The value to be computed will be an expression tree, where the leaves are either literal integers taken from program memory, or variables identified by their memory location. The branches are one of the two operations.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">Lit</span> <span class="dt">Int</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>          <span class="op">|</span> <span class="dt">Var</span> <span class="dt">Int</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>          <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>          <span class="op">|</span> <span class="dt">Mul</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>          <span class="kw">deriving</span> <span class="dt">Show</span></span></code></pre></div>
<p>An expression can be evaluted to a result as long as it has no variables in it. This is where my code goes off the rails already: I use <code class="sourceCode haskell"><span class="fu">error</span></code> instead of putting the partiality into the type. I’ll forgive myself, and as the only reader of my blog, therefore all my readers also forgive me.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">evaluate ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>evaluate (<span class="dt">Lit</span> x)   <span class="ot">=</span> x</span>
<span id="cb4-3"><a href="#cb4-3"></a>evaluate (<span class="dt">Var</span> x)   <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;evaluating variable&quot;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>evaluate (<span class="dt">Add</span> a b) <span class="ot">=</span> evaluate a <span class="op">+</span> evaluate b</span>
<span id="cb4-5"><a href="#cb4-5"></a>evaluate (<span class="dt">Mul</span> a b) <span class="ot">=</span> evaluate a <span class="op">*</span> evaluate b</span></code></pre></div>
<p>If there are variables, the expression can have those variables substituted for values.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">subst ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>subst var val (<span class="dt">Lit</span> x)   <span class="ot">=</span> <span class="dt">Lit</span> x</span>
<span id="cb5-3"><a href="#cb5-3"></a>subst var val (<span class="dt">Var</span> x)   <span class="ot">=</span> <span class="kw">if</span> var <span class="op">==</span> x <span class="kw">then</span> <span class="dt">Lit</span> val <span class="kw">else</span> <span class="dt">Var</span> x</span>
<span id="cb5-4"><a href="#cb5-4"></a>subst var val (<span class="dt">Add</span> a b) <span class="ot">=</span> <span class="dt">Add</span> (subst var val a) (subst var val b)</span>
<span id="cb5-5"><a href="#cb5-5"></a>subst var val (<span class="dt">Mul</span> a b) <span class="ot">=</span> <span class="dt">Mul</span> (subst var val a) (subst var val b)</span></code></pre></div>
<p>My code’s off-the-railness continues, with boolean blindness in the arguments, and recursion everywhere instead of catamorphisms. If you promise to stop being judgemental, I promise to stop being self-deprecating.</p>
<p>The first stage in solving the problem is to convert the initial memory footprint into an expression for the final value. The <code class="sourceCode haskell">mkExpr</code> function takes a list of variable positions and a program memory and produces a list of expression memory. The literal memory is first converted into expressions that are either a <code class="sourceCode haskell"><span class="dt">Lit</span></code> or a <code class="sourceCode haskell"><span class="dt">Var</span></code>, depending on the <code class="sourceCode haskell">vars</code> argument.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">mkExpr ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Expr</span>]</span>
<span id="cb6-2"><a href="#cb6-2"></a>mkExpr vars program <span class="ot">=</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="kw">let</span> cells <span class="ot">=</span> <span class="fu">zipWith</span> eval program [<span class="dv">0</span><span class="op">..</span>]        <span class="co">-- initial value</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>        eval c i <span class="ot">=</span> <span class="kw">if</span> i <span class="ot">`elem`</span> vars <span class="kw">then</span> <span class="dt">Var</span> i <span class="kw">else</span> <span class="dt">Lit</span> c</span>
<span id="cb6-5"><a href="#cb6-5"></a>     <span class="kw">in</span> interpret cells <span class="dv">0</span></span></code></pre></div>
<p>The expression program is now interpreted, starting with an instruction pointer of zero.</p>
<p>The opcode to be executed must be evaluated first. Self-modifying code is fine, but code where the opcodes depend on variables is not - they’ll cause an <code class="sourceCode haskell"><span class="fu">error</span></code> in <code class="sourceCode haskell">evaluate</code>. Since opcodes that depend on variables would mean the majority of programs are invalid, I do not expect this result. Spoiler: the assumption was valid. Also valid was the assumption that the instruction pointer would never stray out of bounds.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">interpret ::</span> [<span class="dt">Expr</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Expr</span>]</span>
<span id="cb7-2"><a href="#cb7-2"></a>interpret cells ip <span class="ot">=</span> <span class="kw">case</span> evaluate (cells <span class="op">!!</span> ip) <span class="kw">of</span></span></code></pre></div>
<p>The two functional opcodes perform their respective operation, increase the instruction pointer, and tail-recursively continue interpretation. The halting opcode returns the current view of memory.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a>    <span class="dv">1</span>  <span class="ot">-&gt;</span> interpret (add cells ip) (ip <span class="op">+</span> <span class="dv">4</span>)</span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="dv">2</span>  <span class="ot">-&gt;</span> interpret (mul cells ip) (ip <span class="op">+</span> <span class="dv">4</span>)</span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="dv">99</span> <span class="ot">-&gt;</span> cells</span></code></pre></div>
<p>Any other opcode results in the dreaded <code class="sourceCode haskell"><span class="fu">error</span></code> again. This time with a little debug info, although the error never arose.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a>    _  <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;invalid opcode &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> (cells <span class="op">!!</span> ip) <span class="op">&lt;&gt;</span> <span class="st">&quot; at &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> ip</span></code></pre></div>
<p>Performing an operation requires that the cell addresses can be evaluated. This is less of a firm assumption, as there would be many possible variable assignments that lead to functional but incorrect programs; for operands in particular programs would remain valid for all in-bounds addresses. Fortunately, this assumption also panned out.</p>
<p>The operand cells have their expressions retrieved. The destination cell is updated with a new expression using the two operands.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a>  <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>    op f cells ip <span class="ot">=</span> <span class="kw">let</span> a <span class="ot">=</span> cells <span class="op">!!</span> (evaluate <span class="op">$</span> cells <span class="op">!!</span> (ip <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb10-3"><a href="#cb10-3"></a>                        b <span class="ot">=</span> cells <span class="op">!!</span> (evaluate <span class="op">$</span> cells <span class="op">!!</span> (ip <span class="op">+</span> <span class="dv">2</span>))</span>
<span id="cb10-4"><a href="#cb10-4"></a>                        t <span class="ot">=</span> evaluate (cells <span class="op">!!</span> (ip <span class="op">+</span> <span class="dv">3</span>))</span>
<span id="cb10-5"><a href="#cb10-5"></a>                    <span class="kw">in</span> <span class="fu">take</span> t cells <span class="op">&lt;&gt;</span> (f a b <span class="op">:</span> <span class="fu">drop</span> (t <span class="op">+</span> <span class="dv">1</span>) cells)</span>
<span id="cb10-6"><a href="#cb10-6"></a>    add <span class="ot">=</span> op <span class="dt">Add</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>    mul <span class="ot">=</span> op <span class="dt">Mul</span></span></code></pre></div>
<p>The example program from the task is <code class="sourceCode haskell">[<span class="dv">1</span>, <span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">11</span>, <span class="dv">0</span>, <span class="dv">99</span>, <span class="dv">30</span>, <span class="dv">40</span>, <span class="dv">50</span>]</code>. With no variables defined, this program produces an expression tree:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a>mkExpr [] [<span class="dv">1</span>, <span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">11</span>, <span class="dv">0</span>, <span class="dv">99</span>, <span class="dv">30</span>, <span class="dv">40</span>, <span class="dv">50</span>] <span class="ot">=</span> <span class="dt">Mul</span> (<span class="dt">Add</span> (<span class="dt">Lit</span> <span class="dv">30</span>)</span>
<span id="cb11-2"><a href="#cb11-2"></a>                                                                (<span class="dt">Lit</span> <span class="dv">40</span>))</span>
<span id="cb11-3"><a href="#cb11-3"></a>                                                           (<span class="dt">Lit</span> <span class="dv">50</span>)</span></code></pre></div>
<p>And sure enough, (30 + 40) * 50 = 3500, the expected result.</p>
<p>Reading an expression tree isn’t all that fun though, so I added a pretty-printer that would parenthesis according to operator precedence:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="ot">pretty ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>pretty <span class="ot">=</span> pretty&#39; <span class="dv">0</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>  <span class="kw">where</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>    pretty&#39; p (<span class="dt">Lit</span> n) <span class="ot">=</span> <span class="fu">show</span> n</span>
<span id="cb12-5"><a href="#cb12-5"></a>    pretty&#39; p (<span class="dt">Var</span> n) <span class="ot">=</span> <span class="st">&quot;v&quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> n</span>
<span id="cb12-6"><a href="#cb12-6"></a>    pretty&#39; p (<span class="dt">Add</span> a b) <span class="ot">=</span> lparen p <span class="dv">1</span> <span class="op">&lt;&gt;</span> pretty&#39; <span class="dv">1</span> a <span class="op">&lt;&gt;</span> <span class="st">&quot; + &quot;</span> <span class="op">&lt;&gt;</span> pretty&#39; <span class="dv">1</span> b <span class="op">&lt;&gt;</span> rparen p <span class="dv">1</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>    pretty&#39; p (<span class="dt">Mul</span> a b) <span class="ot">=</span> lparen p <span class="dv">2</span> <span class="op">&lt;&gt;</span> pretty&#39; <span class="dv">2</span> a <span class="op">&lt;&gt;</span> <span class="st">&quot; * &quot;</span> <span class="op">&lt;&gt;</span> pretty&#39; <span class="dv">2</span> b <span class="op">&lt;&gt;</span> rparen p <span class="dv">2</span></span>
<span id="cb12-8"><a href="#cb12-8"></a>    lparen p q <span class="ot">=</span> <span class="kw">if</span> p <span class="op">&gt;</span> q <span class="kw">then</span> <span class="st">&quot;(&quot;</span> <span class="kw">else</span> <span class="st">&quot;&quot;</span></span>
<span id="cb12-9"><a href="#cb12-9"></a>    rparen p q <span class="ot">=</span> <span class="kw">if</span> p <span class="op">&gt;</span> q <span class="kw">then</span> <span class="st">&quot;)&quot;</span> <span class="kw">else</span> <span class="st">&quot;&quot;</span></span></code></pre></div>
<p>The result is easier to follow, and can be cut and paste into a command line calculator.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a>pretty (<span class="dt">Mul</span> (<span class="dt">Add</span> (<span class="dt">Lit</span> <span class="dv">30</span>) (<span class="dt">Lit</span> <span class="dv">40</span>)) (<span class="dt">Lit</span> <span class="dv">50</span>)) <span class="ot">=</span> (<span class="dv">30</span> <span class="op">+</span> <span class="dv">40</span>) <span class="op">*</span> <span class="dv">50</span></span></code></pre></div>
<p>And if the pretty printer is run on the expression result for the puzzle input with two variables:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a>pretty <span class="op">$</span>  mkExpr [<span class="dv">1</span>,<span class="dv">2</span>] puzzle <span class="op">!!</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dv">5</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">+</span> (<span class="dv">5</span> <span class="op">*</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> <span class="dv">3</span> <span class="op">*</span> (<span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>        ((<span class="dv">4</span> <span class="op">+</span> <span class="dv">4</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> v1 <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">3</span>) <span class="op">*</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span>))) <span class="op">+</span> <span class="dv">4</span>) <span class="op">*</span> <span class="dv">3</span>) <span class="op">*</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span> <span class="op">+</span> v2 <span class="op">+</span> <span class="dv">4</span></span></code></pre></div>
<p>The first observation to note about this is that <code>v2</code> is a simple offset, while <code>v1</code> has a multiplier. The equation will be of the form <span class="math inline">\(ax + y + b\)</span>, but first it must be simplified to reduce all those literals down to just <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="ot">simplify ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span></code></pre></div>
<p>This is an unremarkable expression simplifier, of the kind you’ll encounter over and over in any introduction to theorem proving, and many introductions to functional programming. The general gist of the addition simplifier is to look for opportunities to convert expressions of the form <code class="sourceCode haskell"><span class="dt">Add</span> (expr (<span class="dt">Lit</span> x)) (<span class="dt">Lit</span> y)</code> (i.e. “(expr + val) + val”) into expressions of the form <code class="sourceCode haskell"><span class="dt">Add</span> expr (<span class="dt">Lit</span> <span class="op">$</span> x <span class="op">+</span> y)</code>, removing one layer of nested addition. To accomplish this, the addition of two literals is immediately collapsed to one literal, any remaining literals on the left are moved to the right, the target sub-addition form is simplified, and any remaining nested literal additions have the literal moved to the outer expression.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a>simplify (<span class="dt">Add</span> a b) <span class="ot">=</span> <span class="kw">let</span> a&#39; <span class="ot">=</span> simplify a</span>
<span id="cb16-2"><a href="#cb16-2"></a>                         b&#39; <span class="ot">=</span> simplify b</span>
<span id="cb16-3"><a href="#cb16-3"></a>                      <span class="kw">in</span> <span class="kw">case</span> (a&#39;, b&#39;) <span class="kw">of</span></span>
<span id="cb16-4"><a href="#cb16-4"></a>                            (<span class="dt">Lit</span> x, <span class="dt">Lit</span> y)         <span class="ot">-&gt;</span> <span class="dt">Lit</span> (x <span class="op">+</span> y)</span>
<span id="cb16-5"><a href="#cb16-5"></a>                            (<span class="dt">Lit</span> _, _)             <span class="ot">-&gt;</span> simplify (<span class="dt">Add</span> b&#39; a&#39;)</span>
<span id="cb16-6"><a href="#cb16-6"></a>                            (<span class="dt">Add</span> x (<span class="dt">Lit</span> y), <span class="dt">Lit</span> z) <span class="ot">-&gt;</span> <span class="dt">Add</span> x (<span class="dt">Lit</span> <span class="op">$</span> y <span class="op">+</span> z)</span>
<span id="cb16-7"><a href="#cb16-7"></a>                            (<span class="dt">Add</span> x (<span class="dt">Lit</span> y), z)     <span class="ot">-&gt;</span> <span class="dt">Add</span> (<span class="dt">Add</span> x z) (<span class="dt">Lit</span> y)</span>
<span id="cb16-8"><a href="#cb16-8"></a>                            _                      <span class="ot">-&gt;</span> <span class="dt">Add</span> a&#39; b&#39;</span></code></pre></div>
<p>Multiplication looks for the same nested pattern. In addition, multiplication looks for the opportunity to distribute a literal multiplier into an addition where it can be recursively simplified.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a>simplify (<span class="dt">Mul</span> a b) <span class="ot">=</span> <span class="kw">let</span> a&#39; <span class="ot">=</span> simplify a</span>
<span id="cb17-2"><a href="#cb17-2"></a>                         b&#39; <span class="ot">=</span> simplify b</span>
<span id="cb17-3"><a href="#cb17-3"></a>                      <span class="kw">in</span> <span class="kw">case</span> (a&#39;, b&#39;) <span class="kw">of</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>                            (<span class="dt">Lit</span> x, <span class="dt">Lit</span> y)         <span class="ot">-&gt;</span> <span class="dt">Lit</span> (x <span class="op">*</span> y)</span>
<span id="cb17-5"><a href="#cb17-5"></a>                            (<span class="dt">Lit</span> _, _)             <span class="ot">-&gt;</span> simplify (<span class="dt">Mul</span> b&#39; a&#39;)</span>
<span id="cb17-6"><a href="#cb17-6"></a>                            (<span class="dt">Mul</span> x (<span class="dt">Lit</span> y), <span class="dt">Lit</span> z) <span class="ot">-&gt;</span> <span class="dt">Mul</span> x (<span class="dt">Lit</span> <span class="op">$</span> y <span class="op">*</span> z)</span>
<span id="cb17-7"><a href="#cb17-7"></a>                            (<span class="dt">Mul</span> x (<span class="dt">Lit</span> y), z)     <span class="ot">-&gt;</span> <span class="dt">Mul</span> (<span class="dt">Mul</span> x z) (<span class="dt">Lit</span> y)</span>
<span id="cb17-8"><a href="#cb17-8"></a>                            (<span class="dt">Add</span> x y, <span class="dt">Lit</span> _)       <span class="ot">-&gt;</span> <span class="dt">Add</span> (simplify (<span class="dt">Mul</span> x b&#39;))</span>
<span id="cb17-9"><a href="#cb17-9"></a>                                                          (simplify (<span class="dt">Mul</span> y b&#39;))</span>
<span id="cb17-10"><a href="#cb17-10"></a>                            _                        <span class="ot">-&gt;</span> <span class="dt">Mul</span> a&#39; b&#39;</span></code></pre></div>
<p>Anything else is a literal or a variable, and cannot be simplified further.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a>simplify cell <span class="ot">=</span> cell</span></code></pre></div>
<p>At this point, it’s a good idea to verify that <code class="sourceCode haskell">simplify</code> works as expected. I threw in the weakest kind of testing possible: check that evaluating my puzzle input when both simplified and unsimplified, using the task one values, produces the same output. This doesn’t check that I’ve simplified all possible expression forms, correctly or otherwise, only those encountered in my input. Ideally, it would use property-based checking to cover a wide range of variable values and programs, but I’m comfortable enough with this minor check on correctness.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a><span class="ot">test ::</span> <span class="dt">IO</span> ()</span>
<span id="cb19-2"><a href="#cb19-2"></a>test <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>    <span class="kw">let</span> expr <span class="ot">=</span> mkExpr [<span class="dv">1</span>, <span class="dv">2</span>] puzzle <span class="op">!!</span> <span class="dv">0</span></span>
<span id="cb19-4"><a href="#cb19-4"></a>    <span class="kw">let</span> r1 <span class="ot">=</span> evaluate <span class="op">$</span> subst <span class="dv">2</span> <span class="dv">2</span> <span class="op">$</span> subst <span class="dv">1</span> <span class="dv">12</span> expr</span>
<span id="cb19-5"><a href="#cb19-5"></a>    <span class="kw">let</span> r2 <span class="ot">=</span> evaluate <span class="op">$</span> subst <span class="dv">2</span> <span class="dv">2</span> <span class="op">$</span> subst <span class="dv">1</span> <span class="dv">12</span> <span class="op">$</span> simplify expr</span>
<span id="cb19-6"><a href="#cb19-6"></a>    <span class="fu">print</span> r1</span>
<span id="cb19-7"><a href="#cb19-7"></a>    <span class="fu">print</span> r2</span></code></pre></div>
<p>Let’s take a look at my puzzle’s simplified expression.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a>pretty <span class="op">$</span> simplify <span class="op">$</span> mkExpr [<span class="dv">1</span>,<span class="dv">2</span>] puzzle <span class="op">!!</span> <span class="dv">0</span> <span class="ot">=</span> v1 <span class="op">*</span> <span class="dv">360000</span> <span class="op">+</span> v2 <span class="op">+</span> <span class="dv">250635</span></span></code></pre></div>
<p>This is now of the expected form. Solving this by hand is, of course, trivial, but we’re not here to do things by hand. Except write code, which we’re dong by hand. The last important step is instead to compute the final answer. The expression above must equal <code class="sourceCode haskell"><span class="dv">19690720</span></code> to satisfy the task, giving an equation to solve. Fortunately, it’s a given that there is a unique integer solution, so a solver is trivial. Added literals are subtracted from both sides. Multiplied literals will produce a quotient and a remainder when dividing both sides, so an expression such as <span class="math inline">\(ax + y = b\)</span> means <span class="math inline">\(x\)</span> is the quotient and <span class="math inline">\(y\)</span> is the remainder.</p>
<p>If the simplifier has failed to reduce the expression into one of these forms, the solver will also fail. Which it does not, for my puzzle input.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a><span class="ot">solve ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)]</span>
<span id="cb21-2"><a href="#cb21-2"></a>solve (<span class="dt">Var</span> x) t                 <span class="ot">=</span> [(x, t)]</span>
<span id="cb21-3"><a href="#cb21-3"></a>solve (<span class="dt">Add</span> (<span class="dt">Mul</span> x (<span class="dt">Lit</span> y)) z) t <span class="ot">=</span> <span class="kw">let</span> (x&#39;, z&#39;) <span class="ot">=</span> t <span class="ot">`divMod`</span> y</span>
<span id="cb21-4"><a href="#cb21-4"></a>                                   <span class="kw">in</span> solve x x&#39; <span class="op">&lt;&gt;</span> solve z z&#39;</span>
<span id="cb21-5"><a href="#cb21-5"></a>solve (<span class="dt">Add</span> x (<span class="dt">Lit</span> y)) t         <span class="ot">=</span> solve x (t <span class="op">-</span> y)</span>
<span id="cb21-6"><a href="#cb21-6"></a>solve e t                       <span class="ot">=</span> <span class="fu">error</span> <span class="op">$</span> <span class="fu">show</span> e <span class="op">&lt;&gt;</span> <span class="st">&quot; = &quot;</span> <span class="op">&lt;&gt;</span> <span class="fu">show</span> t</span></code></pre></div>
<p>All that’s left to do is run the whole thing.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb22-2"><a href="#cb22-2"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb22-3"><a href="#cb22-3"></a>    <span class="kw">let</span> expr <span class="ot">=</span> simplify <span class="op">$</span> mkExpr [<span class="dv">1</span>, <span class="dv">2</span>] puzzle <span class="op">!!</span> <span class="dv">0</span></span>
<span id="cb22-4"><a href="#cb22-4"></a>    <span class="fu">putStrLn</span> <span class="op">$</span> pretty expr <span class="op">&lt;&gt;</span> <span class="st">&quot; = 19690720&quot;</span></span>
<span id="cb22-5"><a href="#cb22-5"></a>    <span class="kw">let</span> vars <span class="ot">=</span> solve expr <span class="dv">19690720</span></span>
<span id="cb22-6"><a href="#cb22-6"></a>    <span class="fu">maybe</span> (<span class="fu">error</span> <span class="st">&quot;no solution&quot;</span>) <span class="fu">print</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb22-7"><a href="#cb22-7"></a>        noun <span class="ot">&lt;-</span> <span class="fu">lookup</span> <span class="dv">1</span> vars</span>
<span id="cb22-8"><a href="#cb22-8"></a>        verb <span class="ot">&lt;-</span> <span class="fu">lookup</span> <span class="dv">2</span> vars</span>
<span id="cb22-9"><a href="#cb22-9"></a>        <span class="fu">pure</span> (noun <span class="op">*</span> <span class="dv">100</span> <span class="op">+</span> verb)</span></code></pre></div>
<p>Which produces the output:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a>v1 <span class="op">*</span> <span class="dv">360000</span> <span class="op">+</span> v2 <span class="op">+</span> <span class="dv">250635</span> <span class="ot">=</span> <span class="dv">19690720</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="dv">5485</span></span></code></pre></div>
<p>The icon for this post is copyright <a href="https://thenounproject.com/term/advent-calendar/28226/">Claire Jones</a>, used without modification under a Creative Commons license.</p>]]></summary>
</entry>
<entry>
    <title>The TRS-20 - system bus</title>
    <link href="https://bje.id.au/blog/posts/trs20/002-system-bus.html" />
    <id>https://bje.id.au/blog/posts/trs20/002-system-bus.html</id>
    <published>2019-11-23T00:00:00Z</published>
    <updated>2019-11-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This project is influenced by Quinn Dunki’s 6502 homebrew machine <a href="https://blondihacks.com/veronica/">Veronica</a>, and a little by Radical Brad’s 74-series logic based <a href="http://forum.6502.org/viewtopic.php?f=4&amp;t=3329">Vulcan-74</a>. Along with these two are a large number of existing homebrew computer builds, whose details provide me with a wealth of information on design ideas and likely problems I will face. There are even several kits available for order that solve a number of those problems for you.</p>
<p>Nevertheless, I will strike out on my own with a unique design, starting with the system bus.</p>
<!--more-->
<p>This project has no purpose beyond its own journey. I have a computer already, so I don’t need to build one to get any work done. My computer is powerful enough to emulate an 8-bit 2MHz machine a dozen times simultaneously, so I don’t need to build one just to run some old software. Instead, the reason for this project is to connect at a more fundamental level with what a computer is, and how it works. Using a kit doesn’t achieve this - my understanding would remain theoretical, skipping over the hands-on experience of trying to get a bunch of ICs to come together as a working system.</p>
<p>Flimsy justification out of the way, let’s talk system bus design.</p>
<p>My experience with assembling PCs has exposed me to a common design pattern - a motherboard into which expansion cards are slotted. A variation on this pattern is used by the <a href="https://rc2014.co.uk/">RC2014</a> system, by the Veronica, and by the <a href="http://linc.no/products/z50bus/">Z50</a>, amongst others. Rather than a motherboard carrying the CPU and core system components, though, these systems all have an uncomplicated parallel bus backplane board, and the CPU plugs in just like all the peripheral cards. This is a sensible choice, as the bus can be kept stable even if the CPU board iterates - or even changes processor entirely.</p>
<figure>
<img src="/images/rc2014.jpg" alt="" /><figcaption>The <a href="https://rc2014.co.uk/">RC2014</a> design looks neat and works well.</figcaption>
</figure>
<p>The RC2014, the Z50, and the Veronica are all motherboard designs with daughterboards rising vertically. They vary in the connector technology and pin count, but not widely. None of them are very well suited to my constraints on board size and my use of a Z180. 40-pin headers are slightly over 100mm long, exceeding my board budget. Trimming them takes an already heavily constrained signal set (down from 65 exposed on the Z180) and worsens the situation. ISA edge connectors are more suitable and remain a viable option, though 62 contacts means I’d need to skip three CPU signals and have no spare capacity for any other signals.</p>
<p>The winning choice, in the end, comes from a 30 year old standard for embedded systems. <a href="https://pc104.org/">PC/104</a> is a vertical stack of small boards, using board to board connectors to run a bus, and standoffs to provide stability. Each board should be 90.17x95.89mm in size, with a 13mm allowance for I/O connectors at some edges, allowing me to use most of my board budget.</p>
<figure>
<img src="/images/pc104-stack.jpg" alt="" /><figcaption>A little stack of boards makes for an even better homebrew computer.</figcaption>
</figure>
<p>The original PC/104 bus was an ISA 8-bit (PC/XT) bus, with a 32x2 2.54mm pitch header for the board to board connections. This was subsequently updated to add a 20x2 header for a 16-bit ISA (PC/AT) bus. The original ISA bus uses edge connectors, not pin headers. The use of headers reduces the size of the bus connector down to fit on the PC/104 footprint. Subsequent revisions add a 4x30 header to carry a PCI bus, remove the ISA bus, add a PCI Express bus, and finally remove the PCI bus. These various kinds of bus connector are visible in the image above, but I’ll be sticking to the 16-bit ISA connectors - these are the headers included in my first round of parts.</p>
<p>It remains to be see whether I’ll actually use the ISA bus signals as they’re meant to be used. There isn’t exactly a real <a href="https://en.wikipedia.org/wiki/Industry_Standard_Architecture">ISA bus</a> specification, but the book “ISA and EISA: Theory and Operation” is about as close as it gets. There’s a few parts of correct ISA operation that might cause problems for my project. The ISA bus should be clocked at either 8MHz or 8.33MHz, though it’s reasonable to share the CPU clock. The clock isn’t particularly critical though, since the bus is asynchronous, with expected response times for each signal edge. There’s enough in common with the Z80’s system bus that a bridge should be practical to build, but it may have implications for whether I can get zero wait-state memory on the bus. To be determined…</p>
<p>I’m pleased with the notion of the PC/104 form factor. However, if it doesn’t work out as I’d like, I will fall back on more typical edge connectors. Five 2.54mm pitch 72-pin edge connectors is less than $15, and less than 100mm across (89mm for the pins, plus room for the edge of the header). PCI connectors have 120 pins, and at 1.27mm pitch are a comfortable 90mm or so for the whole connector, and cost about the same.</p>
<p>Meanwhile, because I’d like QFP parts to be an option I’ve also spent $5.84 on SMD soldering practice boards. The boards come with two QFP-44 chips each, some SOICs, a handful of resistors from 0402 up to 0805, some SOT23 chips, and some 0606 resistor arrays. Using SMD means more available parts, lower costs, and more effective use of my rather limited board space - but poking things with a hot metal stick might not cut it for much longer.</p>
<table style="width:86%;">
<caption>Project status update</caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 10%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Budget</th>
<th style="text-align: center;">CPU</th>
<th style="text-align: center;">Power</th>
<th style="text-align: center;">Keyboard</th>
<th style="text-align: center;">Video</th>
<th style="text-align: center;">Memory</th>
<th style="text-align: center;">Debug</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">$54.03 of $400</td>
<td style="text-align: center;">█───</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">█───</td>
</tr>
</tbody>
</table>]]></summary>
</entry>
<entry>
    <title>The TRS-20 - a homebrew Z80 machine</title>
    <link href="https://bje.id.au/blog/posts/trs20/001-ideas.html" />
    <id>https://bje.id.au/blog/posts/trs20/001-ideas.html</id>
    <published>2019-11-10T00:00:00Z</published>
    <updated>2019-11-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>My first computer was a TRS-80 Model I, a device that was first sold before I was born. Some time after I was born, I got my hands on one, starting my 30-odd year journey in computing.</p>
<p>For the sake of nostalgia, I’m embarking on a journey to build a homebrew Z80-based machine, loosely based on the TRS-80 Model I. The build will take place in 2020, and so the machine will be called the TRS-20.</p>
<!--more-->
<p>The Model I is not a particularly high bar to reach, these days. It had 4KB of memory, a cassette drive for storage, and a monochrome video display capable of 64 characters over 16 rows - selected to fill exactly 1024 bytes of video memory. In graphics mode, each character cell becomes a 2x3 grid of addressable pixels. My Model I was a low-end model, with no expansions of note. Wikipedia can provide a <a href="https://en.wikipedia.org/wiki/TRS-80">thorough background</a> on the original compter.</p>
<figure>
<img src="/images/trs80-model1.jpg" alt="" /><figcaption>The TRS-80 Model I. Image by <a href="https://www.flickr.com/photos/eevblog/14761087591/">Dave Jones</a>.</figcaption>
</figure>
<p>The basics of my computer are set by my inspiration: I’ll be using a processor from the Z80 family, it will have RAM and ROM occupying the same 64K space, and peripherals will mostly also steal a bit of memory space instead of using the Z80’s (originally absurdly limited) I/O space.</p>
<p>I will use a Z180 processor, most likely the <a href="https://en.wikipedia.org/wiki/Zilog_Z180">Z8S180</a>. This is not perfectly compatible with the original Z80, though I anticipate being able to manage the incompatibilities in the glue logic for the sake of running original TRS-80 software.</p>
<p>I will need to design a series of boards, roughly broken down along these lines:</p>
<ol type="1">
<li>A motherboard or CPU board.</li>
<li>A ROM and RAM board.</li>
<li>An I/O board for USB keyboard input.</li>
<li>A video display board for VGA or HDMI output.</li>
<li>Development and debugging</li>
<li>External storage</li>
</ol>
<p>The constraints on the system are a total budget target of AUD400, the use of the free edition of Eagle PCB software, and only parts I can solder with a reasonable extrapolation of my current abilities. These constraints limit me to a maximum board size of 100x100mm, to through-hole and the larger SMD parts where all solder surfaces are accessible to an iron, and to avoiding the need for costly new tools.</p>
<p>The first round of spending will largely be experimental - DIP adapter boards to try my hand at soldering TSSOP logic chips and TSOP SRAM chips, an STM32F401 to try as a USB Host for keyboard input, and a now quite aged Altera EPM7128S CPLD chip for video signal generation. Adding in a 20x4 character LED board for debug output takes me up to around $50, an eighth of my budget spent without any actual board progress, so I’ll round the spend up to $50 with a cheap Z8018010VSC processor, a 10MHz Z180 in a PLCC68 package, because mounting my CPU in a socket feels like a good plan.</p>
<table>
<caption>Aliexpress offers a fine selection of electronics of dubious origin and veracity.</caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 12%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Item</th>
<th style="text-align: left;">Price</th>
<th style="text-align: left;">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Z8018010SVC</td>
<td style="text-align: left;">$2.46</td>
<td style="text-align: left;">Low-cost PLCC68 Z180 processor for initial prototyping</td>
</tr>
<tr class="even">
<td style="text-align: left;">USB Blaster</td>
<td style="text-align: left;">$4.29</td>
<td style="text-align: left;">Altera CPLD/FPGA programmer</td>
</tr>
<tr class="odd">
<td style="text-align: left;">PLCC sockets</td>
<td style="text-align: left;">$5.51</td>
<td style="text-align: left;">5 each of PLCC68 and PLCC84 through-hole sockets</td>
</tr>
<tr class="even">
<td style="text-align: left;">PLCC IC tool</td>
<td style="text-align: left;">$1.17</td>
<td style="text-align: left;">Tool for yanking PLCC chips out of sockets</td>
</tr>
<tr class="odd">
<td style="text-align: left;">STM32F401</td>
<td style="text-align: left;">$5.00</td>
<td style="text-align: left;">STM32F401CCU6 development board, for USB host trials</td>
</tr>
<tr class="even">
<td style="text-align: left;">20x4 LCD, I²C adapter, acrylic case</td>
<td style="text-align: left;">$9.02</td>
<td style="text-align: left;">Display for debug output</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TSSOP and TSOP adapters</td>
<td style="text-align: left;">$10.38</td>
<td style="text-align: left;">10xTSSOP-24 and 5xTSOP56 adapters for soldering trials</td>
</tr>
<tr class="even">
<td style="text-align: left;">Pin headers</td>
<td style="text-align: left;">$11.19</td>
<td style="text-align: left;">Pin headers, whose purpose is the subject of the next post</td>
</tr>
<tr class="odd">
<td style="text-align: left;">STM32F03, EPM7128S</td>
<td style="text-align: left;">$3.61</td>
<td style="text-align: left;">TSSOP MCU for soldering, PLCC84 CPLD for trials</td>
</tr>
</tbody>
</table>
<p>There was a discount of $4.44 applied this order, bringing the total down to under $50. This order alone doesn’t give me any single workable item: I will see if I can make my cheap STM32F03 (50c!) function as a driver for the debug LCD display, and begin putting together what I’ll need to drive the processor with data lines tied to run a NOP through the address space. With 30 to 50 days delivery on most of the above, I’ve now got plenty of lead time to prepare.</p>
<p>Below is my project status update table. Each component gains a bar of progress meter for having a rough design, a proof of concept, a completed design, all parts ready, and a working board. Components may backslide if the produced board has enough flaws to send me back to the design or experimental stage. I am using box drawing characters in preparation for my return the glory that is a TRS-80’s graphics system.</p>
<table style="width:86%;">
<caption>Project status update</caption>
<colgroup>
<col style="width: 21%" />
<col style="width: 8%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 10%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Budget</th>
<th style="text-align: center;">CPU</th>
<th style="text-align: center;">Power</th>
<th style="text-align: center;">Keyboard</th>
<th style="text-align: center;">Video</th>
<th style="text-align: center;">Memory</th>
<th style="text-align: center;">Debug</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">$48.19 of $400</td>
<td style="text-align: center;">█───</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">────</td>
<td style="text-align: center;">█───</td>
</tr>
</tbody>
</table>]]></summary>
</entry>

</feed>
